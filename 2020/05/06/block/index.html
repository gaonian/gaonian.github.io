<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>block解析 | GN</title><meta name="description" content="block解析"><meta name="author" content="GN"><meta name="copyright" content="GN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="block解析"><meta name="twitter:description" content="block解析"><meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846"><meta property="og:type" content="article"><meta property="og:title" content="block解析"><meta property="og:url" content="http://lmzcool.top/2020/05/06/block/"><meta property="og:site_name" content="GN"><meta property="og:description" content="block解析"><meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://lmzcool.top/2020/05/06/block/"><link rel="next" title="iOS图片移到assets问题记录" href="http://lmzcool.top/2020/04/10/image_assets/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#声明"><span class="toc-number">1.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建"><span class="toc-number">1.2.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用blocks"><span class="toc-number">1.3.</span> <span class="toc-text">使用blocks</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用block作为函数、方法参数"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用block作为函数、方法参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blocks和变量"><span class="toc-number">1.4.</span> <span class="toc-text">Blocks和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#block修饰类型"><span class="toc-number">1.4.1.</span> <span class="toc-text">__block修饰类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-和-Block变量"><span class="toc-number">1.4.2.</span> <span class="toc-text">Object 和 Block变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block存储位置"><span class="toc-number">1.4.3.</span> <span class="toc-text">Block存储位置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block本质"><span class="toc-number">2.</span> <span class="toc-text">block本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#block修饰符"><span class="toc-number">2.1.</span> <span class="toc-text">__block修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#block可修饰类型"><span class="toc-number">2.1.1.</span> <span class="toc-text">__block可修饰类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forwarding"><span class="toc-number">2.1.2.</span> <span class="toc-text">__forwarding</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block-Copy-Release"><span class="toc-number">2.2.</span> <span class="toc-text">Block Copy&#x2F;Release</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-copy"><span class="toc-number">2.2.1.</span> <span class="toc-text">_Block_copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-release"><span class="toc-number">2.2.2.</span> <span class="toc-text">_Block_release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-object-assign"><span class="toc-number">2.2.3.</span> <span class="toc-text">_Block_object_assign</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-object-dispose"><span class="toc-number">2.2.4.</span> <span class="toc-text">_Block_object_dispose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-byref-copy"><span class="toc-number">2.2.5.</span> <span class="toc-text">_Block_byref_copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Block-byref-release"><span class="toc-number">2.2.6.</span> <span class="toc-text">_Block_byref_release</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Block循环引用"><span class="toc-number">2.3.</span> <span class="toc-text">Block循环引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block内部引用对象"><span class="toc-number">3.</span> <span class="toc-text">block内部引用对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hook-block"><span class="toc-number">4.</span> <span class="toc-text">hook block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">GN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">block解析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-06 13:18:31"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-13 00:40:26"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/06/block/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/06/block/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Blocks是C语言的扩充功能。可以用一句话来表示Blocks的扩充功能：带有自动变量（局部变量）的匿名函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> multiplier = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> (^myBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num) &#123;</span><br><span class="line">	<span class="keyword">return</span> num * multiplier;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2020/5/11/1720422c616b92ef?w=689&h=279&f=png&s=142422"  alt=""></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>Block变量保存对block的引用，使用类似于声明函数指针的语法来声明他们，除了使用 ^ 代替 * ，block类型可以与c类型系统的其余部分完全互相操作。以下是所有有效的block变量声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>（^ blockReturningVoidWithVoidArgument）（<span class="keyword">void</span>）;</span><br><span class="line"><span class="keyword">int</span>（^ blockReturningIntWithIntAndCharArguments）（<span class="keyword">int</span>，<span class="keyword">char</span>）;</span><br><span class="line"><span class="keyword">void</span>（^ arrayOfTenBlocksReturningVoidWithIntArgument [<span class="number">10</span>]）（<span class="keyword">int</span>）;</span><br></pre></td></tr></table></figure>

<p>block还可以支持可变参数(……)，不带参数的block必须在参数列表中指定为void</p>
<p>当在多个位置使用相同的block时，通常可以使用typedef为block创建类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">float</span> <span class="params">(^MyBlockType)</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">MyBlockType myFirstBlock = <span class="comment">// ... ;</span></span><br><span class="line">MyBlockType mySecondBlock = <span class="comment">// ... ;</span></span><br></pre></td></tr></table></figure>



<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> (^oneFrom)(<span class="keyword">float</span>);</span><br><span class="line"> </span><br><span class="line">oneFrom = ^(<span class="keyword">float</span> aFloat) &#123;</span><br><span class="line">    <span class="keyword">float</span> result = aFloat - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>block是由  <code>^ 返回值类型 参数列表 表达式</code> 几部分组成的，返回值类型和参数列表和c语言函数一致，表达式中含有return语句时，其类型必须与返回值类型相同</p>
<p>完整形式的block语言与一般的c语言函数定义相比，仅有两点不同：</p>
<ul>
<li>没有函数名</li>
<li>带有 <strong>^</strong></li>
</ul>
<h3 id="使用blocks"><a href="#使用blocks" class="headerlink" title="使用blocks"></a>使用blocks</h3><p>如果声明了一个block为变量，则可以像函数一样使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (^oneFrom)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> anInt) &#123;</span><br><span class="line">    <span class="keyword">return</span> anInt - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1 from 10 is %d"</span>, oneFrom(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// Prints "1 from 10 is 9"</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">float</span> (^distanceTraveled)(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>) =</span><br><span class="line">                         ^(<span class="keyword">float</span> startingSpeed, <span class="keyword">float</span> acceleration, <span class="keyword">float</span> time) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> distance = (startingSpeed * time) + (<span class="number">0.5</span> * acceleration * time * time);</span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">float</span> howFar = distanceTraveled(<span class="number">0.0</span>, <span class="number">9.8</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// howFar = 4.9</span></span><br></pre></td></tr></table></figure>

<p>但是，经常会将block作为参数传递给函数或方法。在这些情况下，通常会创建一个block “inline”</p>
<h4 id="使用block作为函数、方法参数"><a href="#使用block作为函数、方法参数" class="headerlink" title="使用block作为函数、方法参数"></a>使用block作为函数、方法参数</h4><p>可以像传递任何其他参数一样，将block作为函数参数传递。然而，在许多情况下，不需要声明block；相反，只需在需要block作为参数的地方内联实现它们</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *myCharacters[<span class="number">3</span>] = &#123; <span class="string">"TomJohn"</span>, <span class="string">"George"</span>, <span class="string">"Charles Condomine"</span> &#125;;</span><br><span class="line"> </span><br><span class="line">qsort_b(myCharacters, <span class="number">3</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *), ^(<span class="keyword">const</span> <span class="keyword">void</span> *l, <span class="keyword">const</span> <span class="keyword">void</span> *r) &#123;</span><br><span class="line">    <span class="keyword">char</span> *left = *(<span class="keyword">char</span> **)l;</span><br><span class="line">    <span class="keyword">char</span> *right = *(<span class="keyword">char</span> **)r;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(left, right, <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Block implementation ends at "&#125;"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// myCharacters is now &#123; "Charles Condomine", "George", "TomJohn" &#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dispatch/dispatch.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">dispatch_apply(count, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%u\n"</span>, i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NSArray *<span class="built_in">array</span> = @[@<span class="string">"A"</span>, @<span class="string">"B"</span>, @<span class="string">"C"</span>, @<span class="string">"A"</span>, @<span class="string">"B"</span>, @<span class="string">"Z"</span>, @<span class="string">"G"</span>, @<span class="string">"are"</span>, @<span class="string">"Q"</span>];</span><br><span class="line">NSSet *filterSet = [NSSet setWithObjects: @<span class="string">"A"</span>, @<span class="string">"Z"</span>, @<span class="string">"Q"</span>, nil];</span><br><span class="line"> </span><br><span class="line">BOOL (^test)(id obj, NSUInteger idx, BOOL *<span class="built_in">stop</span>);</span><br><span class="line"> </span><br><span class="line">test = ^(id obj, NSUInteger idx, BOOL *<span class="built_in">stop</span>) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (idx &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([filterSet containsObject: obj]) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">NSIndexSet *indexes = [<span class="built_in">array</span> indexesOfObjectsPassingTest:test];</span><br><span class="line"> </span><br><span class="line">NSLog(@<span class="string">"indexes: %@"</span>, indexes);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">indexes: &lt;NSIndexSet: 0x10236f0&gt;[number of indexes: 2 (in 2 ranges), indexes: (0 3)]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="Blocks和变量"><a href="#Blocks和变量" class="headerlink" title="Blocks和变量"></a>Blocks和变量</h3><p>在block对象的代码体中，变量可以用五种不同的方式处理。</p>
<p>可以引用三种标准类型的变量，就像引用函数一样：</p>
<ul>
<li><p>全局变量，包括静态局部变量</p>
</li>
<li><p>全局函数（技术上是不可变的）</p>
</li>
<li><p>局部变量和参数</p>
</li>
</ul>
<p>Blocks也支持其他两种类型的变量:</p>
<ol>
<li><code>__block</code> 修饰的变量，它们在block（和封闭作用域）中是可变的，并且如果有任何引用block复制到堆中，它们将被保留。</li>
<li>const imports</li>
</ol>
<p>最后，在方法实现中，block可以引用Objective-C实例变量.</p>
<p>以下规则适用于块中使用的变量：</p>
<ul>
<li>全局变量，静态全局变量，静态变量，自动变量</li>
<li>传递给block的参数（就像传递给函数的参数一样）</li>
<li>用<code>__block</code>修饰符修饰的局部变量</li>
</ul>
<p>下面例子展示了使用非静态的自动变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">printXAndY(<span class="number">456</span>); <span class="comment">// prints: 123 456</span></span><br></pre></td></tr></table></figure>

<p>在尝试修改x的值时，会出现error</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">123</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) &#123;</span><br><span class="line"> </span><br><span class="line">    x = x + y; <span class="comment">// error</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若要允许在block中更改变量，请使用 <code>__block</code> 修饰符</p>
<h4 id="block修饰类型"><a href="#block修饰类型" class="headerlink" title="__block修饰类型"></a>__block修饰类型</h4><p>通过 <code>__block</code> 修饰符可以使外部导入的变量可变的，即读写。__block可以同register，auto，static一样修饰局部变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">int</span> x = <span class="number">123</span>; <span class="comment">//  x lives in block storage</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> (^printXAndY)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> y) &#123;</span><br><span class="line"> </span><br><span class="line">    x = x + y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, x, y);</span><br><span class="line">&#125;;</span><br><span class="line">printXAndY(<span class="number">456</span>); <span class="comment">// prints: 579 456</span></span><br><span class="line"><span class="comment">// x is now 579</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> NSInteger CounterGlobal;</span><br><span class="line"><span class="keyword">static</span> NSInteger CounterStatic;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    NSInteger localCounter = <span class="number">42</span>;</span><br><span class="line">    __block <span class="keyword">char</span> localCharacter;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> (^aBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>) &#123;</span><br><span class="line">        ++CounterGlobal;</span><br><span class="line">        ++CounterStatic;</span><br><span class="line">        CounterGlobal = localCounter; <span class="comment">// localCounter fixed at block creation</span></span><br><span class="line">        localCharacter = <span class="string">'a'</span>; <span class="comment">// sets localCharacter in enclosing scope</span></span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ++localCounter; <span class="comment">// unseen by the block</span></span><br><span class="line">    localCharacter = <span class="string">'b'</span>;</span><br><span class="line"> </span><br><span class="line">    aBlock(); <span class="comment">// execute the block</span></span><br><span class="line">    <span class="comment">// localCharacter now 'a'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Object-和-Block变量"><a href="#Object-和-Block变量" class="headerlink" title="Object 和 Block变量"></a>Object 和 Block变量</h4><p>Blocks支持OC、c++对象、和另外的block作为变量</p>
<p>拷贝block时，它会创建对block中使用的对象变量的强引用</p>
<ul>
<li>如果通过引用访问实例变量，则对self进行强引用</li>
<li>如果通过值访问实例变量，则会对该变量进行强引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="comment">// instanceVariable is used by reference, a strong reference is made to self</span></span><br><span class="line">    doSomethingWithObject(instanceVariable);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">id localVariable = instanceVariable;</span><br><span class="line">dispatch_async(<span class="built_in">queue</span>, ^&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      localVariable is used by value, a strong reference is made to localVariable</span></span><br><span class="line"><span class="comment">      (and not to self).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    doSomethingWithObject(localVariable);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="Block存储位置"><a href="#Block存储位置" class="headerlink" title="Block存储位置"></a>Block存储位置</h4><p>block具体有三种类型</p>
<ul>
<li><p><code>__NSGlobalBlock__</code>  全局区</p>
<p>没有访问外部变量 或者 只访问全局变量、静态变量、全局静态变量，这种情况下存放在全局区。生命周期从创建到应用程序结束。</p>
</li>
<li><p><code>__NSStackBlock__</code> 栈区</p>
<p>用到外部局部变量，没有强指针引用的block都是放在栈区。作用域结束，就被销毁。</p>
<p>在arc下，以下情况默认会将block从栈区拷贝到堆区</p>
<ul>
<li>手动调用copy</li>
<li>Block作为函数的返回值</li>
<li>Block被强引用，Block被赋值给<code>__strong</code> 或者id类型</li>
<li>调用系统API入参中含有usingBlock的方法</li>
</ul>
</li>
<li><p><code>__NSMallocBlock__</code> 堆区</p>
<p>访问了处于堆区的变量，有强指针引用等就会放在堆区</p>
</li>
</ul>
<h2 id="block本质"><a href="#block本质" class="headerlink" title="block本质"></a>block本质</h2><p>上节描述了block的使用和一些使用规则。看到了如果在block内修改局部变量会直接报错，接下来就从这个角度来分析block的本质</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, a);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, a);</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result:</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>这里有两种方法去窥探一下block的本质</p>
<ol>
<li>执行clang命令把代码转换为cpp，可以基本上看到苹果内部是怎么实现的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过<a href="https://opensource.apple.com/source/libclosure/" target="_blank" rel="noopener">官方开源库</a> 查看 <code>Block_private.h</code> 头文件可以看到block的定义。这里看到的代码和第一种方式转换出来的基本保持一致</li>
</ol>
<p>我们看通过第一种转换出来的cpp文件，有三万多行代码，直接拉到最底部就可以找到main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br><span class="line"></span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, a);</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void (*block)(void) &#x3D; ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a));</span><br></pre></td></tr></table></figure>

<p>这一行是我们写的block的定义和创建，实际调用了<code>__main_block_impl_0</code> 函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _a, <span class="keyword">int</span> flags=<span class="number">0</span>) : a(_a) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/" class="lazyload" data-src="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&h=500&f=png&s=23846"  alt="block_layout"></p>
<p>从代码上也可以看出block的布局，上图引用网上一张著名的block_layout图片。</p>
<ul>
<li><p>第一个就是isa，oc中所有对象都有isa，从这点可以判断block实际也是一个oc对象</p>
</li>
<li><p>flags对象block的一些状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for Block_layout-&gt;flags to describe block objects</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_DEALLOCATING =      (<span class="number">0x0001</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_REFCOUNT_MASK =     (<span class="number">0xfffe</span>),  <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_NEEDS_FREE =        (<span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_HAS_COPY_DISPOSE =  (<span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_CTOR =          (<span class="number">1</span> &lt;&lt; <span class="number">26</span>), <span class="comment">// compiler: helpers have C++ code</span></span><br><span class="line">    BLOCK_IS_GC =             (<span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line">    BLOCK_IS_GLOBAL =         (<span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_USE_STRET =         (<span class="number">1</span> &lt;&lt; <span class="number">29</span>), <span class="comment">// compiler: undefined if !BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    BLOCK_HAS_SIGNATURE  =    (<span class="number">1</span> &lt;&lt; <span class="number">30</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_HAS_EXTENDED_LAYOUT=(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)  <span class="comment">// compiler</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>reserved 目前从资料上来看是保留未用的</p>
</li>
<li><p>invoke 指向函数指针，调用invoke实际上就是实现的block内部代码</p>
</li>
<li><p>descriptor 对应的是 <code>Block_descriptor_*</code> 结构体</p>
<ul>
<li>reserved</li>
<li>size： 整个block内存布局的大小</li>
<li>copy、dispose： 对应外部对象类型捕获的内存管理</li>
<li>signature：block的方法签名，对应flags <code>BLOCK_HAS_SIGNATURE</code></li>
<li>layout：描述了block外部引用对象的内存布局，对应flags <code>BLOCK_HAS_EXTENDED_LAYOUT</code></li>
</ul>
</li>
<li><p>variables: block捕获的外部对象或者基本类型数据都会在这里展示，例如int a、Person *p对象。具体多少有多少对象可以根据desc3的layout获取到</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  Person *p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>上面简单分析了block的内存布局，接下来回到调用时候的传递参数，传了三个参数，分别对应构造函数的形参</p>
<ul>
<li><p><code>__main_block_func_0</code> 赋值给了impl.FuncPtr，也就是调用的函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, a);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>也就是说调用block的时候会调用__main_block_func_0这个函数，内部实现的代码就是我们之前写的block的代码</p>
</li>
<li><p><code>__main_block_desc_0_DATA</code>  主要是对应的一些描述信息。对应Desc，也就是 <code>__main_block_desc_0</code> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure>

<p>reserved字段保留为0，block_size是整个 __main_block_impl_0 的大小</p>
</li>
<li><p>第三个字段 a 就是我们定义的局部变量，在<code>__main_block_impl_0</code>内部同时也有一个int a，这里直接把外面的局部变量值直接赋值给了内部的int a。</p>
</li>
<li><p>如果有多个引用，比如还引用了一个person对象，这里就会把person对象也传递进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a, p, <span class="number">570425344</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后一个参数是flags，对应的就是block_layout -&gt; flags，具体falgs类型上部分有提到</p>
</li>
</ul>
<p>至此，block的定义和实现部分转换后的代码基本分析完毕了。接着往下看调用的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br></pre></td></tr></table></figure>

<p>直接就是调用 block -&gt; FuncPtr，上面已经提到了，FuncPtr就是对应的block的内部实现代码，就是调用的 <code>__main_block_func_0</code> </p>
<p>从上面的分析可以看出来一点为什么局部变量的值没有被修改，因为是把外部值直接传递给了我们内部自己定义的 int a，所以在外面的所有修改已经和内部没有关系了。</p>
<h3 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h3><p>如果想要修改局部变量的值，官方给出的做法就是在变量定义前加上 <code>__block</code> 修饰符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        Person *p = [[Person alloc] init];</span><br><span class="line">        p.age = <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d \n"</span>, a, p.age);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        a = <span class="number">20</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, a);</span><br><span class="line">        </span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加上<code>__block</code> 修饰符之后，运行结果是符合预期的。我们再转换为cpp文件看一看发生了什么变化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_a_0 *)&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_a_0), <span class="number">10</span>&#125;;</span><br><span class="line">                            </span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> (*block)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, <span class="number">570425344</span>));</span><br><span class="line"></span><br><span class="line">        (a.__forwarding-&gt;a) = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (a.__forwarding-&gt;a));</span><br><span class="line"></span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比之前发现了定义变量的地方变的复杂了很多，生成了一个<code>__Block_byref_a_0</code> 对象，可以看到实际上也是一个oc对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_a_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_a_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>第二个参数 <code>__forwarding</code> 对应的是自身</li>
<li>第四个参数是size</li>
<li>最后一个参数是保存的局部变量的值</li>
</ul>
<p>接着来看一下block的内部布局发生了什么变化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_a_0 *a; <span class="comment">// by ref</span></span><br><span class="line">  </span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, Person *_p, __Block_byref_a_0 *_a, <span class="keyword">int</span> flags=<span class="number">0</span>) : p(_p), a(_a-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>之前的 int a，现在变成了 <code>__Block_byref_a_0 *a;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_a_0 *a = __cself-&gt;a; <span class="comment">// bound by ref</span></span><br><span class="line">  Person *p = __cself-&gt;p; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d \n"</span>, (a-&gt;__forwarding-&gt;a), ((<span class="keyword">int</span> (*)(id, SEL))(<span class="keyword">void</span> *)objc_msgSend)((id)p, sel_registerName(<span class="string">"age"</span>)));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>具体实现里面也是通过调用__Block_byref_a_0对象内部的a也获取值</p>
<p>外部修改值得时候，也会对应的修改byref对象内部的值，所以在里面我们获取的就是最新值</p>
<p>总结来说，使用<code>__block</code> 修饰符的时候，会将基本数据类型包装成一个<code>__Block_byref_a_0</code> 对象类型，基本数据类型的值存储在对象内部的属性中。</p>
<h4 id="block可修饰类型"><a href="#block可修饰类型" class="headerlink" title="__block可修饰类型"></a>__block可修饰类型</h4><p><code>__block</code> 可修饰的类型可以分为三种，每一种类型的处理方式也不一样，具体处理会在下面<code>_Block_byref_copy</code> 部分讲解</p>
<ul>
<li>修饰变量 <code>__block int a</code></li>
<li>修饰OC对象 <code>__block id p</code></li>
<li>修饰block <code>__block (^block)</code></li>
</ul>
<h4 id="forwarding"><a href="#forwarding" class="headerlink" title="__forwarding"></a>__forwarding</h4><p>在使用<code>__block</code>修饰符的时候会发现一个问题， <code>__Block_byref_a_0</code> 结构体内第二个参数 <code>__forwarding</code> 指向的就是自身，而且在修改或使用的时候都会通过 <code>__forwarding</code> 去间接调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a.__forwarding-&gt;a) = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d \n"</span>, (a-&gt;__forwarding-&gt;a));</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？</p>
<p>我们已经知道了block会存在全局区、栈区和堆区。</p>
<ul>
<li><p>当block在栈上时候，forwarding指针就指向了自身。</p>
</li>
<li><p>当block被拷贝到堆上的时候，访问栈上的block，forwarding指针这时候指向了堆上的block结构体，访问堆上的block，forwarding指针指向了自身，也就是堆上的block</p>
</li>
</ul>
<p>这样通过forwarding中转调用，无论栈或者堆每次都能访问到正确的<code>__block</code>变量</p>
<h3 id="Block-Copy-Release"><a href="#Block-Copy-Release" class="headerlink" title="Block Copy/Release"></a>Block Copy/Release</h3><p>当block从栈上拷贝到堆上时，会调用<code>_Block_copy</code> 函数拷贝block，同时也会block内部所有引用的对象和 使用<code>__block</code>修饰的变量 调用<code>_Block_object_assign</code>进行拷贝</p>
<h4 id="Block-copy"><a href="#Block-copy" class="headerlink" title="_Block_copy"></a>_Block_copy</h4><p>在源码中<code>runtime.cpp</code> 中可以找到此函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy, or bump refcount, of a block.  If really copying, call the copy helper if present.</span></span><br><span class="line"><span class="keyword">void</span> *_Block_copy(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!arg) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The following would be better done as a switch statement</span></span><br><span class="line">    aBlock = (struct Block_layout *)arg;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="comment">// latches on high</span></span><br><span class="line">        latching_incr_int(&amp;aBlock-&gt;flags);</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> aBlock;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Its a stack block.  Make a copy.</span></span><br><span class="line">        struct Block_layout *result =</span><br><span class="line">            (struct Block_layout *)<span class="built_in">malloc</span>(aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">if</span> (!result) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        memmove(result, aBlock, aBlock-&gt;descriptor-&gt;<span class="built_in">size</span>); <span class="comment">// bitcopy first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(ptrauth_calls)</span></span><br><span class="line">        <span class="comment">// Resign the invoke pointer as it uses address authentication.</span></span><br><span class="line">        result-&gt;invoke = aBlock-&gt;invoke;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br><span class="line">        _Block_call_copy_helper(result, aBlock);</span><br><span class="line">        <span class="comment">// Set isa last so memory analysis tools see a fully-initialized object.</span></span><br><span class="line">        result-&gt;isa = _NSConcreteMallocBlock;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先将传进来的block转换为一个aBlock，然后根据block的flags做相应的处理</p>
</li>
<li><p>第二步，如果flags包含 <code>BLOCK_NEEDS_FREE</code>，free代表是在堆上，只用对应的增加引用计数即可。</p>
<p>此处调用了<code>latching_incr_int</code> 函数，内部对原始flags做了一个加2的操作</p>
</li>
<li><p>第三步，判断如果flags包含BLOCK_IS_GLOBAL，则证明block为全局block，全局block一直存在内存中，不需要做对应内存管理，所以此步骤直接返回该block</p>
</li>
<li><p>第四步，else 则说明此block是存在于栈上的，需要进行拷贝，下面分析拷贝的步骤：</p>
<ol>
<li><p>首先在堆上malloc分配一段空间，大小是<code>aBlock-&gt;descriptor-&gt;size</code> ，对应原有block的大小</p>
</li>
<li><p>然后<code>memmove</code>复制原有block到堆上，复制大小为原有block大小，完全复制</p>
</li>
<li><p>根据 <code>__has_feature(ptrauth_calls)</code> 编译器特性，执行了一句代码 <code>result-&gt;invoke = aBlock-&gt;invoke;</code>，此处的猜想是如果使用了地址空间随机化，则重新指定invoke指针的地址</p>
</li>
<li><p>接下来有两句设置flags的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset refcount</span></span><br><span class="line">        result-&gt;flags &amp;= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    <span class="comment">// XXX not needed</span></span><br><span class="line">        result-&gt;flags |= BLOCK_NEEDS_FREE | <span class="number">2</span>;  <span class="comment">// logical refcount 1</span></span><br></pre></td></tr></table></figure>

<p>第一句右边的代码<code>BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING</code> 结果为0xFFFF，<code>~(0xFFFF)</code>结果为<code>0x0000</code>，一个数<code>&amp;=0x0000</code>，则会清空低16位的数据，也就是此处注释上所说的重置引用计数，因为引用计数就存在于低16上（低1位代表<code>BLOCK_DEALLOCATING</code>）</p>
<p>在清空之后，第二句代码则重新按位或上了<code>BLOCK_NEEDS_FREE | 2</code>，设置引用计数。 free代表是在堆上，<code>| 2</code> 增加引用计数，每次增加引用计数都是递增2 。</p>
</li>
<li><p>接下来 <code>_Block_call_copy_helper</code> 会根据原block中是否有需要内存管理的对象，来进行对应拷贝到堆上</p>
</li>
<li><p>最后一步设置isa为<code>_NSConcreteMallocBlock</code> 标明block的类型</p>
</li>
</ol>
</li>
</ol>
<h4 id="Block-release"><a href="#Block-release" class="headerlink" title="_Block_release"></a>_Block_release</h4><p>有copy就会对应有release，接下来就来分析一下release的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// API entry point to release a copied Block</span></span><br><span class="line"><span class="keyword">void</span> _Block_release(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_layout</span> *<span class="title">aBlock</span> = (<span class="title">struct</span> <span class="title">Block_layout</span> *)<span class="title">arg</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!aBlock) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (aBlock-&gt;flags &amp; BLOCK_IS_GLOBAL) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (! (aBlock-&gt;flags &amp; BLOCK_NEEDS_FREE)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (latching_decr_int_should_deallocate(&amp;aBlock-&gt;flags)) &#123;</span><br><span class="line">        _Block_call_dispose_helper(aBlock);</span><br><span class="line">        _Block_destructInstance(aBlock);</span><br><span class="line">        <span class="built_in">free</span>(aBlock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>第一步是先转换block，判空处理</p>
</li>
<li><p>接下来看是否是<code>BLOCK_IS_GLOBAL</code> 全局区，是的话返回不做处理</p>
</li>
<li><p>第三步看<code>BLOCK_NEEDS_FREE</code> 状态，此状态标明是在堆区，如果不是此状态，也直接返回</p>
</li>
<li><p>处理完一些其他情况之后，就该正式做release操作了，首先调用<code>latching_decr_int_should_deallocate</code> 判断是否需要dealloc</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return should_deallocate?</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">latching_decr_int_should_deallocate</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> old_value = *where;</span><br><span class="line">        <span class="keyword">if</span> ((old_value &amp; BLOCK_REFCOUNT_MASK) == BLOCK_REFCOUNT_MASK) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// latched high</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((old_value &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">// underflow, latch low</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int32_t</span> new_value = old_value - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((old_value &amp; (BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING)) == <span class="number">2</span>) &#123;</span><br><span class="line">            new_value = old_value - <span class="number">1</span>;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (OSAtomicCompareAndSwapInt(old_value, new_value, where)) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先会判断边界情况，最大<code>BLOCK_REFCOUNT_MASK</code> 或者等于0，都返回false，不处理</p>
</li>
<li><p>接着往下看，我们在copy函数增加引用计数的时候会对flags+2，所以在这里首先会对flags做-2的操作</p>
</li>
<li><p>然后如果此时old_value正好等于2 ，说明只有一个引用计数，需要释放了。直接对old_value-1，减1之后flags就变成了<code>BLOCK_DEALLOCATING</code> ，这个值表示block需要释放</p>
</li>
<li><p>最后交换flags的值，返回result，告诉外界是否需要释放</p>
</li>
<li><p>总结就是如果有多个引用计数，则减一个，如果只有一个，则释放</p>
</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>由于上一步判断需要释放的时候已经对flags进行了减引用计数的操作，如果不需要释放，则此时release函数已经执行完毕了。 </p>
</li>
<li><p>如果需要释放，调用<code>_Block_call_dispose_helper</code> 函数对block内部对象进行相应内存管理释放。接着调用<code>_Block_destructInstance</code> 函数，此函数没有找到对应的源码，故根据字面意思猜测是对block实例对象进行释放。最后free释放空间</p>
</li>
</ol>
<h4 id="Block-object-assign"><a href="#Block-object-assign" class="headerlink" title="_Block_object_assign"></a>_Block_object_assign</h4><p>当block拷贝到堆上时，可以引用四种不同的类型</p>
<ol>
<li>基于c++的堆栈对象</li>
<li>引用Objective-C对象</li>
<li>其他的block</li>
<li><code>__block</code> 修改的变量类型</li>
</ol>
<p>在Block_copy和Block_release调用情况下，编译器会合成 copy 和 dispose 助手函数。</p>
<p>在第一种基于c++堆栈对象的情况下，copy助手函数会调用其构造函数，dispose助手函数会调用析构函数</p>
<p>其余三种情况下，copy助手函数会调用 <code>_Block_object_assign</code>， dispose助手函数会调用 <code>_Block_object_dispose</code> 去做相应的处理</p>
<p><code>__Block_object_assign</code> 和 <code>__Block_object_dispose</code> 的 flags参数类型如下：</p>
<ul>
<li><p><code>BLOCK_FIELD_IS_OBJECT (3)</code>, Objective-C对象</p>
</li>
<li><p><code>BLOCK_FIELD_IS_BLOCK (7)</code> ，其他的block对象</p>
</li>
<li><p><code>BLOCK_FIELD_IS_BYREF (8)</code>， <code>__block</code> 修饰的变量</p>
<p>如果<code>__block</code>修饰的变量设置为<code>__weak</code>，则flags也是 <code>BLOCK_FIELD_IS_WEAK (16)</code></p>
</li>
</ul>
<p>所以，Block copy/dispose 应该只生成 3、7、8、24 这四种flags</p>
<p>当<code>__block</code>修饰符修饰了一个c++对象或者OC对象或者其他的block对象时，编译器也会生成 copy/dispose 助手函数，也会做相应的内存管理操作。</p>
<p>在为oc对象或者其他block调用相同的助手函数时，同时会在flags中提供额外的位信息标识，<code>BLOCK_BYREF_CALLER (128)</code></p>
<p>所以 <code>__block</code> copy/dispose 助手将在为 对象 或 其他block 生成3、7的同时，会根据不同的情况增加16或者128。下面是可能出现的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__block id                   128+3       (0x83)</span><br><span class="line">__block (^Block)             128+7       (0x87)</span><br><span class="line">__weak __block id            128+3+16    (0x93)</span><br><span class="line">__weak __block (^Block)      128+7+16    (0x97)</span><br></pre></td></tr></table></figure>

<p>如果是修饰的对象或者block，则对应增加128，如果同时修饰了weak属性，则再对应增加16</p>
<p>当Blocks或者Block_byrefs包含了对象时，copy方法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Block_object_assign(<span class="keyword">void</span> *destArg, <span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **dest = (<span class="keyword">const</span> <span class="keyword">void</span> **)destArg;</span><br><span class="line">    <span class="keyword">switch</span> (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        id object = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        _Block_retain_object(object);</span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">        void (^object)(void) = ...;</span></span><br><span class="line"><span class="comment">        [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">        ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the onstack __block container to the heap</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block ... x;</span></span><br><span class="line"><span class="comment">         __weak __block ... x;</span></span><br><span class="line"><span class="comment">         [^&#123; x; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = _Block_byref_copy(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this is MRC unretained __block only. </span></span><br><span class="line"><span class="comment">         // ARC retained __block is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __block id object;</span></span><br><span class="line"><span class="comment">         __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        <span class="comment">/*******</span></span><br><span class="line"><span class="comment">         // copy the actual field held in the __block container</span></span><br><span class="line"><span class="comment">         // Note this __weak is old GC-weak/MRC-unretained.</span></span><br><span class="line"><span class="comment">         // ARC-style __weak is handled by the copy helper directly.</span></span><br><span class="line"><span class="comment">         __weak __block id object;</span></span><br><span class="line"><span class="comment">         __weak __block void (^object)(void);</span></span><br><span class="line"><span class="comment">         [^&#123; object; &#125; copy];</span></span><br><span class="line"><span class="comment">         ********/</span></span><br><span class="line"></span><br><span class="line">        *dest = object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来分析接收的三个参数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _Block_call_copy_helper(<span class="keyword">void</span> *result, struct Block_layout *aBlock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_2</span> *<span class="title">desc</span> = _<span class="title">Block_descriptor_2</span>(<span class="title">aBlock</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (!desc) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    (*desc-&gt;copy)(result, aBlock); <span class="comment">// do fixup</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Block_copy中找到上面的函数，从此函数可以看出copy助手函数传入的两个函数一个为拷贝之后堆上的block，一个为原始的block</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;a, (<span class="keyword">void</span>*)src-&gt;a, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;weakPerson, (<span class="keyword">void</span>*)src-&gt;weakPerson, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;s, (<span class="keyword">void</span>*)src-&gt;s, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;s1, (<span class="keyword">void</span>*)src-&gt;s1, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>从编译后的cpp中可以找到<code>void (*copy)(x, x)</code>实际调用的是<code>__main_block_copy_0</code>，  在这里面看到了 <code>_Block_object_assign</code></p>
<p>这样综合分析之后就可以明白三个参数传递的都是什么</p>
<ol>
<li><p>destArg为copy之后在堆上的block对象</p>
</li>
<li><p>object指向copy之前的block对象</p>
</li>
<li><p>flags对应如下，区分引用的对象类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for _Block_object_assign() and _Block_object_dispose() parameters</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// see function implementation for a more complete description of these fields and combinations</span></span><br><span class="line">    BLOCK_FIELD_IS_OBJECT   =  <span class="number">3</span>,  <span class="comment">// id, NSObject, __attribute__((NSObject)), block, ...</span></span><br><span class="line">    BLOCK_FIELD_IS_BLOCK    =  <span class="number">7</span>,  <span class="comment">// a block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_BYREF    =  <span class="number">8</span>,  <span class="comment">// the on stack structure holding the __block variable</span></span><br><span class="line">    BLOCK_FIELD_IS_WEAK     = <span class="number">16</span>,  <span class="comment">// declared __weak, only used in byref copy helpers</span></span><br><span class="line">    BLOCK_BYREF_CALLER      = <span class="number">128</span>, <span class="comment">// called from __block (byref) copy/dispose support routines.</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_ALL_COPY_DISPOSE_FLAGS = </span><br><span class="line">        BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_BYREF |</span><br><span class="line">        BLOCK_FIELD_IS_WEAK | BLOCK_BYREF_CALLER</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>接着正式来看到底做了什么</p>
<ol>
<li>如果是<code>BLOCK_FIELD_IS_OBJECT</code>，即OC对象。对object执行retain操作，赋值为destArg</li>
<li>如果是<code>BLOCK_FIELD_IS_BLOCK</code>，即block对象。则执行Block_copy，进行对应的拷贝操作，赋值给destArg</li>
<li>如果是<code>BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK</code> 或者 <code>BLOCK_FIELD_IS_BYREF</code>，代表<code>__block</code> 或者<code>__block __weak</code> 修饰的变量。则执行<code>_Block_byref_copy</code> 函数，此函数在后面分析</li>
<li>如果是<code>BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT</code> 或者 <code>BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK</code>，代表的是<code>__block</code>修饰的oc对象或者block，直接赋值给destArg</li>
<li>如果是<code>BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK</code> 或者 <code>BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK | BLOCK_FIELD_IS_WEAK</code>，代表的是 <code>__block __weak</code> 修饰的oc对象或者block，也是直接赋值</li>
</ol>
<h4 id="Block-object-dispose"><a href="#Block-object-dispose" class="headerlink" title="_Block_object_dispose"></a>_Block_object_dispose</h4><p>dispose对应的是assign，当block销毁时，同时dispose block内部引用的对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When Blocks or Block_byrefs hold objects their destroy helper routines call this entry point</span></span><br><span class="line"><span class="comment">// to help dispose of the contents</span></span><br><span class="line"><span class="keyword">void</span> _Block_object_dispose(<span class="keyword">const</span> <span class="keyword">void</span> *object, <span class="keyword">const</span> <span class="keyword">int</span> flags) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (os_assumes(flags &amp; BLOCK_ALL_COPY_DISPOSE_FLAGS)) &#123;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BYREF:</span><br><span class="line">        <span class="comment">// get rid of the __block data structure held in a Block</span></span><br><span class="line">        _Block_byref_release(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">        _Block_release(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">        _Block_release_object(object);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">      <span class="keyword">case</span> BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数和assign操作是一一对应的，接下来具体步骤分析</p>
<ol>
<li>如果是<code>BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK</code> 或者 <code>BLOCK_FIELD_IS_BYREF</code>，代表<code>__block</code> 或者 <code>__block __weak</code> 修饰的变量，则执行<code>_Block_byref_release</code> 函数，此函数也会在后面分析，此处跳过</li>
<li>如果是<code>BLOCK_FIELD_IS_BLOCK</code> ，代表引用的block对象，执行Block_release函数进行释放</li>
<li>如果是<code>BLOCK_FIELD_IS_OBJECT</code>，执行relase对象的操作，和assign中retain是对应关系</li>
<li>最后如果是<code>__block</code> 或者 <code>__block __weak</code> 修饰的oc对象或者block对象，则什么也不做，因为在assign中对应的情况也没有做任何处理</li>
</ol>
<h4 id="Block-byref-copy"><a href="#Block-byref-copy" class="headerlink" title="_Block_byref_copy"></a>_Block_byref_copy</h4><p>之前有介绍过byref对象，知道是<code>__block</code> 修饰的变量或者对象等就会生成一个byref对象。现在再来认识一下byref对象的布局</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Values for Block_byref-&gt;flags to describe __block variables</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// Byref refcount must use the same bits as Block_layout's refcount.</span></span><br><span class="line">    <span class="comment">// BLOCK_DEALLOCATING =      (0x0001),  // runtime</span></span><br><span class="line">    <span class="comment">// BLOCK_REFCOUNT_MASK =     (0xfffe),  // runtime</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_LAYOUT_MASK =       (<span class="number">0xf</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_EXTENDED =   (  <span class="number">1</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_NON_OBJECT = (  <span class="number">2</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_STRONG =     (  <span class="number">3</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_WEAK =       (  <span class="number">4</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_LAYOUT_UNRETAINED = (  <span class="number">5</span> &lt;&lt; <span class="number">28</span>), <span class="comment">// compiler</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_IS_GC =             (  <span class="number">1</span> &lt;&lt; <span class="number">27</span>), <span class="comment">// runtime</span></span><br><span class="line"></span><br><span class="line">    BLOCK_BYREF_HAS_COPY_DISPOSE =  (  <span class="number">1</span> &lt;&lt; <span class="number">25</span>), <span class="comment">// compiler</span></span><br><span class="line">    BLOCK_BYREF_NEEDS_FREE =        (  <span class="number">1</span> &lt;&lt; <span class="number">24</span>), <span class="comment">// runtime</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">forwarding</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_HAS_COPY_DISPOSE</span></span><br><span class="line">    BlockByrefKeepFunction byref_keep;</span><br><span class="line">    BlockByrefDestroyFunction byref_destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_LAYOUT_EXTENDED</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>分为了三部分组成</p>
<p><strong>Block_byref</strong> </p>
<ul>
<li>isa，默认为NULL</li>
<li>forwarding 栈上的指向堆上的对象，堆上的指向自身</li>
<li>flags 包含一些状态，例如引用计数，堆栈信息等</li>
<li>size 整个byref大小 包含了下面两部分</li>
</ul>
<p><strong>Block_byref_2</strong></p>
<ul>
<li>如果<code>__block</code> 修饰的是对象类型，则此部分就会存在，用于内存管理。实际调用的<code>_Block_object_assign</code> 和 <code>_Block_object_dispose</code> </li>
</ul>
<p><strong>Block_byref_3</strong></p>
<ul>
<li>layout描述了引用的外部对象布局信息，官方注释上说layout和block的layout一样采用了一种压缩布局方式，但是经测试发现，在byref对象内部的layout存储的就是外部对象的地址值，这里有待深究？</li>
</ul>
<p>了解byref的布局方式之后，接下来看copy函数更有利于理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *_<span class="title">Block_byref_copy</span>(<span class="title">const</span> <span class="title">void</span> *<span class="title">arg</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">src</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// src points to stack</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">copy</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">malloc</span>(<span class="title">src</span>-&gt;<span class="title">size</span>);</span></span><br><span class="line">        copy-&gt;isa = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// byref value 4 is logical refcount of 2: one for caller, one for stack</span></span><br><span class="line">        copy-&gt;flags = src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | <span class="number">4</span>;</span><br><span class="line">        copy-&gt;forwarding = copy; <span class="comment">// patch heap copy to point to itself</span></span><br><span class="line">        src-&gt;forwarding = copy;  <span class="comment">// patch stack to point to heap copy</span></span><br><span class="line">        copy-&gt;<span class="built_in">size</span> = src-&gt;<span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">            <span class="comment">// Trust copy helper to copy everything of interest</span></span><br><span class="line">            <span class="comment">// If more than one field shows up in a byref block this is wrong XXX</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">src2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">src</span>+1);</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">copy2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">copy</span>+1);</span></span><br><span class="line">            copy2-&gt;byref_keep = src2-&gt;byref_keep;</span><br><span class="line">            copy2-&gt;byref_destroy = src2-&gt;byref_destroy;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src-&gt;flags &amp; BLOCK_BYREF_LAYOUT_EXTENDED) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">src3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span> *)(<span class="title">src2</span>+1);</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_3</span> *<span class="title">copy3</span> = (<span class="title">struct</span> <span class="title">Block_byref_3</span>*)(<span class="title">copy2</span>+1);</span></span><br><span class="line">                copy3-&gt;layout = src3-&gt;layout;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            (*src2-&gt;byref_keep)(copy, src);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Bitwise copy.</span></span><br><span class="line">            <span class="comment">// This copy includes Block_byref_3, if any.</span></span><br><span class="line">            memmove(copy+<span class="number">1</span>, src+<span class="number">1</span>, src-&gt;<span class="built_in">size</span> - <span class="keyword">sizeof</span>(*src));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// already copied to heap</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        latching_incr_int(&amp;src-&gt;forwarding-&gt;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> src-&gt;forwarding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此段代码执行了两个条件判断</p>
<ul>
<li><p>首先判断<code>(src-&gt;forwarding-&gt;flags &amp; BLOCK_REFCOUNT_MASK) == 0</code> ，等于0代表没有引用计数，也说明了不在堆上，所以需要执行拷贝操作</p>
<ol>
<li><p>malloc分配空间，size为栈上byref的大小</p>
</li>
<li><p>设置isa等于NULL</p>
</li>
<li><p>设置flags <code>src-&gt;flags | BLOCK_BYREF_NEEDS_FREE | 4</code>，<code>BLOCK_BYREF_NEEDS_FREE</code> 代表位于堆上，<code>| 4</code> 代表引用计数为2，一份是堆上持有，一份是栈上持有。（之前我们之前讨论过，引用计数递增flags每次都会增加2，所以这里两份持有，就按位或4 <code>| 4</code> ）</p>
</li>
<li><p>设置堆上的forwarding指向堆上的byref对象（之前也讨论过在堆上时forwarding指针指向自身，在栈上时forwarding指向堆上，所以这里也没有疑问）</p>
</li>
<li><p>设置原来栈上的forwarding指针指向堆上</p>
</li>
<li><p>设置size为原有栈上的size</p>
</li>
<li><p>接下来就是设置内存管理和引用对象了。 如果需要内存管理</p>
<ol>
<li>根据src+1取出<code>Block_byref_2</code> ，设置堆上的byref_keep和byref_destroy指向栈上对应的函数</li>
<li>如果有extended，则根据src2+1取出<code>Block_byref_3</code>，赋值layout</li>
<li>接下来 <code>(*src2-&gt;byref_keep)(copy, src);</code> 调用byref_keep函数进行拷贝</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</span><br><span class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据clang编译出来的cpp文件，可以推测出实际调用的就是<code>_Block_object_assign</code> 函数，传入+40的目的是直接找到layout对象，也就是需要拷贝的对象。 （layout前面有<code>*isa</code>、<code>*forwarding</code>、<code>int flags</code>、<code>int size</code>、<code>*byref_keep</code>、<code>*byfre_destroy</code>，总共就是40字节）</p>
</li>
<li><p>如果不需要内存管理，说明捕获的是一个变量，没有<code>Block_byref_2</code>，<code>Block_byref</code> 中size之后就直接是layout了，所以src+1取出的就是layout。直接进行字节拷贝，大小是 <code>src-&gt;size - sizeof(*src)</code> 总大小减<code>Block_byref</code> 的大小，就是layout的大小</p>
</li>
</ol>
</li>
<li><p>接着回到最外层，另外一条判断语句。<code>(src-&gt;forwarding-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) == BLOCK_BYREF_NEEDS_FREE</code> 表示byref对象已经在堆上了，只需要调用<code>latching_incr_int</code> 增加引用计数即可</p>
</li>
<li><p>最后返回 <code>src-&gt;forwarding</code> ，也就是堆上的byref对象</p>
</li>
</ul>
<h4 id="Block-byref-release"><a href="#Block-byref-release" class="headerlink" title="_Block_byref_release"></a>_Block_byref_release</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _Block_byref_release(<span class="keyword">const</span> <span class="keyword">void</span> *arg) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref</span> *<span class="title">byref</span> = (<span class="title">struct</span> <span class="title">Block_byref</span> *)<span class="title">arg</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dereference the forwarding pointer since the compiler isn't doing this anymore (ever?)</span></span><br><span class="line">    byref = byref-&gt;forwarding;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (byref-&gt;flags &amp; BLOCK_BYREF_NEEDS_FREE) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> refcount = byref-&gt;flags &amp; BLOCK_REFCOUNT_MASK;</span><br><span class="line">        os_assert(refcount);</span><br><span class="line">        <span class="keyword">if</span> (latching_decr_int_should_deallocate(&amp;byref-&gt;flags)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (byref-&gt;flags &amp; BLOCK_BYREF_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Block_byref_2</span> *<span class="title">byref2</span> = (<span class="title">struct</span> <span class="title">Block_byref_2</span> *)(<span class="title">byref</span>+1);</span></span><br><span class="line">                (*byref2-&gt;byref_destroy)(byref);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(byref);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先通过forwarding取出真正的byref对象</li>
<li>根据flags判断是否在堆上</li>
<li>取出refcount，引用计数</li>
<li>然后调用<code>latching_decr_int_should_deallocate</code> 判断此byref对象是否需要释放</li>
<li>如果需要释放，再根据是否有copy、dispose，调用<code>byref_destroy</code> 释放byref对象内部的引用对象</li>
</ol>
<h3 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h3><p>block循环引用问题是开发中最常见的问题，也是最熟悉的。 </p>
<p>对象持有block，block又强引用了对象，这样就造成了循环引用。我们要做的就是把其中一条强引用关系给解除，就可以避免循环引用问题</p>
<ul>
<li><p>使用 <code>__weak</code>  修饰符。</p>
<p><code>__weak</code> 不会产生强引用，指向的对象销毁时，会自动让指针置为nil。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__weak <span class="title">typeof</span><span class="params">(p)</span> weakPerson </span>= p;</span><br><span class="line">__weak Person *weakPerson = p;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__unsafe_retained</code> 修饰符</p>
<p><code>__unsafe_retained</code> 不会产生强引用，不安全，指向的对象销毁时，指针存储的地址值不变</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__unsafe_retained Person *weakPerson = p;</span><br><span class="line"><span class="function">__unsafe_unretained <span class="title">typeof</span><span class="params">(p)</span> weakpp </span>= p;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>__block</code> ，但是block实现之后必须要把引用对象置为nil，而且block必须要被调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block id weakSelf - self;</span><br><span class="line">self.block = ^&#123;</span><br><span class="line"> 	<span class="built_in">printf</span>(<span class="string">"%p"</span>, weakSelf);</span><br><span class="line">  weakSelf = nil;</span><br><span class="line">&#125;;</span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>arc下建议使用 <code>__weak</code> 解决方案</p>
<p>ps: cell的隐性循环引用</p>
<p>分析其原因在于cell实际是tableView的子视图,每个子视图都是会被其父视图的subviews(NSArray *)属性所强引用,即tableView ~&gt; subviews ~&gt; cell,而cell因为使用block作为回调强引用了block内部的对象,形成了这样的循环引用链条,即 controller ~&gt; tableView ~&gt; cell ~&gt; block -&gt; controller。所以构成了循环引用，解决的方法同样是block弱引用controller，就打破了闭环</p>
<h2 id="block内部引用对象"><a href="#block内部引用对象" class="headerlink" title="block内部引用对象"></a>block内部引用对象</h2><p>这一部分主要的目的是打印出block内部引用的所有外部对象，在平时开发中如果有难以排查的循环引用问题，可以帮助我们快速查找问题。一个实用的小工具。参考文章<a href="https://juejin.im/post/5d7e3b8de51d4561ac7bcd5f" target="_blank" rel="noopener">一种查看Block中引用的所有外部对象的实现方法</a> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.name = @<span class="string">"哈哈"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__weak <span class="title">typeof</span><span class="params">(self)</span> weakSelf </span>= self;</span><br><span class="line"></span><br><span class="line">Person *p = [[Person alloc] init];</span><br><span class="line">p.age = <span class="number">88</span>;</span><br><span class="line"></span><br><span class="line">__block Student *s = [[Student alloc] init];</span><br><span class="line">s.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">self.block = ^&#123;</span><br><span class="line">  NSLog(@<span class="string">"%@"</span>, weakSelf.name);</span><br><span class="line">  NSLog(@<span class="string">"%d"</span>, p.age);</span><br><span class="line">  NSLog(@<span class="string">"%@"</span>, self.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">self.block();</span><br></pre></td></tr></table></figure>

<p><code>self.block</code> 内部引用了三个对象，弱引用了self，强引用person对象，强引用了self对象。然后我们使用lldb调用工具类打印一下结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="function">po <span class="title">showBlockExtendedLayout</span><span class="params">(self.block)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line">2020-05-10 14:23:05.753129+0800 BlockExtends[21198:1007232] the refObj is:&lt;Person: 0x6000025edc60&gt;  type is:KB_BLOCK_LAYOUT_STRONG</span><br><span class="line">  </span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-10</span> <span class="number">14</span>:<span class="number">23</span>:<span class="number">05.753389</span>+<span class="number">0800</span> BlockExtends[<span class="number">21198</span>:<span class="number">1007232</span>] the refObj is:&lt;ViewController: <span class="number">0x7fcc807031f0</span>&gt;  type is:KB_BLOCK_LAYOUT_STRONG</span><br><span class="line"> </span><br><span class="line"><span class="number">2020</span><span class="number">-05</span><span class="number">-10</span> <span class="number">21</span>:<span class="number">17</span>:<span class="number">29.770055</span>+<span class="number">0800</span> BlockExtends[<span class="number">2322</span>:<span class="number">1354898</span>] the refObj is:&lt;Student: <span class="number">0x600002ad0750</span>&gt;  type is KB_BLOCK_LAYOUT_BYREF</span><br></pre></td></tr></table></figure>

<p>由于工具内部只打印强引用的对象，所以可以看到这里打印出了person对象和强引用的self对象，type is ： 3 代表强引用类型。这只是简单的示范，实际项目中使用可以通过不同情况自己封装。 </p>
<p>代码并不复杂，主要是实现的思路。如果flags包含了<code>BLOCK_HAS_EXTENDED_LAYOUT</code> ，说明引用了外部的对象，位置是在结构体的最下面部分。我们只需要找到这一部分就可以找到引用的对象。但是由于苹果对layout数据进行了编码，所以我们需要知道编码规则，才可以对应的解出来数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extended layout encoding.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Values for Block_descriptor_3-&gt;layout with BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line"><span class="comment">// and for Block_byref_3-&gt;layout with BLOCK_BYREF_LAYOUT_EXTENDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layout field is less than 0x1000, then it is a compact encoding </span></span><br><span class="line"><span class="comment">// of the form 0xXYZ: X strong pointers, then Y byref pointers, </span></span><br><span class="line"><span class="comment">// then Z weak pointers.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layout field is 0x1000 or greater, it points to a </span></span><br><span class="line"><span class="comment">// string of layout bytes. Each byte is of the form 0xPN.</span></span><br><span class="line"><span class="comment">// Operator P is from the list below. Value N is a parameter for the operator.</span></span><br><span class="line"><span class="comment">// Byte 0x00 terminates the layout; remaining block data is non-pointer bytes.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BLOCK_LAYOUT_ESCAPE = <span class="number">0</span>, <span class="comment">// N=0 halt, rest is non-pointer. N!=0 reserved.</span></span><br><span class="line">    BLOCK_LAYOUT_NON_OBJECT_BYTES = <span class="number">1</span>,    <span class="comment">// N bytes non-objects</span></span><br><span class="line">    BLOCK_LAYOUT_NON_OBJECT_WORDS = <span class="number">2</span>,    <span class="comment">// N words non-objects</span></span><br><span class="line">    BLOCK_LAYOUT_STRONG           = <span class="number">3</span>,    <span class="comment">// N words strong pointers</span></span><br><span class="line">    BLOCK_LAYOUT_BYREF            = <span class="number">4</span>,    <span class="comment">// N words byref pointers</span></span><br><span class="line">    BLOCK_LAYOUT_WEAK             = <span class="number">5</span>,    <span class="comment">// N words weak pointers</span></span><br><span class="line">    BLOCK_LAYOUT_UNRETAINED       = <span class="number">6</span>,    <span class="comment">// N words unretained pointers</span></span><br><span class="line">    BLOCK_LAYOUT_UNKNOWN_WORDS_7  = <span class="number">7</span>,    <span class="comment">// N words, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNKNOWN_WORDS_8  = <span class="number">8</span>,    <span class="comment">// N words, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNKNOWN_WORDS_9  = <span class="number">9</span>,    <span class="comment">// N words, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNKNOWN_WORDS_A  = <span class="number">0xA</span>,  <span class="comment">// N words, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNUSED_B         = <span class="number">0xB</span>,  <span class="comment">// unspecified, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNUSED_C         = <span class="number">0xC</span>,  <span class="comment">// unspecified, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNUSED_D         = <span class="number">0xD</span>,  <span class="comment">// unspecified, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNUSED_E         = <span class="number">0xE</span>,  <span class="comment">// unspecified, reserved</span></span><br><span class="line">    BLOCK_LAYOUT_UNUSED_F         = <span class="number">0xF</span>,  <span class="comment">// unspecified, reserved</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以在源码中找到layout的描述，在上面讲byref对象的时候也有一个扩展layout。这两个的存储实现方式是一致的。</p>
<p>layout采用了一种自己独特的编码形式</p>
<ul>
<li>当layout字段小于<code>0x1000</code>，则是一个压缩的扩展布局描述，格式为<code>0xXYZ</code>，x代表强引用的对象指针，y代表byref对象的指针，z代表的是weak弱引用指针。也就是用12位存储数据 <code>0000 0000 0000</code> ，低4位代表weak弱引用(z)，中间4位代表byref对象的指针(y)，高4位代表强引用的对象(x)</li>
<li>如果layout字段大于等于<code>0x1000</code>，它指向一个以<code>0x00</code> 结尾的字符串指针，每个字节的格式为 <code>0xPN</code>，P就是枚举中描述的类型，N代表每种类型的数量。也就是8位 <code>0000 0000</code> ，低4位表示数量N，高4位表示类型P</li>
</ul>
<p>我们在之前小节中已经了解了block的布局，刚刚也知道了layout的编码规则。相信再看代码的话已经很轻松了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// kb_Block_layout Extended layout encoding.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    KB_BLOCK_LAYOUT_STRONG = <span class="number">3</span>,</span><br><span class="line">    KB_BLOCK_LAYOUT_BYREF = <span class="number">4</span>,</span><br><span class="line">    KB_BLOCK_LAYOUT_WEAK = <span class="number">5</span>,</span><br><span class="line">    KB_BLOCK_LAYOUT_UNRETAINED = <span class="number">6</span></span><br><span class="line">&#125; KBBlockExtendFlags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// kb_Block_layout -&gt; flags</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    KB_BLOCK_HAS_COPY_DISPOSE = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">    KB_BLOCK_HAS_EXTENDED_LAYOUT = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)</span><br><span class="line">&#125; KBBlockLayoutFlags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// kb_Block_byref -&gt; flags</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    KB_BLOCK_BYREF_LAYOUT_EXTENDED =   (  <span class="number">1</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    KB_BLOCK_BYREF_LAYOUT_NON_OBJECT = (  <span class="number">2</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    KB_BLOCK_BYREF_LAYOUT_STRONG =     (  <span class="number">3</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    KB_BLOCK_BYREF_LAYOUT_WEAK =       (  <span class="number">4</span> &lt;&lt; <span class="number">28</span>),</span><br><span class="line">    KB_BLOCK_BYREF_LAYOUT_HAS_COPY_DISPOSE = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">&#125; KBBlockByrefFlags;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_descriptor_1</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> reserved;</span><br><span class="line">    <span class="keyword">uintptr_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_descriptor_2</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_COPY_DISPOSE</span></span><br><span class="line">    <span class="keyword">void</span> *copy;</span><br><span class="line">    <span class="keyword">void</span> *dispose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_descriptor_3</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_HAS_SIGNATURE</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;     <span class="comment">// contents depend on BLOCK_HAS_EXTENDED_LAYOUT</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_layout</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count</span></span><br><span class="line">    <span class="keyword">int32_t</span> reserved;</span><br><span class="line">    <span class="keyword">void</span> *invoke;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Block_descriptor_1</span> *<span class="title">descriptor</span>;</span></span><br><span class="line">    <span class="comment">// imported variables</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_byref</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_byref</span> *<span class="title">forwarding</span>;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_byref_2</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_HAS_COPY_DISPOSE</span></span><br><span class="line">    <span class="keyword">void</span> *byref_keep;</span><br><span class="line">    <span class="keyword">void</span> *byref_destroy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_byref_3</span> &#123;</span></span><br><span class="line">    <span class="comment">// requires BLOCK_BYREF_LAYOUT_EXTENDED</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *layout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showBlockExtendedLayout</span><span class="params">(id block)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将block转化为自定义 kb_Block_layout 结构体指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_layout</span> *<span class="title">blockLayout</span> = (__<span class="title">bridge</span> <span class="title">struct</span> <span class="title">kb_Block_layout</span>*)(<span class="title">block</span>);</span></span><br><span class="line">    <span class="comment">// 如果没有引用外部对象也就是没有扩展布局标志的话则直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (! (blockLayout-&gt;flags &amp; KB_BLOCK_HAS_EXTENDED_LAYOUT)) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Block_descriptor_1都有，默认加上偏移</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *desc = (<span class="keyword">uint8_t</span> *)blockLayout-&gt;descriptor;</span><br><span class="line">    desc += <span class="keyword">sizeof</span>(struct kb_Block_descriptor_1);</span><br><span class="line">    <span class="comment">// 如果有BLOCK_HAS_COPY_DISPOSE，说明引用的有外部对象，需要内存管理，也要加上对应偏移</span></span><br><span class="line">    <span class="keyword">if</span> (blockLayout-&gt;flags &amp; KB_BLOCK_HAS_COPY_DISPOSE) &#123;</span><br><span class="line">        desc += <span class="keyword">sizeof</span>(struct kb_Block_descriptor_2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最终转化为Block_descriptor_3中的结构指针。并且当布局值为0时表明没有引用外部对象。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kb_Block_descriptor_3</span> *<span class="title">desc3</span> = (<span class="title">struct</span> <span class="title">kb_Block_descriptor_3</span> *)<span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (desc3-&gt;layout == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 经测试，如果一种类型的外部引用超过0xF，则layout字段就会大于0x1000，如果同种类型外部引用小于0xF，则layout字段就会小于0x1000,进行压缩处理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *extlayoutstr = desc3-&gt;layout;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理压缩布局描述的情况。最终也是包装成 0xPN</span></span><br><span class="line">    <span class="keyword">if</span> (extlayoutstr &lt; (<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="number">0x1000</span>) &#123;</span><br><span class="line">        <span class="comment">// 当扩展布局的值小于0x1000时则是压缩的布局描述，这里分别取出xyz部分的内容进行重新编码。 0xXYZ</span></span><br><span class="line">        <span class="comment">// 取出的xyz则代表每种类型的引用数量</span></span><br><span class="line">        <span class="keyword">char</span> compactEncoding[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">unsigned</span> short xyz = (<span class="keyword">unsigned</span> short)(extlayoutstr);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> x = (xyz &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取前四位 代表x</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> y = (xyz &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取中间四位 代表y</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> z = (xyz &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取末尾四位 代表z</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 0x30 | x</span></span><br><span class="line">            compactEncoding[idx++] = (KB_BLOCK_LAYOUT_STRONG&lt;&lt;<span class="number">4</span>) | x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 0x40 | y</span></span><br><span class="line">            compactEncoding[idx++] = (KB_BLOCK_LAYOUT_BYREF&lt;&lt;<span class="number">4</span>) | y;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (z != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 0x50 | z</span></span><br><span class="line">            compactEncoding[idx++] = (KB_BLOCK_LAYOUT_WEAK&lt;&lt;<span class="number">4</span>) | z;</span><br><span class="line">        &#125;</span><br><span class="line">        compactEncoding[idx++] = <span class="number">0</span>;</span><br><span class="line">        extlayoutstr = compactEncoding;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *blockmemoryAddr = (__bridge <span class="keyword">void</span>*)block;</span><br><span class="line">    <span class="comment">// 得到外部引用对象的开始偏移位置</span></span><br><span class="line">    <span class="keyword">int</span> refObjOffset = <span class="keyword">sizeof</span>(struct kb_Block_layout);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(extlayoutstr); i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取出字节中所表示的类型和数量。</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> PN = extlayoutstr[i];</span><br><span class="line">        <span class="comment">// P 取高4位 描述引用的类型。</span></span><br><span class="line">        <span class="keyword">int</span> P = (PN &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">        <span class="comment">// N 取低4位 代表数量</span></span><br><span class="line">        <span class="keyword">int</span> N = (PN &amp; <span class="number">0xF</span>);</span><br><span class="line">       </span><br><span class="line">				<span class="comment">// 这里只对类型为3，4，5，6四种类型进行处理。</span></span><br><span class="line">        <span class="keyword">if</span> (P &gt;= KB_BLOCK_LAYOUT_STRONG &amp;&amp; P &lt;= KB_BLOCK_LAYOUT_UNRETAINED) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                <span class="comment">// 强引用类型</span></span><br><span class="line">                <span class="keyword">if</span> (P == KB_BLOCK_LAYOUT_STRONG) &#123;</span><br><span class="line">                    <span class="comment">// 根据偏移得到引用外部对象的地址。并转化为OC对象。</span></span><br><span class="line">                    <span class="keyword">void</span> *refObjAddr = *(<span class="keyword">void</span>**)(blockmemoryAddr + refObjOffset);</span><br><span class="line">                    id refObj =  (__bridge id) refObjAddr;</span><br><span class="line">                    </span><br><span class="line">                    NSLog(@<span class="string">"the refObj is:%@  type is KB_BLOCK_LAYOUT_STRONG"</span>, refObj);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果使用__block修饰了oc对象或者block 没有加__weak，也会存在强引用的情况，首先要拿到byref对象，再去byref对象内部找到具体的对象</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (P == KB_BLOCK_LAYOUT_BYREF) &#123;</span><br><span class="line">                    struct kb_Block_byref *byrefObj = *(struct kb_Block_byref **)(blockmemoryAddr + refObjOffset);</span><br><span class="line">                    <span class="keyword">int32_t</span> flags = byrefObj-&gt;flags;</span><br><span class="line">                    <span class="keyword">if</span> ((flags &amp; KB_BLOCK_BYREF_LAYOUT_HAS_COPY_DISPOSE) &amp;&amp; (flags &amp; KB_BLOCK_BYREF_LAYOUT_EXTENDED)) &#123;</span><br><span class="line">                        <span class="keyword">unsigned</span> <span class="keyword">char</span> *byrefAddr = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)byrefObj;</span><br><span class="line">                        <span class="keyword">void</span> *desc = *(<span class="keyword">void</span> **)(byrefAddr + <span class="keyword">sizeof</span>(struct kb_Block_byref) + <span class="keyword">sizeof</span>(struct kb_Block_byref_2));</span><br><span class="line">                        id obj = (__bridge id)desc;</span><br><span class="line">                        </span><br><span class="line">                        NSLog(@<span class="string">"the refObj is:%@  type is KB_BLOCK_LAYOUT_BYREF"</span>, obj);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 因为布局中保存的是对象的指针，所以偏移要加上一个指针的大小继续获取下一个偏移。</span></span><br><span class="line">                refObjOffset += <span class="keyword">sizeof</span>(<span class="keyword">void</span>*);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先转换block，如果flags不包含 <code>BLOCK_HAS_EXTENDED_LAYOUT</code> ，则直接return，说明没有引用外部对象</p>
</li>
<li><p>接着找到descriptor的位置，首先加上 <code>Block_descriptor_1</code> 的大小，因为descriptor1里的reserved和size是一直存在的</p>
</li>
<li><p>接着根据 <code>BLOCK_HAS_COPY_DISPOSE</code> 来判断是否有<code>Block_descriptor_2</code>，这一部分是用于外部对象内存管理的。如果有，则加上对应的大小</p>
</li>
<li><p>再接着就到了<code>Block_descriptor_3</code>这一部分，这是我们的主角。首先判断一下layout是否有值，有值继续往下处理</p>
</li>
<li><p>如果layout 小于 <code>0x1000</code>，则代表是压缩布局，<code>0xXYZ</code></p>
<ul>
<li><p>分别取出xyz，取出的值代表的就是对应的数量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> short xyz = (<span class="keyword">unsigned</span> short)(extlayoutstr);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> x = (xyz &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取前四位 代表x</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> y = (xyz &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取中间四位 代表y</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> z = (xyz &gt;&gt; <span class="number">0</span>) &amp; <span class="number">0xF</span>; <span class="comment">// 取末尾四位 代表z</span></span><br></pre></td></tr></table></figure>

<p>举个例子讲一下这里的位运算，假如xyz值为 <code>1010 0010 1100</code> ，取高四位。首先右移8位之后变为了 <code>0000 0000 1010</code> ，高四位的值到了低四位，前面补0，然后按位与上<code>0xF</code>，也就是<code>0000 0000 1111</code>，所以就取出了低四位的值 <code>1010</code>。其他一样的道理</p>
</li>
<li><p>这里分别取出来值以后，把它包装成<code>0xPN</code>的形式，方便后面统一处理。如果是x，x表示强引用<code>BLOCK_LAYOUT_STRONG</code> , 因为类型是P表示，所以要对<code>BLOCK_LAYOUT_STRONG</code>类型左移4位，低4位就是x的值。 用16进制表示就是<code>0x30 | x</code>，若x为F，就是<code>0x3F</code>，用二进制表示就是 <code>0011 1111</code>。 以此类推，把xyz都包装成<code>0xPN</code>形式</p>
</li>
</ul>
</li>
<li><p>在上一步如果小于0x1000的话，也已经包装成了0xPN的形式。大于等于0x1000的话，本来就是0xPN的形式。所以下面就开始根据这种格式找出我们所需要的对象了</p>
</li>
<li><p>根据<code>extlayoutStr</code>的length进行for循环，取出对应字节中的数据，这时候取出来的就是0XPN的形式，进行位运算取出p和n，然后判断p的类型，分别对<code>BLOCK_LAYOUT_STRONG</code> 和 <code>BLOCK_LAYOUT_BYREF</code> 这两种类型进行处理</p>
<ul>
<li>如果<code>P == BLOCK_LAYOUT_STRONG</code>，根据偏移找到对象，转换为oc对象打印</li>
<li>如果<code>P == BLOCK_LAYOUT_BYREF</code> 根据偏移找到的对象为byref对象，byref对象需要根据flags判断内部引用的是对象还是基本数据类型，如果是对象类型，则根据byref内部偏移找到具体对象打印。如果为基本数据类型，则不做处理</li>
<li>每次循环结束，偏移offset增加一个指针的大小，用于获取下一个对象</li>
</ul>
</li>
</ol>
<h2 id="hook-block"><a href="#hook-block" class="headerlink" title="hook block"></a>hook block</h2><p>iOS中hook oc对象用系统的method swizzer可以很方便的做到。但是block作为特殊的oc对象，方法交换并不适用。hook block的本质就是找到invoke函数指针和block的signature方法签名。</p>
<p>网上大致有两种实现方式</p>
<ul>
<li>一种是把invoke指针指向消息转发，然后通过NSInvocation进行调用，参考文章<a href="https://juejin.im/post/5c653921e51d457fa676eafc" target="_blank" rel="noopener">Block hook 正确姿势</a></li>
<li>另外一种是使用libffi来动态调用c函数，参考文章 <a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/" target="_blank" rel="noopener">Hook Objective-C Block with Libffi</a></li>
</ul>
<p>如果需要hook block的，可以参考上面两篇文章进行学习，每一个都有对应的demo实现。这里就不再赘述了</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502-CH1-SW1" target="_blank" rel="noopener">官方文档</a></p>
<p><a href="https://opensource.apple.com/source/libclosure/" target="_blank" rel="noopener">官方开源库</a></p>
<p><a href="https://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/" target="_blank" rel="noopener">A look inside blocks</a></p>
<p><a href="https://juejin.im/post/5d7e3b8de51d4561ac7bcd5f" target="_blank" rel="noopener">一种查看Block中引用的所有外部对象</a></p>
<p><a href="http://yulingtianxia.com/blog/2018/02/28/Hook-Objective-C-Block-with-Libffi/" target="_blank" rel="noopener">Hook Objective-C Block with Libffi</a></p>
<p><a href="https://juejin.im/post/5c653921e51d457fa676eafc" target="_blank" rel="noopener">Block hook 正确姿势</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmzcool.top/2020/05/06/block/">http://lmzcool.top/2020/05/06/block/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmzcool.top" target="_blank">GN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/04/10/image_assets/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">iOS图片移到assets问题记录</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'v26lyi3lmFjLAjSuqbPuAQWf-gzGzoHsz',
  appKey: 'kXNYMLXOoEDtuSEqWE7SadDa',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By GN</div><div class="icp"><a><span>京ICP备19014027号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>