<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Dyld | GN</title><meta name="description" content="Dyld"><meta name="author" content="GN"><meta name="copyright" content="GN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Dyld"><meta name="twitter:description" content="Dyld"><meta name="twitter:image" content="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png"><meta property="og:type" content="article"><meta property="og:title" content="Dyld"><meta property="og:url" content="http://lmzcool.top/2020/04/06/dyld/"><meta property="og:site_name" content="GN"><meta property="og:description" content="Dyld"><meta property="og:image" content="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://lmzcool.top/2020/04/06/dyld/"><link rel="prev" title="Mac OS X ABI Mach-O File Format Reference" href="http://lmzcool.top/2020/04/06/machoFormat/"><link rel="next" title="Fishhook使用和源码解析" href="http://lmzcool.top/2020/04/06/fishHook/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dyld加载流程"><span class="toc-number">2.</span> <span class="toc-text">dyld加载流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dyld-start"><span class="toc-number">2.1.</span> <span class="toc-text">__dyld_start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootstrap-start"><span class="toc-number">2.2.</span> <span class="toc-text">bootstrap::start()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dyld-main"><span class="toc-number">2.3.</span> <span class="toc-text">dyld::_main()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#设置检查运行环境"><span class="toc-number">2.3.1.</span> <span class="toc-text">设置检查运行环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载共享缓存"><span class="toc-number">2.3.2.</span> <span class="toc-text">加载共享缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载主程序"><span class="toc-number">2.3.3.</span> <span class="toc-text">加载主程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载插入的动态库"><span class="toc-number">2.3.4.</span> <span class="toc-text">加载插入的动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链接主程序"><span class="toc-number">2.3.5.</span> <span class="toc-text">链接主程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链接插入的动态库"><span class="toc-number">2.3.6.</span> <span class="toc-text">链接插入的动态库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#执行所有初始化"><span class="toc-number">2.3.7.</span> <span class="toc-text">执行所有初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#查找main-函数"><span class="toc-number">2.3.8.</span> <span class="toc-text">查找main()函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dyld3"><span class="toc-number">3.</span> <span class="toc-text">dyld3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#out-of-process-mach-o-parser"><span class="toc-number">3.1.</span> <span class="toc-text">out-of-process mach-o parser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-process-engine"><span class="toc-number">3.2.</span> <span class="toc-text">in-process engine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#launch-closure-cache"><span class="toc-number">3.3.</span> <span class="toc-text">launch closure cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文档"><span class="toc-number">4.</span> <span class="toc-text">参考文档</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">GN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Dyld</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-06 19:41:08"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-12 23:13:27"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/06/dyld/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/06/dyld/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>内核加载mach-o文件，fork一条新的线程出来，分配内存，解析主程序的mach-o信息，读取主程序mach-o头信息，遍历主程序每条load command信息，装载进内存，解析dyld，讲entry_point入口地址改为dyld的入口地址。进入entry_point对应的入口，启动dyld，设置进程的主线程</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png"  alt=""></p>
<p><strong>dyld</strong>（the dynamic link editor）动态链接器。系统内核加载mach-o做完初始化操作之后，交由dyld处理</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld@2x.png"  alt=""></p>
<p>dyld主要做动态库加载，链接，初始化等操作，一直处理到调用程序的main()函数为止。</p>
<h2 id="dyld加载流程"><a href="#dyld加载流程" class="headerlink" title="dyld加载流程"></a>dyld加载流程</h2><p>首先在+load函数打断点，看一下之前的调用堆栈</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/start@2x.png"  alt=""></p>
<p>从图中可以看到首先调用了dyld中的_dyld_start方法，再接着调用dyldbootstrap::start()方法。</p>
<h3 id="dyld-start"><a href="#dyld-start" class="headerlink" title="__dyld_start"></a>__dyld_start</h3><p><a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">dyld</a>是开源的，这里讨论的是dyld2，下载源码，搜索_dyld_start在何处使用，找到是在<code>dyldStartup.s</code>汇编文件内，从汇编内注释看到调用了dyldbootstrap::start</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyldstart@2x.png"  alt=""></p>
<h3 id="bootstrap-start"><a href="#bootstrap-start" class="headerlink" title="bootstrap::start()"></a>bootstrap::start()</h3><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/func_start.png"  alt=""></p>
<p>start()内做了四步操作</p>
<ul>
<li>根据slide确定是否rebaseDyld()</li>
<li>初始化mach消息</li>
<li>保护栈溢出</li>
<li>调用dyld::_main()函数进行下一步操作</li>
</ul>
<h3 id="dyld-main"><a href="#dyld-main" class="headerlink" title="dyld::_main()"></a>dyld::_main()</h3><p>main()函数是dyld主要的加载步骤。</p>
<p>内核加载dyld并跳转到__dyld_start设置一些寄存器信息之后，调用此函数。 </p>
<p>返回主程序的main()函数，并在__dyld_start内实现跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, </span><br><span class="line">		int argc, const char* argv[], const char* envp[], const char* apple[], </span><br><span class="line">		uintptr_t* startGlue)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">    </span><br><span class="line">	uintptr_t result &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; mach-o</span><br><span class="line">	sMainExecutableMachHeader &#x3D; mainExecutableMH;</span><br><span class="line">	&#x2F;&#x2F; slide</span><br><span class="line">	sMainExecutableSlide &#x3D; mainExecutableSlide;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(&quot;dyld: launch started&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 设置上下文(函数的参数，标识信息)</span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Pickup the pointer to the exec path.</span><br><span class="line">	&#x2F;&#x2F; 执行路径的指针</span><br><span class="line">	sExecPath &#x3D; _simple_getenv(apple, &quot;executable_path&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;13868260&gt; Remove interim apple[0] transition code from dyld</span><br><span class="line">	if (!sExecPath) sExecPath &#x3D; apple[0];</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 若是相对路径，则使变为绝对路径</span><br><span class="line">	if ( sExecPath[0] !&#x3D; &#39;&#x2F;&#39; ) &#123;</span><br><span class="line">		&#x2F;&#x2F; have relative path, use cwd to make absolute</span><br><span class="line">		char cwdbuff[MAXPATHLEN];</span><br><span class="line">	    if ( getcwd(cwdbuff, MAXPATHLEN) !&#x3D; NULL ) &#123;</span><br><span class="line">			&#x2F;&#x2F; maybe use static buffer to avoid calling malloc so early...</span><br><span class="line">			char* s &#x3D; new char[strlen(cwdbuff) + strlen(sExecPath) + 2];</span><br><span class="line">			strcpy(s, cwdbuff);</span><br><span class="line">			strcat(s, &quot;&#x2F;&quot;);</span><br><span class="line">			strcat(s, sExecPath);</span><br><span class="line">			sExecPath &#x3D; s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Remember short name of process for later logging</span><br><span class="line">	&#x2F;&#x2F; 进程shortName</span><br><span class="line">	sExecShortName &#x3D; ::strrchr(sExecPath, &#39;&#x2F;&#39;);</span><br><span class="line">	if ( sExecShortName !&#x3D; NULL )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	else</span><br><span class="line">		sExecShortName &#x3D; sExecPath;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 配置进程限制条件</span><br><span class="line">    configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; 检查环境变量</span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 打印配置的环境变量</span><br><span class="line">	if ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">	if ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	&#x2F;&#x2F; 获取相关程序架构,到这里整个环境配置完成</span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; load shared cache</span><br><span class="line">	&#x2F;&#x2F; 加载共享缓存, iOS必须开启</span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">	&#x2F;&#x2F; &lt;HACK&gt; until &lt;rdar:&#x2F;&#x2F;30773711&gt; is fixed</span><br><span class="line">	gLinkContext.sharedRegionMode &#x3D; ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">	&#x2F;&#x2F; &lt;&#x2F;HACK&gt;</span><br><span class="line">#endif</span><br><span class="line">	if ( gLinkContext.sharedRegionMode !&#x3D; ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">		&#x2F;&#x2F; 开启共享缓存，map</span><br><span class="line">		mapSharedCache();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(sLoadingCrashMessage);</span><br><span class="line">		&#x2F;&#x2F; instantiate ImageLoader for main executable</span><br><span class="line">		&#x2F;&#x2F; 初始化 ImageLoader 加载主程序</span><br><span class="line">		sMainExecutable &#x3D; instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">		gLinkContext.mainExecutable &#x3D; sMainExecutable;</span><br><span class="line">		&#x2F;&#x2F; 签名信息</span><br><span class="line">		gLinkContext.mainExecutableCodeSigned &#x3D; hasCodeSignatureLoadCommand(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; load any inserted libraries</span><br><span class="line">		&#x2F;&#x2F; 加载插入的动态库</span><br><span class="line">		&#x2F;&#x2F; 和主程序一起加入到sAllImages中</span><br><span class="line">		if	( sEnv.DYLD_INSERT_LIBRARIES !&#x3D; NULL ) &#123;</span><br><span class="line">			for (const char* const* lib &#x3D; sEnv.DYLD_INSERT_LIBRARIES; *lib !&#x3D; NULL; ++lib) </span><br><span class="line">				loadInsertedDylib(*lib);</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; record count of inserted libraries so that a flat search will look at </span><br><span class="line">		&#x2F;&#x2F; inserted libraries, then main, then others.</span><br><span class="line">		&#x2F;&#x2F; 记录插入的动态库的个数 -1是因为sAllImages中有一个是主程序</span><br><span class="line">		sInsertedDylibCount &#x3D; sAllImages.size()-1;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; link main executable</span><br><span class="line">		&#x2F;&#x2F; 链接主可执行文件</span><br><span class="line">		gLinkContext.linkingMainExecutable &#x3D; true;</span><br><span class="line">#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">		if ( mainExcutableAlreadyRebased ) &#123;</span><br><span class="line">			&#x2F;&#x2F; previous link() on main executable has already adjusted its internal pointers for ASLR</span><br><span class="line">			&#x2F;&#x2F; work around that by rebasing by inverse amount</span><br><span class="line">			sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide);</span><br><span class="line">		&#125;</span><br><span class="line">#endif</span><br><span class="line">		&#x2F;&#x2F; 链接</span><br><span class="line">		link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">		sMainExecutable-&gt;setNeverUnloadRecursive();</span><br><span class="line">		if ( sMainExecutable-&gt;forceFlat() ) &#123;</span><br><span class="line">			gLinkContext.bindFlat &#x3D; true;</span><br><span class="line">			gLinkContext.prebindUsage &#x3D; ImageLoader::kUseNoPrebinding;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; link any inserted libraries</span><br><span class="line">		&#x2F;&#x2F; do this after linking main executable so that any dylibs pulled in by inserted </span><br><span class="line">		&#x2F;&#x2F; dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span><br><span class="line">		&#x2F;&#x2F; 链接插入的动态库</span><br><span class="line">		&#x2F;&#x2F; 在链接主程序之后执行此操作，为了使插入的动态库不会在主程序的动态库前面使用</span><br><span class="line">		if ( sInsertedDylibCount &gt; 0 ) &#123;</span><br><span class="line">			for(unsigned int i&#x3D;0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image &#x3D; sAllImages[i+1];</span><br><span class="line">				link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">				image-&gt;setNeverUnloadRecursive();</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; only INSERTED libraries can interpose</span><br><span class="line">			&#x2F;&#x2F; register interposing info after all inserted libraries are bound so chaining works</span><br><span class="line">			for(unsigned int i&#x3D;0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image &#x3D; sAllImages[i+1];</span><br><span class="line">				image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES</span><br><span class="line">		&#x2F;&#x2F; 即使没有 DYLD_INSERT_LIBRARIES，dyld也应该支持插入</span><br><span class="line">		for (long i&#x3D;sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">			ImageLoader* image &#x3D; sAllImages[i];</span><br><span class="line">			if ( image-&gt;inSharedCache() )</span><br><span class="line">				continue;</span><br><span class="line">			image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">	#if SUPPORT_ACCELERATE_TABLES</span><br><span class="line">		if ( (sAllCacheImagesProxy !&#x3D; NULL) &amp;&amp; ImageLoader::haveInterposingTuples() ) &#123;</span><br><span class="line">			&#x2F;&#x2F; Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled</span><br><span class="line">			ImageLoader::clearInterposingTuples();</span><br><span class="line">			&#x2F;&#x2F; unmap all loaded dylibs (but not main executable)</span><br><span class="line">			for (long i&#x3D;1; i &lt; sAllImages.size(); ++i) &#123;</span><br><span class="line">				ImageLoader* image &#x3D; sAllImages[i];</span><br><span class="line">				if ( image &#x3D;&#x3D; sMainExecutable )</span><br><span class="line">					continue;</span><br><span class="line">				if ( image &#x3D;&#x3D; sAllCacheImagesProxy )</span><br><span class="line">					continue;</span><br><span class="line">				image-&gt;setCanUnload();</span><br><span class="line">				ImageLoader::deleteImage(image);</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F; note: we don&#39;t need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table</span><br><span class="line">			sAllImages.clear();</span><br><span class="line">			sImageRoots.clear();</span><br><span class="line">			sImageFilesNeedingTermination.clear();</span><br><span class="line">			sImageFilesNeedingDOFUnregistration.clear();</span><br><span class="line">			sAddImageCallbacks.clear();</span><br><span class="line">			sRemoveImageCallbacks.clear();</span><br><span class="line">			sAddLoadImageCallbacks.clear();</span><br><span class="line">			sDisableAcceleratorTables &#x3D; true;</span><br><span class="line">			sAllCacheImagesProxy &#x3D; NULL;</span><br><span class="line">			sMappedRangesStart &#x3D; NULL;</span><br><span class="line">			mainExcutableAlreadyRebased &#x3D; true;</span><br><span class="line">			gLinkContext.linkingMainExecutable &#x3D; false;</span><br><span class="line">			resetAllImages();</span><br><span class="line">			goto reloadAllImages;</span><br><span class="line">		&#125;</span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; apply interposing to initial set of images</span><br><span class="line">		&#x2F;&#x2F; 对初始化images进行插入</span><br><span class="line">		for(int i&#x3D;0; i &lt; sImageRoots.size(); ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;applyInterposing(gLinkContext);</span><br><span class="line">		&#125;</span><br><span class="line">		ImageLoader::applyInterposingToDyldCache(gLinkContext);</span><br><span class="line">		gLinkContext.linkingMainExecutable &#x3D; false;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Bind and notify for the main executable now that interposing has been registered</span><br><span class="line">		&#x2F;&#x2F; 绑定 通知 主可执行文件</span><br><span class="line">		uint64_t bindMainExecutableStartTime &#x3D; mach_absolute_time();</span><br><span class="line">		sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true);</span><br><span class="line">		uint64_t bindMainExecutableEndTime &#x3D; mach_absolute_time();</span><br><span class="line">		ImageLoaderMachO::fgTotalBindTime +&#x3D; bindMainExecutableEndTime - bindMainExecutableStartTime;</span><br><span class="line">		gLinkContext.notifyBatch(dyld_image_state_bound, false);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Bind and notify for the inserted images now interposing has been registered</span><br><span class="line">		&#x2F;&#x2F; 已插入和注册的images的绑定和通知</span><br><span class="line">		if ( sInsertedDylibCount &gt; 0 ) &#123;</span><br><span class="line">			for(unsigned int i&#x3D;0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">				ImageLoader* image &#x3D; sAllImages[i+1];</span><br><span class="line">				image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;12186933&gt; do weak binding only after all inserted images linked</span><br><span class="line">		&#x2F;&#x2F; 弱绑定</span><br><span class="line">		sMainExecutable-&gt;weakBind(gLinkContext);</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; If cache has branch island dylibs, tell debugger about them</span><br><span class="line">		if ( (sSharedCacheLoadInfo.loadAddress !&#x3D; NULL) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.mappingOffset &gt;&#x3D; 0x78) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset !&#x3D; 0) ) &#123;</span><br><span class="line">			uint32_t count &#x3D; sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsCount;</span><br><span class="line">			dyld_image_info info[count];</span><br><span class="line">			const uint64_t* poolAddress &#x3D; (uint64_t*)((char*)sSharedCacheLoadInfo.loadAddress + sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset);</span><br><span class="line">			&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;20799203&gt; empty branch pools can be in development cache</span><br><span class="line">			if ( ((mach_header*)poolAddress)-&gt;magic &#x3D;&#x3D; sMainExecutableMachHeader-&gt;magic ) &#123;</span><br><span class="line">				for (int poolIndex&#x3D;0; poolIndex &lt; count; ++poolIndex) &#123;</span><br><span class="line">					uint64_t poolAddr &#x3D; poolAddress[poolIndex] + sSharedCacheLoadInfo.slide;</span><br><span class="line">					info[poolIndex].imageLoadAddress &#x3D; (mach_header*)(long)poolAddr;</span><br><span class="line">					info[poolIndex].imageFilePath &#x3D; &quot;dyld_shared_cache_branch_islands&quot;;</span><br><span class="line">					info[poolIndex].imageFileModDate &#x3D; 0;</span><br><span class="line">				&#125;</span><br><span class="line">				&#x2F;&#x2F; add to all_images list</span><br><span class="line">				addImagesToAllImages(count, info);</span><br><span class="line">				&#x2F;&#x2F; tell gdb about new branch island images</span><br><span class="line">				gProcessInfo-&gt;notification(dyld_image_adding, count, info);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;);</span><br><span class="line">	#if SUPPORT_OLD_CRT_INITIALIZATION</span><br><span class="line">		&#x2F;&#x2F; Old way is to run initializers via a callback from crt1.o</span><br><span class="line">		if ( ! gRunInitializersOldWay ) </span><br><span class="line">			initializeMainExecutable(); </span><br><span class="line">	#else</span><br><span class="line">		&#x2F;&#x2F; run all initializers</span><br><span class="line">		&#x2F;&#x2F; 执行所有的初始化</span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">	#endif</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; notify any montoring proccesses that this process is about to enter main()</span><br><span class="line">		if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">			dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2);</span><br><span class="line">		&#125;</span><br><span class="line">		notifyMonitoringDyldMain();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; find entry point for main executable</span><br><span class="line">		&#x2F;&#x2F; 找 main 函数的入口, 返回由start进行调用</span><br><span class="line">		result &#x3D; (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">		if ( result !&#x3D; 0 ) &#123;</span><br><span class="line">			&#x2F;&#x2F; main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span><br><span class="line">			if ( (gLibSystemHelpers !&#x3D; NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;&#x3D; 9) )</span><br><span class="line">				*startGlue &#x3D; (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">			else</span><br><span class="line">				halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span><br><span class="line">			result &#x3D; (uintptr_t)sMainExecutable-&gt;getEntryFromLC_UNIXTHREAD();</span><br><span class="line">			*startGlue &#x3D; 0;</span><br><span class="line">		&#125;</span><br><span class="line">#if __has_feature(ptrauth_calls)</span><br><span class="line">		&#x2F;&#x2F; start() calls the result pointer as a function pointer so we need to sign it.</span><br><span class="line">		result &#x3D; (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);</span><br><span class="line">#endif</span><br><span class="line">	&#125;</span><br><span class="line">	catch(const char* message) &#123;</span><br><span class="line">		syncAllImages();</span><br><span class="line">		halt(message);</span><br><span class="line">	&#125;</span><br><span class="line">	catch(...) &#123;</span><br><span class="line">		dyld::log(&quot;dyld: launch failed\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(&quot;dyld2 mode&quot;);</span><br><span class="line"></span><br><span class="line">	if (sSkipMain) &#123;</span><br><span class="line">		if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">			dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2);</span><br><span class="line">		&#125;</span><br><span class="line">		result &#x3D; (uintptr_t)&amp;fake_main;</span><br><span class="line">		*startGlue &#x3D; (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是_main()函数经简化之后的代码，可以看出主要分为了几个步骤</p>
<ul>
<li>设置检查运行环境</li>
<li>加载共享缓存，iOS必须开启</li>
<li>初始化 ImageLoader 加载主程序</li>
<li>加载插入的动态库</li>
<li>链接主程序</li>
<li>链接插入的动态库</li>
<li>执行所有初始化</li>
<li>查找main()函数并返回</li>
</ul>
<h4 id="设置检查运行环境"><a href="#设置检查运行环境" class="headerlink" title="设置检查运行环境"></a>设置检查运行环境</h4><p>主要获取基本信息，设置上下文，配置环境变量，检查受限条件等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">	if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) &#123;</span><br><span class="line">		launchTraceID &#x3D; dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (uint64_t)mainExecutableMH, 0, 0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Grab the cdHash of the main executable from the environment</span><br><span class="line">	&#x2F;&#x2F; 从环境中获取主执行文件的hash</span><br><span class="line">	uint8_t mainExecutableCDHashBuffer[20];</span><br><span class="line">	const uint8_t* mainExecutableCDHash &#x3D; nullptr;</span><br><span class="line">	if ( hexToBytes(_simple_getenv(apple, &quot;executable_cdhash&quot;), 40, mainExecutableCDHashBuffer) )</span><br><span class="line">		mainExecutableCDHash &#x3D; mainExecutableCDHashBuffer;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Trace dyld&#39;s load</span><br><span class="line">	&#x2F;&#x2F; 跟踪dyld加载</span><br><span class="line">	notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));</span><br><span class="line">#if !TARGET_IPHONE_SIMULATOR</span><br><span class="line">	&#x2F;&#x2F; Trace the main executable&#39;s load</span><br><span class="line">	&#x2F;&#x2F; 非模拟器 跟踪主执行文件的load</span><br><span class="line">	notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	uintptr_t result &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; mach-o</span><br><span class="line">	sMainExecutableMachHeader &#x3D; mainExecutableMH;</span><br><span class="line">	&#x2F;&#x2F; slide</span><br><span class="line">	sMainExecutableSlide &#x3D; mainExecutableSlide;</span><br><span class="line"></span><br><span class="line">	CRSetCrashLogMessage(&quot;dyld: launch started&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 设置上下文(函数的参数，标识信息)</span><br><span class="line">	setContext(mainExecutableMH, argc, argv, envp, apple);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Pickup the pointer to the exec path.</span><br><span class="line">	&#x2F;&#x2F; 执行路径的指针</span><br><span class="line">	sExecPath &#x3D; _simple_getenv(apple, &quot;executable_path&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;13868260&gt; Remove interim apple[0] transition code from dyld</span><br><span class="line">	if (!sExecPath) sExecPath &#x3D; apple[0];</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 若是相对路径，则使变为绝对路径</span><br><span class="line">	if ( sExecPath[0] !&#x3D; &#39;&#x2F;&#39; ) &#123;</span><br><span class="line">		&#x2F;&#x2F; have relative path, use cwd to make absolute</span><br><span class="line">		char cwdbuff[MAXPATHLEN];</span><br><span class="line">	    if ( getcwd(cwdbuff, MAXPATHLEN) !&#x3D; NULL ) &#123;</span><br><span class="line">			&#x2F;&#x2F; maybe use static buffer to avoid calling malloc so early...</span><br><span class="line">			char* s &#x3D; new char[strlen(cwdbuff) + strlen(sExecPath) + 2];</span><br><span class="line">			strcpy(s, cwdbuff);</span><br><span class="line">			strcat(s, &quot;&#x2F;&quot;);</span><br><span class="line">			strcat(s, sExecPath);</span><br><span class="line">			sExecPath &#x3D; s;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Remember short name of process for later logging</span><br><span class="line">	&#x2F;&#x2F; 进程shortName</span><br><span class="line">	sExecShortName &#x3D; ::strrchr(sExecPath, &#39;&#x2F;&#39;);</span><br><span class="line">	if ( sExecShortName !&#x3D; NULL )</span><br><span class="line">		++sExecShortName;</span><br><span class="line">	else</span><br><span class="line">		sExecShortName &#x3D; sExecPath;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 配置进程限制条件</span><br><span class="line">    configureProcessRestrictions(mainExecutableMH);</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; 检查环境变量</span><br><span class="line">		checkEnvironmentVariables(envp);</span><br><span class="line">		defaultUninitializedFallbackPaths(envp);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 打印配置的环境变量</span><br><span class="line">	if ( sEnv.DYLD_PRINT_OPTS )</span><br><span class="line">		printOptions(argv);</span><br><span class="line">	if ( sEnv.DYLD_PRINT_ENV ) </span><br><span class="line">		printEnvironmentVariables(envp);</span><br><span class="line">	&#x2F;&#x2F; 获取相关程序架构,到这里整个环境配置完成</span><br><span class="line">	getHostInfo(mainExecutableMH, mainExecutableSlide);</span><br></pre></td></tr></table></figure>

<p>如果在xcode内设置了<code>DYLD_PRINT_OPTS</code>或<code>DYLD_PRINT_ENV</code>环境变量，则进行打印</p>
<h4 id="加载共享缓存"><a href="#加载共享缓存" class="headerlink" title="加载共享缓存"></a>加载共享缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	&#x2F;&#x2F; load shared cache</span><br><span class="line">	&#x2F;&#x2F; 加载共享缓存, iOS必须开启</span><br><span class="line">	checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">	&#x2F;&#x2F; &lt;HACK&gt; until &lt;rdar:&#x2F;&#x2F;30773711&gt; is fixed</span><br><span class="line">	gLinkContext.sharedRegionMode &#x3D; ImageLoader::kUsePrivateSharedRegion;</span><br><span class="line">	&#x2F;&#x2F; &lt;&#x2F;HACK&gt;</span><br><span class="line">#endif</span><br><span class="line">	if ( gLinkContext.sharedRegionMode !&#x3D; ImageLoader::kDontUseSharedRegion ) &#123;</span><br><span class="line">		&#x2F;&#x2F; 开启共享缓存，map</span><br><span class="line">		mapSharedCache();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>checkSharedRegionDisable()</code>检查是否开启共享缓存，从方法内部可以看到iOS不能没有共享缓存。</p>
<p>检查之后调用<code>mapSharedCache()</code>函数映射共享缓存，<code>mapSharedCache()</code>内部调用了<code>loadDyldCache()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">bool loadDyldCache(const SharedCacheOptions&amp; options, SharedCacheLoadInfo* results)</span><br><span class="line">&#123;</span><br><span class="line">    results-&gt;loadAddress        &#x3D; 0;</span><br><span class="line">    results-&gt;slide              &#x3D; 0;</span><br><span class="line">    results-&gt;errorMessage       &#x3D; nullptr;</span><br><span class="line"></span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">    &#x2F;&#x2F; simulator only supports mmap()ing cache privately into process</span><br><span class="line">    return mapCachePrivate(options, results);</span><br><span class="line">#else</span><br><span class="line">    if ( options.forcePrivate ) &#123;</span><br><span class="line">        &#x2F;&#x2F; mmap cache into this process only</span><br><span class="line">        &#x2F;&#x2F; 私有加载，仅加载到当前线程</span><br><span class="line">        return mapCachePrivate(options, results);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        &#x2F;&#x2F; fast path: when cache is already mapped into shared region</span><br><span class="line">        &#x2F;&#x2F; 如果已经存在缓存，则不需要做处理。 若没有，则调用mapCacheSystemWide()第一次加载</span><br><span class="line">        bool hasError &#x3D; false;</span><br><span class="line">        if ( reuseExistingCache(options, results) ) &#123;</span><br><span class="line">            hasError &#x3D; (results-&gt;errorMessage !&#x3D; nullptr);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; slow path: this is first process to load cache</span><br><span class="line">            hasError &#x3D; mapCacheSystemWide(options, results);</span><br><span class="line">        &#125;</span><br><span class="line">        return hasError;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模拟器 调用mapCachePrivate()结束</p>
<p>真机分为三种情况</p>
<ul>
<li><p>私有加载，仅加载到当前线程</p>
</li>
<li><p>如果已经存在缓存，则不需要做处理</p>
</li>
<li><p>如果没有，则调用则调用mapCacheSystemWide()进行第一次加载</p>
</li>
</ul>
<h4 id="加载主程序"><a href="#加载主程序" class="headerlink" title="加载主程序"></a>加载主程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; instantiate ImageLoader for main executable</span><br><span class="line">&#x2F;&#x2F; 初始化 ImageLoader 加载主程序</span><br><span class="line">sMainExecutable &#x3D; instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath);</span><br><span class="line">gLinkContext.mainExecutable &#x3D; sMainExecutable;</span><br><span class="line">&#x2F;&#x2F; 签名信息</span><br><span class="line">gLinkContext.mainExecutableCodeSigned &#x3D; hasCodeSignatureLoadCommand(mainExecutableMH);</span><br></pre></td></tr></table></figure>

<p>调用<code>instantiateFromLoadedImage()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; The kernel maps in main executable before dyld gets control.  We need to </span><br><span class="line">&#x2F;&#x2F; make an ImageLoader* for the already mapped in main executable.</span><br><span class="line">&#x2F;&#x2F; 在dyld获得控制权之前，内核映射到主可执行文件中。我们需要为已经映射到主可执行文件中的创建一个ImageLoader*。</span><br><span class="line">static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; try mach-o loader</span><br><span class="line">	&#x2F;&#x2F; 验证mach-o类型是否支持</span><br><span class="line">	if ( isCompatibleMachO((const uint8_t*)mh, path) ) &#123;</span><br><span class="line">		&#x2F;&#x2F; 初始化主二进制文件</span><br><span class="line">		ImageLoader* image &#x3D; ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		&#x2F;&#x2F; 添加主二进制文件到sAllImages数组中</span><br><span class="line">		addImage(image);</span><br><span class="line">		return (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	throw &quot;main executable not a known format&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先验证mach-o文件类型是否支持，验证通过之后调用<code>instantiateMainExecutable()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create image for main executable</span><br><span class="line">ImageLoader* ImageLoaderMachO::instantiateMainExecutable(const macho_header* mh, uintptr_t slide, const char* path, const LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;dyld::log(&quot;ImageLoader&#x3D;%ld, ImageLoaderMachO&#x3D;%ld, ImageLoaderMachOClassic&#x3D;%ld, ImageLoaderMachOCompressed&#x3D;%ld\n&quot;,</span><br><span class="line">	&#x2F;&#x2F;	sizeof(ImageLoader), sizeof(ImageLoaderMachO), sizeof(ImageLoaderMachOClassic), sizeof(ImageLoaderMachOCompressed));</span><br><span class="line">	bool compressed;</span><br><span class="line">	unsigned int segCount;</span><br><span class="line">	unsigned int libCount;</span><br><span class="line">	const linkedit_data_command* codeSigCmd;</span><br><span class="line">	const encryption_info_command* encryptCmd;</span><br><span class="line">	sniffLoadCommands(mh, path, false, &amp;compressed, &amp;segCount, &amp;libCount, context, &amp;codeSigCmd, &amp;encryptCmd);</span><br><span class="line">	&#x2F;&#x2F; instantiate concrete class based on content of load commands</span><br><span class="line">	&#x2F;&#x2F; 基于load commands实例化具体类</span><br><span class="line">	if ( compressed ) </span><br><span class="line">		return ImageLoaderMachOCompressed::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">	else</span><br><span class="line">#if SUPPORT_CLASSIC_MACHO</span><br><span class="line">		return ImageLoaderMachOClassic::instantiateMainExecutable(mh, slide, path, segCount, libCount, context);</span><br><span class="line">#else</span><br><span class="line">		throw &quot;missing LC_DYLD_INFO load command&quot;;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable()</code>内部首先调用<code>sniffLoadCommands()</code>来确定mach-o内部是否有压缩，以及有多少segment。如果有LC_DYLD_INFO、LC_DYLD_INFO_ONLY则确定是compressed。 Mach-o segment的数量不能大于255，依赖库的个数不能大于4095</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; fSegmentsArrayCount is only 8-bits</span><br><span class="line">&#x2F;&#x2F; mach-o 段的数量，最大不能大于255个</span><br><span class="line">if ( *segCount &gt; 255 )</span><br><span class="line">	dyld::throwf(&quot;malformed mach-o image: more than 255 segments in %s&quot;, path);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fSegmentsArrayCount is only 8-bits</span><br><span class="line">&#x2F;&#x2F; mach-o依赖库的个数，不能超过4095个</span><br><span class="line">if ( *libCount &gt; 4095 )</span><br><span class="line">	dyld::throwf(&quot;malformed mach-o image: more than 4095 dependent libraries in %s&quot;, path);</span><br></pre></td></tr></table></figure>

<p>根据是否压缩，调用不同实例类的<code>instantiateMainExecutable()</code>函数进行初始化</p>
<p>最后初始化完成之后调用<code>addImage(image);</code>把主二进制文件添加到全局<strong>sAllImages</strong>数组中</p>
<p>ps: 我们在lldb调试时输入<code>image list</code>查看所有image，第一个出现的是主程序模块，就是因为这里是第一个把主程序添加到sAllImages数组内。</p>
<h4 id="加载插入的动态库"><a href="#加载插入的动态库" class="headerlink" title="加载插入的动态库"></a>加载插入的动态库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; load any inserted libraries</span><br><span class="line">&#x2F;&#x2F; 加载插入的动态库</span><br><span class="line">&#x2F;&#x2F; 和主程序一起加入到sAllImages中</span><br><span class="line">if	( sEnv.DYLD_INSERT_LIBRARIES !&#x3D; NULL ) &#123;</span><br><span class="line">	for (const char* const* lib &#x3D; sEnv.DYLD_INSERT_LIBRARIES; *lib !&#x3D; NULL; ++lib) </span><br><span class="line">		loadInsertedDylib(*lib);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; record count of inserted libraries so that a flat search will look at </span><br><span class="line">&#x2F;&#x2F; inserted libraries, then main, then others.</span><br><span class="line">&#x2F;&#x2F; 记录插入的动态库的个数 -1是因为sAllImages中有一个是主程序</span><br><span class="line">sInsertedDylibCount &#x3D; sAllImages.size()-1;</span><br></pre></td></tr></table></figure>

<p>根据系统环境变量 <strong>DYLD_INSERT_LIBRARIES</strong>来确定是否有要插入的动态库，在越狱手机内就是通过这个变量把动态库注入到app内实现hook。</p>
<p>调用<code>loadInsertedDylib()</code>函数，内部再调用<code>load()</code>、<code>loadPhase0()</code>、<code>loadPhase2cache()</code>….</p>
<p>加载完毕之后同样添加到<strong>sAllImages</strong>数组内，并记录插入的动态库的数量sInsertedDylibCount</p>
<h4 id="链接主程序"><a href="#链接主程序" class="headerlink" title="链接主程序"></a>链接主程序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 链接</span><br><span class="line">link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#warning link链接</span><br><span class="line">void ImageLoader::link(const LinkContext&amp; context, bool forceLazysBound, bool preflightOnly, bool neverUnload, const RPathChain&amp; loaderRPaths, const char* imagePath)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F;dyld::log(&quot;ImageLoader::link(%s) refCount&#x3D;%d, neverUnload&#x3D;%d\n&quot;, imagePath, fDlopenReferenceCount, fNeverUnload);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; clear error strings</span><br><span class="line">	(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">	uint64_t t0 &#x3D; mach_absolute_time();</span><br><span class="line">	&#x2F;&#x2F; 递归加载依赖库</span><br><span class="line">	&#x2F;&#x2F; 在链接的时候，不仅仅是对主程序进行链接，还有很多依赖库也需要进行链接，所以首先循环加载依赖库</span><br><span class="line">	this-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; we only do the loading step for preflights</span><br><span class="line">	if ( preflightOnly )</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">	uint64_t t1 &#x3D; mach_absolute_time();</span><br><span class="line">	context.clearAllDepths();</span><br><span class="line">	&#x2F;&#x2F; 递归依赖层级</span><br><span class="line">	this-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">	__block uint64_t t2, t3, t4, t5;</span><br><span class="line">	&#123;</span><br><span class="line">		dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, 0, 0, 0);</span><br><span class="line">		t2 &#x3D; mach_absolute_time();</span><br><span class="line">		&#x2F;&#x2F; 递归进行rebase</span><br><span class="line">		this-&gt;recursiveRebase(context);</span><br><span class="line">		context.notifyBatch(dyld_image_state_rebased, false);</span><br><span class="line"></span><br><span class="line">		t3 &#x3D; mach_absolute_time();</span><br><span class="line">		if ( !context.linkingMainExecutable )</span><br><span class="line">			&#x2F;&#x2F; 递归进行符号绑定</span><br><span class="line">			this-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">		t4 &#x3D; mach_absolute_time();</span><br><span class="line">		if ( !context.linkingMainExecutable )</span><br><span class="line">			&#x2F;&#x2F; 弱绑定</span><br><span class="line">			this-&gt;weakBind(context);</span><br><span class="line">		t5 &#x3D; mach_absolute_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    if ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, false);</span><br><span class="line">	uint64_t t6 &#x3D; mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 注册DOF</span><br><span class="line">	std::vector&lt;DOFInfo&gt; dofs;</span><br><span class="line">	this-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">	context.registerDOFs(dofs);</span><br><span class="line">	uint64_t t7 &#x3D; mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; interpose any dynamically loaded images</span><br><span class="line">	if ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() !&#x3D; 0) ) &#123;</span><br><span class="line">		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_APPLY_INTERPOSING, 0, 0, 0);</span><br><span class="line">		this-&gt;recursiveApplyInterposing(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; clear error strings</span><br><span class="line">	(*context.setErrorStrings)(0, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">	fgTotalLoadLibrariesTime +&#x3D; t1 - t0;</span><br><span class="line">	fgTotalRebaseTime +&#x3D; t3 - t2;</span><br><span class="line">	fgTotalBindTime +&#x3D; t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime +&#x3D; t5 - t4;</span><br><span class="line">	fgTotalDOF +&#x3D; t7 - t6;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; done with initial dylib loads</span><br><span class="line">	fgNextPIEDylibAddress &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>recursiveLoadLibraries()递归加载依赖库，在链接的时候，不仅仅是对主程序进行链接，还有很多依赖库也需要进行链接，所以首先循环加载依赖库</p>
</li>
<li><p>recursiveUpdateDepth递归依赖层级</p>
</li>
<li><p>recursiveRebase递归进行符号rebase</p>
</li>
<li><p>recursiveBindWithAccounting递归进行符号绑定</p>
</li>
<li><p>weakBind弱绑定</p>
</li>
<li><p>registerDOFs注册<a href="https://www.jianshu.com/p/6acd36976fba" target="_blank" rel="noopener">DOF</a></p>
</li>
</ul>
<h4 id="链接插入的动态库"><a href="#链接插入的动态库" class="headerlink" title="链接插入的动态库"></a>链接插入的动态库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; link any inserted libraries</span><br><span class="line">&#x2F;&#x2F; do this after linking main executable so that any dylibs pulled in by inserted </span><br><span class="line">&#x2F;&#x2F; dylibs (e.g. libSystem) will not be in front of dylibs the program uses</span><br><span class="line">&#x2F;&#x2F; 链接插入的动态库</span><br><span class="line">&#x2F;&#x2F; 在链接主程序之后执行此操作，为了使插入的动态库不会在主程序的动态库前面使用</span><br><span class="line">if ( sInsertedDylibCount &gt; 0 ) &#123;</span><br><span class="line">	for(unsigned int i&#x3D;0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">		ImageLoader* image &#x3D; sAllImages[i+1];</span><br><span class="line">		link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);</span><br><span class="line">		image-&gt;setNeverUnloadRecursive();</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; only INSERTED libraries can interpose</span><br><span class="line">	&#x2F;&#x2F; register interposing info after all inserted libraries are bound so chaining works</span><br><span class="line">	for(unsigned int i&#x3D;0; i &lt; sInsertedDylibCount; ++i) &#123;</span><br><span class="line">		ImageLoader* image &#x3D; sAllImages[i+1];</span><br><span class="line">		image-&gt;registerInterposing(gLinkContext);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先取上文保存的sInsertedDylibCount来判断。i+1取出是因为第一个保存的是主二进制文件。</p>
<h4 id="执行所有初始化"><a href="#执行所有初始化" class="headerlink" title="执行所有初始化"></a>执行所有初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;);</span><br><span class="line">#if SUPPORT_OLD_CRT_INITIALIZATION</span><br><span class="line">	&#x2F;&#x2F; Old way is to run initializers via a callback from crt1.o</span><br><span class="line">	if ( ! gRunInitializersOldWay ) </span><br><span class="line">		initializeMainExecutable(); </span><br><span class="line">#else</span><br><span class="line">	&#x2F;&#x2F; run all initializers</span><br><span class="line">	&#x2F;&#x2F; 执行所有的初始化</span><br><span class="line">	initializeMainExecutable(); </span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p><code>initializeMainExecutable</code>开始执行初始化操作，可以看到方法内有针对<code>DYLD_PRINT_STATISTICS</code>、<code>DYLD_PRINT_STATISTICS_DETAILS</code>这两个环境变量的打印操作，我们在打印pre-main启动时间的时候会用到这个环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">void initializeMainExecutable()</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; record that we&#39;ve reached this step</span><br><span class="line">	&#x2F;&#x2F; 记录已经到此步骤</span><br><span class="line">	gLinkContext.startedInitializingMainExecutable &#x3D; true;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; run initialzers for any inserted dylibs</span><br><span class="line">	&#x2F;&#x2F; 执行初始化为已插入的动态库</span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[0].count &#x3D; 0;</span><br><span class="line">	const size_t rootCount &#x3D; sImageRoots.size();</span><br><span class="line">	if ( rootCount &gt; 1 ) &#123;</span><br><span class="line">		for(size_t i&#x3D;1; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; run initializers for main executable and everything it brings up</span><br><span class="line">	&#x2F;&#x2F; 为主可执行文件及其引发的所有内容运行初始化程序</span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span><br><span class="line">	if ( gLibSystemHelpers !&#x3D; NULL ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; dump info if requested</span><br><span class="line">	&#x2F;&#x2F; 如果设置了打印参数，打印具体的启动时间</span><br><span class="line">	if ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]);</span><br><span class="line">	if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用了<code>runInitializers()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span><br><span class="line">&#123;</span><br><span class="line">	uint64_t t1 &#x3D; mach_absolute_time();</span><br><span class="line">	mach_port_t thisThread &#x3D; mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count &#x3D; 1;</span><br><span class="line">	up.images[0] &#x3D; this;</span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, false);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	uint64_t t2 &#x3D; mach_absolute_time();</span><br><span class="line">	fgTotalInitTime +&#x3D; (t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用了<code>processInitializers()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;14412057&gt; upward dylib initializers can be run too soon</span><br><span class="line">&#x2F;&#x2F; To handle dangling dylibs which are upward linked but not downward, all upward linked dylibs</span><br><span class="line">&#x2F;&#x2F; have their initialization postponed until after the recursion through downward dylibs</span><br><span class="line">&#x2F;&#x2F; has completed.</span><br><span class="line">&#x2F;&#x2F; 向上dylib初始化程序可能运行得太快为了处理向上链接而不是向下链接的悬挂dylib，所有向上链接的dylib的初始化都被推迟到向下dylib的递归完成之后</span><br><span class="line">void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread,</span><br><span class="line">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span><br><span class="line">&#123;</span><br><span class="line">	uint32_t maxImageCount &#x3D; context.imageCount()+2;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups &#x3D; upsBuffer[0];</span><br><span class="line">	ups.count &#x3D; 0;</span><br><span class="line">	&#x2F;&#x2F; Calling recursive init on all images in images list, building a new list of</span><br><span class="line">	&#x2F;&#x2F; uninitialized upward dependencies.</span><br><span class="line">	for (uintptr_t i&#x3D;0; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F; If any upward dependencies remain, init them.</span><br><span class="line">	if ( ups.count &gt; 0 )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>processInitializers</code>内部调用了<code>recursiveInitialization()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize,</span><br><span class="line">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span><br><span class="line">&#123;</span><br><span class="line">	recursive_lock lock_info(this_thread);</span><br><span class="line">	recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line">	if ( fState &lt; dyld_image_state_dependents_initialized-1 ) &#123;</span><br><span class="line">		uint8_t oldState &#x3D; fState;</span><br><span class="line">		&#x2F;&#x2F; break cycles</span><br><span class="line">		fState &#x3D; dyld_image_state_dependents_initialized-1;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; initialize lower level libraries first</span><br><span class="line">			for(unsigned int i&#x3D;0; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage &#x3D; libImage(i);</span><br><span class="line">				if ( dependentImage !&#x3D; NULL ) &#123;</span><br><span class="line">					&#x2F;&#x2F; don&#39;t try to initialize stuff &quot;above&quot; me yet</span><br><span class="line">					if ( libIsUpward(i) ) &#123;</span><br><span class="line">						uninitUps.images[uninitUps.count] &#x3D; dependentImage;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					else if ( dependentImage-&gt;fDepth &gt;&#x3D; fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F; record termination order</span><br><span class="line">			if ( this-&gt;needsTermination() )</span><br><span class="line">				context.terminationRecorder(this);</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F; let objc know we are about to initialize this image</span><br><span class="line">			&#x2F;&#x2F; 通知objc即将初始化此image</span><br><span class="line">			uint64_t t1 &#x3D; mach_absolute_time();</span><br><span class="line">			fState &#x3D; dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState &#x3D; fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F; initialize this image</span><br><span class="line">			bool hasInitializers &#x3D; this-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F; let anyone know we finished initializing this image</span><br><span class="line">			&#x2F;&#x2F; 通知所有人已经完成初始化此image</span><br><span class="line">			fState &#x3D; dyld_image_state_initialized;</span><br><span class="line">			oldState &#x3D; fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, this, NULL);</span><br><span class="line">			</span><br><span class="line">			if ( hasInitializers ) &#123;</span><br><span class="line">				uint64_t t2 &#x3D; mach_absolute_time();</span><br><span class="line">				timingInfo.addTime(this-&gt;getShortName(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (const char* msg) &#123;</span><br><span class="line">			&#x2F;&#x2F; this image is not initialized</span><br><span class="line">			fState &#x3D; oldState;</span><br><span class="line">			recursiveSpinUnLock();</span><br><span class="line">			throw;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看notifySingle函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo)</span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	if ( (state &#x3D;&#x3D; dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit !&#x3D; NULL) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line">		uint64_t t0 &#x3D; mach_absolute_time();</span><br><span class="line">		dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0);</span><br><span class="line">		(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line">		uint64_t t1 &#x3D; mach_absolute_time();</span><br><span class="line">		uint64_t t2 &#x3D; mach_absolute_time();</span><br><span class="line">		uint64_t timeInObjC &#x3D; t1-t0;</span><br><span class="line">		uint64_t emptyTime &#x3D; (t2-t1)*100;</span><br><span class="line">		if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo !&#x3D; NULL) ) &#123;</span><br><span class="line">			timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索<code>sNotifyObjCInit</code>，找到是在<code>registerObjCNotifiers()</code>函数内赋值，接着全局搜索什么地方调用了registerObjCNotifiers()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void _dyld_objc_notify_register(_dyld_objc_notify_mapped    mapped,</span><br><span class="line">                                _dyld_objc_notify_init      init,</span><br><span class="line">                                _dyld_objc_notify_unmapped  unmapped)</span><br><span class="line">&#123;</span><br><span class="line">	dyld::registerObjCNotifiers(mapped, init, unmapped);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在代码层面已经无法继续跟进，我们需要在在项目内打符号断点查看_dyld_objc_notify_register在何处调用</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/objc_notify.png"  alt=""></p>
<p>从断点可以看出是<code>_objc_init</code>注册了这个通知，接下来我们打开<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime的开源库</a>，找到_objc_init方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* _objc_init</span><br><span class="line">* Bootstrap initialization. Registers our image notifier with dyld.</span><br><span class="line">* Called by libSystem BEFORE library initialization time</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line"></span><br><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized &#x3D; false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized &#x3D; true;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的确注册了这个通知，我们再来看load_images方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">load_images(const char *path __unused, const struct mach_header *mh)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Return without taking locks if there are no +load methods here.</span><br><span class="line">    if (!hasLoadMethods((const headerType *)mh)) return;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Discover load methods</span><br><span class="line">    &#123;</span><br><span class="line">        mutex_locker_t lock2(runtimeLock);</span><br><span class="line">        prepare_load_methods((const headerType *)mh);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call +load methods (without runtimeLock - re-entrant)</span><br><span class="line">    call_load_methods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先去查找类和分类文件，如果没有+load方法，则直接返回</p>
<p>接下来调用<code>call_load_methods()</code>调用+load方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods(void)</span><br><span class="line">&#123;</span><br><span class="line">		......</span><br><span class="line">    &#x2F;&#x2F; 加载所有类和分类的+load</span><br><span class="line">    do &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. Repeatedly call class +loads until there aren&#39;t any more</span><br><span class="line">        while (loadable_classes_used &gt; 0) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. Call category +loads ONCE</span><br><span class="line">        more_categories &#x3D; call_category_loads();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. Run more +loads if there are classes OR more untried categories</span><br><span class="line">    &#125; while (loadable_classes_used &gt; 0  ||  more_categories);</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，由此得出，项目内的所有+load方法是在这一步调用的，所有+load过多会影响启动速度。</p>
<p>接着回来看<code>recursiveInitialization()</code>这个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; initialize this image</span><br><span class="line">bool hasInitializers &#x3D; this-&gt;doInitialization(context);</span><br></pre></td></tr></table></figure>

<p>在通知之后，会调用doInitialization()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool ImageLoaderMachO::doInitialization(const LinkContext&amp; context)</span><br><span class="line">&#123;</span><br><span class="line">	CRSetCrashLogMessage2(this-&gt;getPath());</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; mach-o has -init and static initializers</span><br><span class="line">	&#x2F;&#x2F; 加载c++的构造函数 __mod_init_func</span><br><span class="line">	doImageInit(context);</span><br><span class="line">	doModInitFunctions(context);</span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage2(NULL);</span><br><span class="line">	</span><br><span class="line">	return (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在doInitialization()函数内会调用doModInitFunctions()，在这一步会加载c++的构造函数和<code>__attribute__((constructor))</code>，所以减少启动速度也可以在这一点进行优化。</p>
<p>至此，初始化阶段工作完成，下面简单总结一下调用步骤</p>
<ul>
<li><p>dyld::initializeMainExecutable()</p>
</li>
<li><p>ImageLoader::runInitializers()</p>
</li>
<li><p>ImageLoader::processInitializers()</p>
</li>
<li><p>ImageLoader::recursiveInitialization()</p>
</li>
<li><p>dyld::notifySingle()</p>
<ul>
<li>_dyld_objc_notify_init</li>
<li>_objc_init.  _dyld_objc_notify_register +load</li>
</ul>
</li>
<li><p>ImageLoaderMachO::doInitialization()</p>
<ul>
<li>ImageLoaderMachO::doModInitFunctions(). c++构造函数</li>
</ul>
</li>
</ul>
<h4 id="查找main-函数"><a href="#查找main-函数" class="headerlink" title="查找main()函数"></a>查找main()函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; find entry point for main executable</span><br><span class="line">		&#x2F;&#x2F; 找 main 函数的入口, 返回由start进行调用</span><br><span class="line">		result &#x3D; (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN();</span><br><span class="line">		if ( result !&#x3D; 0 ) &#123;</span><br><span class="line">			&#x2F;&#x2F; main executable uses LC_MAIN, we need to use helper in libdyld to call into main()</span><br><span class="line">			if ( (gLibSystemHelpers !&#x3D; NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;&#x3D; 9) )</span><br><span class="line">				*startGlue &#x3D; (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit;</span><br><span class="line">			else</span><br><span class="line">				halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			&#x2F;&#x2F; main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main()</span><br><span class="line">			result &#x3D; (uintptr_t)sMainExecutable-&gt;getEntryFromLC_UNIXTHREAD();</span><br><span class="line">			*startGlue &#x3D; 0;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>getEntryFromLC_MAIN()</code>查找从mach-o的LC_MAIN segment 查找main()函数入口</p>
<p>如果没有，通过<code>getEntryFromLC_UNIXTHREAD()</code>查找入口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void* ImageLoaderMachO::getEntryFromLC_MAIN() const</span><br><span class="line">&#123;</span><br><span class="line">	const uint32_t cmd_count &#x3D; ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	const struct load_command* const cmds &#x3D; (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</span><br><span class="line">	const struct load_command* cmd &#x3D; cmds;</span><br><span class="line">	for (uint32_t i &#x3D; 0; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		if ( cmd-&gt;cmd &#x3D;&#x3D; LC_MAIN ) &#123;</span><br><span class="line">			entry_point_command* mainCmd &#x3D; (entry_point_command*)cmd;</span><br><span class="line">			void* entry &#x3D; (void*)(mainCmd-&gt;entryoff + (char*)fMachOData);</span><br><span class="line">			&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;8543820&amp;9228031&gt; verify entry point is in image</span><br><span class="line">			if ( this-&gt;containsAddress(entry) )</span><br><span class="line">				return entry;</span><br><span class="line">			else</span><br><span class="line">				throw &quot;LC_MAIN entryoff is out of range&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cmd &#x3D; (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void* ImageLoaderMachO::getEntryFromLC_UNIXTHREAD() const</span><br><span class="line">&#123;</span><br><span class="line">	const uint32_t cmd_count &#x3D; ((macho_header*)fMachOData)-&gt;ncmds;</span><br><span class="line">	const struct load_command* const cmds &#x3D; (struct load_command*)&amp;fMachOData[sizeof(macho_header)];</span><br><span class="line">	const struct load_command* cmd &#x3D; cmds;</span><br><span class="line">	for (uint32_t i &#x3D; 0; i &lt; cmd_count; ++i) &#123;</span><br><span class="line">		if ( cmd-&gt;cmd &#x3D;&#x3D; LC_UNIXTHREAD ) &#123;</span><br><span class="line">	#if __i386__</span><br><span class="line">			const i386_thread_state_t* registers &#x3D; (i386_thread_state_t*)(((char*)cmd) + 16);</span><br><span class="line">			void* entry &#x3D; (void*)(registers-&gt;eip + fSlide);</span><br><span class="line">			&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;8543820&amp;9228031&gt; verify entry point is in image</span><br><span class="line">			if ( this-&gt;containsAddress(entry) )</span><br><span class="line">				return entry;</span><br><span class="line">	#elif __x86_64__</span><br><span class="line">			const x86_thread_state64_t* registers &#x3D; (x86_thread_state64_t*)(((char*)cmd) + 16);</span><br><span class="line">			void* entry &#x3D; (void*)(registers-&gt;rip + fSlide);</span><br><span class="line">			&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;8543820&amp;9228031&gt; verify entry point is in image</span><br><span class="line">			if ( this-&gt;containsAddress(entry) )</span><br><span class="line">				return entry;</span><br><span class="line">	#elif __arm64__ &amp;&amp; !__arm64e__</span><br><span class="line">			&#x2F;&#x2F; temp support until &lt;rdar:&#x2F;&#x2F;39514191&gt; is fixed</span><br><span class="line">			const uint64_t* regs64 &#x3D; (uint64_t*)(((char*)cmd) + 16);</span><br><span class="line">			void* entry &#x3D; (void*)(regs64[32] + fSlide); &#x2F;&#x2F; arm_thread_state64_t.__pc</span><br><span class="line">			&#x2F;&#x2F; &lt;rdar:&#x2F;&#x2F;problem&#x2F;8543820&amp;9228031&gt; verify entry point is in image</span><br><span class="line">			if ( this-&gt;containsAddress(entry) )</span><br><span class="line">				return entry;</span><br><span class="line">	#endif</span><br><span class="line">		&#125;</span><br><span class="line">		cmd &#x3D; (const struct load_command*)(((char*)cmd)+cmd-&gt;cmdsize);</span><br><span class="line">	&#125;</span><br><span class="line">	throw &quot;no valid entry point&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找到main()函数之后返回有__dyld_start调用。 至此，启动流程结束，进入主程序的main()函数</p>
<h2 id="dyld3"><a href="#dyld3" class="headerlink" title="dyld3"></a>dyld3</h2><p>WWDC2017推出了dyld3，应用在系统的app中。在iOS13开放给三方的app，极大优化了启动速度。</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld3@2x.png"  alt=""></p>
<p>dyld2是纯碎的in-process，也就是在程序进程内执行的，也就意味着只有当应用程序被启动的时候，dyld2才能开始执行任务。</p>
<p>针对于dyld2的流程，dyld3优化有以下两点思路</p>
<ul>
<li><p>识别安全性敏感的组件：解析 mach-o 文件并寻找依赖是安全性敏感的，因为恶意篡改的 mach-o 头部可以进行某些攻击，如果一个 app 使用了 @rpath，那么恶意修改路径或者将一些库插入到特定的地方，攻击者就可以毁坏 app。所以这部分工作需要被搬到进程外来完成，比如搬到一个 daemon 进程中。</p>
</li>
<li><p>识别可以被缓存的部分：符号查找就是其中一个，因为在一个特定的库中，除非软件更新或者这个库被改变，不然每个符号都应该有固定的偏移量。</p>
</li>
</ul>
<p>在 dyld 3.0 中，mach-o 头部解析和符号查找工作完成后，这些执行结果会被作为“启动闭包（launch closure）写入硬盘。</p>
<p>因此iOS操作系统的后台守护进程可以完成所有的这些工作。然后我们确定大量占用资源的部分，也就是占用缓冲的部分。它们是符号查找，因为在给定的库中，除非进行软件更新或者在磁盘上更改库，符号将始终位于库中的相同的偏移位置。</p>
<p>Dyld3中，将这些部分移到上层（图中红色的部分），然后向磁盘写入闭包处理 “Write closure to disk”。这样，启动闭包处理就成了启动程序的重要环节。稍后可以在APP的进程中使用 dyld 3包含的这三个部分，</p>
<p>启动闭包比mach-o更简单。它们是内存映射文件，不需要用复杂的方法进行分析。</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld3_1@2x.png"  alt=""></p>
<p>dyld3包含了3个组件</p>
<ul>
<li>进程外的mach-o解析编译器</li>
<li>进程内的执行launch closures的解析引擎</li>
<li>launch closure的缓存服务</li>
</ul>
<h3 id="out-of-process-mach-o-parser"><a href="#out-of-process-mach-o-parser" class="headerlink" title="out-of-process mach-o parser"></a>out-of-process mach-o parser</h3><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld3_2@2x.png"  alt=""></p>
<p>在dyld 2的加载流程中，Parse mach-o headers和Find Dependencies存在安全风险（可以通过修改mach-o header及添加非法@rpath进行攻击），而Perform symbol lookups会耗费较多的CPU时间，因为一个库文件不变时，符号将始终位于库中相同的偏移位置，这两部分在dyld 3中将采用提前写入把结果数据缓存成文件的方式构成一个”lauch closure“（可以理解为缓存文件）。</p>
<ul>
<li><p>处理了所有可能影响启动速度的 search path，@rpaths 和环境变量</p>
</li>
<li><p>解析 mach-o 二进制文件，分析其依赖的动态库</p>
</li>
<li><p>执行所有符号查找的工作</p>
</li>
<li><p>最后它将这些工作的结果创建成了启动闭包，写入缓存，这样，在应用启动的时候，就可以直接从缓存中读取数据，加快加载速度。</p>
</li>
<li><p>这是一个普通的 daemon 进程，可以使用通常的测试架构。</p>
</li>
</ul>
<p>out-of-process是一个普通的后台守护程序，因为从各个APP进程抽离出来了，可以提高dyld3的可测试性。</p>
<h3 id="in-process-engine"><a href="#in-process-engine" class="headerlink" title="in-process engine"></a>in-process engine</h3><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld3_3@2x.png"  alt=""></p>
<p>进程内验证launch closure是否正确，映射所有的动态库，执行初始化并跳转到main()函数。</p>
<p>不需要解析mach-o头文件或者查找符号，这是花费大部分时间的地方，优化了这一部分，所以带来了更快的启动</p>
<h3 id="launch-closure-cache"><a href="#launch-closure-cache" class="headerlink" title="launch closure cache"></a>launch closure cache</h3><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/dyld3_4@2x.png"  alt=""></p>
<ul>
<li>系统的app的<code>launch closures</code>直接构建到共享的缓存内，可以运行和分析系统中每一个mach-o文件</li>
<li>对于第三方的app，将在程序安装期间构建<code>launch closures</code>，在系统更新期间重新构建。因为那时候的系统库已经发生更改。这样就能保证<code>lauch closure</code>总是在APP打开之前准备好。启动闭包会被写到到一个文件里，下次启动则直接读取和验证这个文件。</li>
<li>在 iOS，tvOS，watchOS 中，一切（生成启动闭包）都是在 app 启动之前做完的。在 macOS 上，由于有 sideload app，进程内引擎会在首次启动时启动一个 daemon，之后就可以使用启动闭包了。总之大部分情景下，这些工作都在 app 启动之前完成了。</li>
</ul>
<p>总体来说，dyld 3把pre-main()阶段很多耗时的操作都提前处理好了，极大提升了启动速度。</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">opensource</a></p>
<p><a href="https://leylfl.github.io/2018/05/28/dyld启动流程/" target="_blank" rel="noopener">dyld启动流程</a></p>
<p><a href="http://www.zoomfeng.com/blog/launch-optimize-from-wwdc2019.html" target="_blank" rel="noopener">WWDC2019之启动时间与Dyld3</a></p>
<p><a href="https://developer.apple.com/videos/play/wwdc2017/413/" target="_blank" rel="noopener">App Startup Time: Past, Present, and Future</a></p>
<p><a href="https://www.dllhook.com/post/238.html" target="_blank" rel="noopener">dyld详解</a></p>
<p><a href="https://www.jianshu.com/p/be413358cd45" target="_blank" rel="noopener">dyld简介及加载过程分析</a></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmzcool.top/2020/04/06/dyld/">http://lmzcool.top/2020/04/06/dyld/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmzcool.top" target="_blank">GN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/assets_img/asset1.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/06/machoFormat/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/macho_image/machoformat2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Mac OS X ABI Mach-O File Format Reference</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/06/fishHook/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Fishhook使用和源码解析</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'v26lyi3lmFjLAjSuqbPuAQWf-gzGzoHsz',
  appKey: 'kXNYMLXOoEDtuSEqWE7SadDa',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By GN</div><div class="icp"><a><span>京ICP备19014027号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>