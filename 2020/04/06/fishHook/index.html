<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Fishhook使用和源码解析 | GN</title><meta name="description" content="Fishhook使用和源码解析"><meta name="author" content="GN"><meta name="copyright" content="GN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Fishhook使用和源码解析"><meta name="twitter:description" content="Fishhook使用和源码解析"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png"><meta property="og:type" content="article"><meta property="og:title" content="Fishhook使用和源码解析"><meta property="og:url" content="http://lmzcool.top/2020/04/06/fishHook/"><meta property="og:site_name" content="GN"><meta property="og:description" content="Fishhook使用和源码解析"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://lmzcool.top/2020/04/06/fishHook/"><link rel="prev" title="Dyld" href="http://lmzcool.top/2020/04/06/dyld/"><link rel="next" title="iOS 10 Notification Extension" href="http://lmzcool.top/2020/04/06/iOS10Notification/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用"><span class="toc-number">2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#原理"><span class="toc-number">3.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#编译链接简单介绍"><span class="toc-number">3.1.</span> <span class="toc-text">编译链接简单介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#地址无关代码"><span class="toc-number">3.2.</span> <span class="toc-text">地址无关代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#懒加载符号和非懒加载符号"><span class="toc-number">3.3.</span> <span class="toc-text">懒加载符号和非懒加载符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fishhook的绑定验证"><span class="toc-number">3.4.</span> <span class="toc-text">fishhook的绑定验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fishhook查找流程"><span class="toc-number">3.5.</span> <span class="toc-text">fishhook查找流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#源码"><span class="toc-number">4.</span> <span class="toc-text">源码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">GN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Fishhook使用和源码解析</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-06 19:36:28"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-06 19:36:28"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/06/fishHook/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">fishhook</a> 是Facebook开源的用来动态修改C语言函数实现的库。</p>
<p>iOS中<code>Method swizzing</code>通过交换IMP可以hook OC的方法，但是对于C的函数是没有办法的，而fishhook通过交换函数实现 可以hook系统的静态C函数。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>先来看一下使用方法和达到的效果，随后再慢慢解析。我们这里就拿printf为例进行hook，下面来看一下代码，非常简单就可以实现效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*old_printf)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newPrintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *arg1, ...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> old_printf(<span class="string">"新的print: %s \n"</span>, arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">printBind</span>;</span></span><br><span class="line">    <span class="comment">// name</span></span><br><span class="line">    printBind.name = <span class="string">"printf"</span>;</span><br><span class="line">    <span class="comment">// 新实现的函数地址</span></span><br><span class="line">    printBind.replacement = newPrintf;</span><br><span class="line">    <span class="comment">// 用于保存原始函数地址变量的指针</span></span><br><span class="line">    printBind.replaced = (<span class="keyword">void</span> *)&amp;old_printf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构体数组，可以同时传入多个要hook的结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> <span class="title">binds</span>[] = &#123;</span>printBind&#125;;</span><br><span class="line">    rebind_symbols(binds, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"测试printf"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新的print: 测试printf </span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure>

<p>可以看到已经实现了hook printf的目的。从代码来看，调用printf的时候，应该是调用了我们的newPrintf函数，在我们的函数内部做一些事情之后再调用会到原本的函数实现，本质来说就是函数指针的交换。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="编译链接简单介绍"><a href="#编译链接简单介绍" class="headerlink" title="编译链接简单介绍"></a>编译链接简单介绍</h2><ul>
<li><p>编译（Compile）</p>
<p>编译的时候会把每一个.m文件经过预处理、词法分析、语法分析、语义分析等一系列步骤最终编译成为一个.o文件，这个.o文件称为<code>目标文件</code>。编译结束后会生成一个一个的.o文件</p>
</li>
<li><p>静态链接（Link）</p>
<p>在我们实际开发中，不可能将所有代码都放在一个文件内，所以就会有多个.m文件，这些.m文件之间肯定有所依赖，比如引用了函数或者变量等。但是每一个.m文件都是单独编译成为.o文件的，为了维持这种依赖关系，则需要将这些目标文件进行链接并且进行符号解析重定位等，从而形成一个可执行程序。这就是静态链接</p>
</li>
<li><p>动态链接</p>
<p>动态链接是把程序拆分成不同的模块，等到程序启动的时候再进行链接，而不是像静态链接一样在编译时候就把所有的模块都链接在一起成功一个可执行文件。</p>
<p>苹果所有的系统框架都是动态库，放在一个共享缓存内，供所有的程序使用</p>
<p>动态链接的好处就是节省了空间，而且更新方便。坏处就是由于链接放在启动时候，所以就会造成一些性能损耗。</p>
</li>
</ul>
<h2 id="地址无关代码"><a href="#地址无关代码" class="headerlink" title="地址无关代码"></a>地址无关代码</h2><p>地址无关代码，也叫PIC（Position-indendent Code），使用PIC的Mach-O文件，在引用符号（比如printf）的时候，并不是直接去找到符号的地址（编译期并不知道运行时printf的函数地址），而是通过在<code>__DATA</code> Segment上创建一个指针，等到启动的时候，dyld动态的去做绑定（bind），这样__DATA Segment上的指针就指向了printf的实现。fishhook利用PIC技术，针对<code>DATA</code> 段上的符号绑定的指针进行替换</p>
<h2 id="懒加载符号和非懒加载符号"><a href="#懒加载符号和非懒加载符号" class="headerlink" title="懒加载符号和非懒加载符号"></a>懒加载符号和非懒加载符号</h2><p>操作系统为了加快启动速度，将符号分成了懒加载符号和非懒加载符号。将一些符号的绑定重定位等放到第一次加载的时候。</p>
<ul>
<li>非懒加载符号在动态库链接的时候就会绑定真实的值</li>
<li>懒加载符号会在程序中第一次用到的时候再进行绑定</li>
</ul>
<p>fishhook在懒加载符号第一次使用时进行绑定这个机制来进行指针替换，达到hook的效果。也是正因为这样，所有fishhook无法hook程序内自定义的c函数，因为自己的c函数在启动的时候已绑定完地址。</p>
<p>下面就以printf为例，printf就是一个懒加载符号，只有在用到的时候才会绑定。我们分别来看一下第一次调用和第二次调用有什么不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"测试printf 第一次"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"测试printf 第二次"</span>);</span><br></pre></td></tr></table></figure>

<p>调用两次，都打上断点。转到反汇编</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_2.png"  alt="printf"></p>
<p>这是第一次调用，call 0x100001e70，我们接着来看0x100001e70这个地址是什么</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_3.png"  alt="printf"></p>
<p>继续跳转到0x100001f0e，再来看这个地址</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_4.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_5.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_6.png"  alt="printf"></p>
<p>最终我们看到调用了<code>dyld_stub_binder</code> 这个函数，动态绑定符号是由这个函数实现的。具体实现可以在<a href="https://opensource.apple.com/tarballs/dyld/" target="_blank" rel="noopener">dyld</a> 中找到。</p>
<p>接下来我们过掉第一次调用的断点，来到第二个断点</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_7.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_8.png"  alt="printf">)<img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_9.png"  alt="printf"></p>
<p>可以看到这一次直接就是找到printf的函数实现地址</p>
<h2 id="fishhook的绑定验证"><a href="#fishhook的绑定验证" class="headerlink" title="fishhook的绑定验证"></a>fishhook的绑定验证</h2><p>看完上面一堆乱七八糟的之后，我们接下来看一下经过hook之后，函数的地址是怎么样变化的</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_10.png"  alt="printf"></p>
<p>先观察第一次触发断点的时候，printf的实现函数</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_11.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_12.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_13.png"  alt="printf"></p>
<p>可以看到这是正常实现，最后调用了system的printf函数。</p>
<p>接下来看实现hook之后，第三次调用的情况</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_14.png"  alt="printf"></p>
<p>调用0x100001e58</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_15.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_16.png"  alt="printf"></p>
<p>这下就发现不一样了，刚才我们调用的是system的printf函数，而现在我们看到直接调用了我们新写的newPrintf函数。这就说明了fishhook的内部实际是对函数实现的替换。</p>
<p>但是fishhook是怎样就根据一个传入的printf字符串就能找到具体的函数实现并替换呢？接下来就来看一看查找的流程。</p>
<h2 id="fishhook查找流程"><a href="#fishhook查找流程" class="headerlink" title="fishhook查找流程"></a>fishhook查找流程</h2><p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_1.png"  alt="printf"></p>
<p>这是官方给的查找流程图。根据在 __ DATA， __la_symbol_ptr 中的偏移，找到在Indirect Symbol Table中的位置，Indirect Symbol Table中的偏移值是在Symbol Table中的偏移，然后取出在Symbol Table中的偏移值，这个偏移值是在String Table中的偏移，在String Table中找到对应的符号。如果匹配证明查找正确。</p>
<p> 整个流程大致是这个样子，下面我们以懒加载符号NSLog为例，来探究一下具体的查找流程</p>
<ol>
<li><p>首先来看<code>Load Commands</code> -&gt; <code>LC_SEGMENT_64(__DATA)</code> -&gt; <code>Section64 Header(__la_symbol_ptr)</code>  </p>
<ul>
<li><p><code>Address</code> 的值指的是懒加载符号对应实现的虚拟内存地址，通过100002018找到了<code>Section64(__DATA,__la_symbol_ptr)</code> ，这一段代表的就是符号的具体实现，这里的顺序跟在符号表内的顺序是一致的</p>
</li>
<li><p><code>Indirect Sym Index</code> 的值18代表的是在<code>Dynamic Symbol Table</code>中的索引，从符号表中偏移18，就可以找到NSLog，按照顺序就可以找到其他对应的符号</p>
</li>
<li><p><code>Symbol Table</code>、<code>String Table</code> 和 <code>Dynamic Symbol Table</code>  的地址可以通过<code>Load Commands</code> -&gt; <code>LC_SYMTAB</code> / <code>LC_DYSYMTAB</code> 找到对应的起始地址</p>
</li>
</ul>
</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_17.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_18.png"  alt="printf"></p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_19.png"  alt="printf"></p>
<ol start="2">
<li>根据索引18在<code>Dynamic Symbol Table</code> 中找到了_NSLog， 第二列的值00000052就是在<code>Symbol Table</code>中的索引，这个52是十六进制，我们转成十进制就是82</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_20.png"  alt="printf"></p>
<ol start="3">
<li>在<code>Symbol Table</code>中找到82的位置，我们看到也是__NSLog，这说明目前我们的查找是没问题的。拿到第二列的值55，这个值就是在<code>String Table</code>中的偏移</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_21.png"  alt="printf"></p>
<ol start="4">
<li>找到<code>String Table</code>的起始地址38B4，加上我们刚刚得到的偏移55，通过计算器相加=0x3909，然后找到具体的位置，可以看到就是<code>_NSLog</code>，前后的.是分隔符</li>
</ol>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/fishhook_image/fishhook_23.png"  alt="printf"></p>
<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A structure representing a particular intended rebinding from a symbol</span></span><br><span class="line"><span class="comment"> * name to its replacement</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">void</span> *replacement;</span><br><span class="line">  <span class="keyword">void</span> **replaced;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For each rebinding in rebindings, rebinds references to external, indirect</span></span><br><span class="line"><span class="comment"> * symbols with the specified name to instead point at replacement for each</span></span><br><span class="line"><span class="comment"> * image in the calling process as well as for all future images that are loaded</span></span><br><span class="line"><span class="comment"> * by the process. If rebind_functions is called more than once, the symbols to</span></span><br><span class="line"><span class="comment"> * rebind are added to the existing list of rebindings, and if a given symbol</span></span><br><span class="line"><span class="comment"> * is rebound more than once, the later rebinding will take precedence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">FISHHOOK_VISIBILITY</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fishhook主要函数就是rebind_symbols()，传入两个参数，第一个参数为rebinding结构体数组，第二个参数为结构体数组个数。</p>
<p>看一下rebinding结构体</p>
<ul>
<li><p><code>char *name</code> 需要hook的函数名称。若需hook printf()函数，则为”printf”</p>
</li>
<li><p><code>void *replacement</code> 新实现的函数地址</p>
</li>
<li><p><code>void **replaced</code> <em>replaced是一个函数指针 *</em>replaced是指向函数指针的指针，为了取出函数的地址，可以在被调函数内修改</p>
</li>
</ul>
<p>接下来看一下rebind_symbols()函数的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols</span><span class="params">(struct rebinding rebindings[], <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> retval = prepend_rebindings(&amp;_rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">  <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If this was the first call, register callback for image additions (which is also invoked for</span></span><br><span class="line">  <span class="comment">// existing images, otherwise, just run on existing images</span></span><br><span class="line">  <span class="keyword">if</span> (!_rebindings_head-&gt;next) &#123;</span><br><span class="line">    _dyld_register_func_for_add_image(_rebind_symbols_for_image);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> c = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">      _rebind_symbols_for_image(_dyld_get_image_header(i), _dyld_get_image_vmaddr_slide(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用 <code>prepend_rebindings()</code>  函数做一些初始化准备工作，传入三个参数，第一个参数<code>_rebindings_head</code>是一个指向<code>rebindings_entry</code>结构体的指针，从结构体定义可以看出这是一个单向链表的结构。<code>rebindings</code>是一个指向<code>rebinding</code>结构体的指针，<code>next</code>指向下一个节点。会把外部传入的<code>rebindings</code>全部插入到此链表中串起来。第二三个参数则是rebindings结构体数组，<code>prepend_rebindings</code>函数内部会把第二三个参数插入到第一个参数内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *_<span class="title">rebindings_head</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prepend_rebindings</span><span class="params">(struct rebindings_entry **rebindings_head,</span></span></span><br><span class="line"><span class="function"><span class="params">                              struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">size_t</span> nel)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 开辟 rebindings_entry 堆空间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">new_entry</span> = (<span class="title">struct</span> <span class="title">rebindings_entry</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rebindings_entry</span>));</span></span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开辟 new_entry-&gt;rebindings 堆空间</span></span><br><span class="line">  <span class="comment">// 如果失败，释放空间 返回</span></span><br><span class="line">  new_entry-&gt;rebindings = (struct rebinding *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    <span class="built_in">free</span>(new_entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拷贝外部rebinding结构体内容 -&gt; 内部结构体 rebindings_entry-&gt;rebindings</span></span><br><span class="line">  <span class="comment">// 添加 new_entry 到 _rebindings_head 这个链表结构的头部 成为新的头节点</span></span><br><span class="line">  <span class="built_in">memcpy</span>(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(struct rebinding) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>准备工作没问题之后，接下来执行一个判断，<code>!_rebindings_head-&gt;next</code> 若链表内无内容，说明第一次执行，则调用<code>_dyld_register_func_for_add_image</code>方法，当调用<code>_dyld_register_func_for_add_image</code>注册监听方法后，当前已经装载的image等会立刻触发回调，之后的image会在装载的时候触发回调，调用通知内的<code>_rebind_symbols_for_image</code>方法</p>
<p>若next有值，则进行加载动态库的遍历，也调用<code>_rebind_symbols_for_image</code> 方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _rebind_symbols_for_image(<span class="keyword">const</span> struct mach_header *header,</span><br><span class="line">                                      <span class="keyword">intptr_t</span> slide) &#123;</span><br><span class="line">    rebind_symbols_for_image(_rebindings_head, header, slide);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_rebind_symbols_for_image</code>实际调用的是<code>rebind_symbols_for_image</code> ，<code>rebind_symbols_for_image</code> 是核心方法，主要是解析mach-o，查找<code>S_LAZY_SYMBOL_POINTERS</code> <code>S_NON_LAZY_SYMBOL_POINTERS</code> 位置，找到之后调用<code>perform_rebinding_with_section</code> 方法真正的实现函数替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rebind_symbols_for_image</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> struct mach_header *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">intptr_t</span> slide)</span> </span>&#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">segment_command_t</span> *cur_seg_cmd;</span><br><span class="line">  <span class="keyword">segment_command_t</span> *linkedit_segment = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span>* <span class="title">symtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span>* <span class="title">dysymtab_cmd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">uintptr_t</span> cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>) &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123;</span><br><span class="line">      symtab_cmd = (struct symtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123;</span><br><span class="line">      dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> linkedit_base = (<span class="keyword">uintptr_t</span>)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  <span class="keyword">nlist_t</span> *symtab = (<span class="keyword">nlist_t</span> *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="keyword">char</span> *strtab = (<span class="keyword">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symtab = (<span class="keyword">uint32_t</span> *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (<span class="keyword">uintptr_t</span>)header + <span class="keyword">sizeof</span>(<span class="keyword">mach_header_t</span>);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123;</span><br><span class="line">    cur_seg_cmd = (<span class="keyword">segment_command_t</span> *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">strcmp</span>(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        <span class="keyword">section_t</span> *sect =</span><br><span class="line">          (<span class="keyword">section_t</span> *)(cur + <span class="keyword">sizeof</span>(<span class="keyword">segment_command_t</span>)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>perform_rebinding_with_section</code>的内部真正实现替换，会拿结构体内需hook的符号名进行对比，如果符号名称一致，而且没有被替换过，则会拿我们自己的函数指针保存原来的实现，然后把指针指向我们自定义的实现。这样就实现了替换，既完成了函数替换，也保存了原有实现，待在自定义函数内完成了工作后，可以调用原来的实现恢复正常工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line">  <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;<span class="built_in">size</span> / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">    <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">        symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS)) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">    <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">    <span class="keyword">bool</span> symbol_name_longer_than_1 = symbol_name[<span class="number">0</span>] &amp;&amp; symbol_name[<span class="number">1</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">    <span class="comment">// 遍历所有结构体内需要替换的函数，进行替换</span></span><br><span class="line">    <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++) &#123;</span><br><span class="line">        <span class="comment">// 比较符号名称和外部传入需hook的符号名，如果一致则进行下一步替换</span></span><br><span class="line">        <span class="keyword">if</span> (symbol_name_longer_than_1 &amp;&amp;</span><br><span class="line">            <span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">              indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123;</span><br><span class="line">            <span class="comment">// 取出函数指针的指向的地址，存入函数原有的方法实现</span></span><br><span class="line">            *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 把原有的函数实现替换为自定义的replacement</span></span><br><span class="line">          indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">          <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  symbol_loop:;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><p><a href="https://github.com/facebook/fishhook" target="_blank" rel="noopener">https://github.com/facebook/fishhook</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c7b43976fb9a04a05406312" target="_blank" rel="noopener">fishhook的实现原理浅析</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c810294f265da2db91297f1" target="_blank" rel="noopener">fishhook使用场景&amp;源码分析</a></p>
</li>
<li><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/78444203" target="_blank" rel="noopener">Fishhook替换C函数的原理</a></p>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmzcool.top/2020/04/06/fishHook/">http://lmzcool.top/2020/04/06/fishHook/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmzcool.top" target="_blank">GN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/06/dyld/"><img class="prev_cover lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Dyld</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/06/iOS10Notification/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">iOS 10 Notification Extension</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'f41b211b8f76bcb4c631',
  clientSecret: '18d237316009bcbd6c13816a73a595f20e63e0f9',
  repo: 'https://github.com/gaonian/gaonian.github.io',
  owner: 'gaonian',
  admin: ['gaonian'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By GN</div><div class="icp"><a><span>京ICP备19014027号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>