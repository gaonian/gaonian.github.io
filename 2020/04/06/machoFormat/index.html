<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Mac OS X ABI Mach-O File Format Reference | GN</title><meta name="description" content="Mac OS X ABI Mach-O File Format Reference"><meta name="author" content="GN"><meta name="copyright" content="GN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Mac OS X ABI Mach-O File Format Reference"><meta name="twitter:description" content="Mac OS X ABI Mach-O File Format Reference"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-7.png"><meta property="og:type" content="article"><meta property="og:title" content="Mac OS X ABI Mach-O File Format Reference"><meta property="og:url" content="http://lmzcool.top/2020/04/06/machoFormat/"><meta property="og:site_name" content="GN"><meta property="og:description" content="Mac OS X ABI Mach-O File Format Reference"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-7.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://lmzcool.top/2020/04/06/machoFormat/"><link rel="prev" title="objc_msgsend" href="http://lmzcool.top/2020/04/06/objc_msgsend/"><link rel="next" title="Dyld" href="http://lmzcool.top/2020/04/06/dyld/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Basic-Structure"><span class="toc-number">1.1.</span> <span class="toc-text">Basic Structure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Header-Structure-and-Load-Commands"><span class="toc-number">1.2.</span> <span class="toc-text">Header Structure and Load Commands</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Segments"><span class="toc-number">1.3.</span> <span class="toc-text">Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sections"><span class="toc-number">1.4.</span> <span class="toc-text">Sections</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Data-Types"><span class="toc-number">2.</span> <span class="toc-text">Data Types</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Header-Data-Structure"><span class="toc-number">2.1.</span> <span class="toc-text">Header Data Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mach-header"><span class="toc-number">2.1.1.</span> <span class="toc-text">mach_header</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Load-Command-Data-Structures"><span class="toc-number">2.2.</span> <span class="toc-text">Load Command Data Structures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#load-command"><span class="toc-number">2.2.1.</span> <span class="toc-text">load_command</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-Table-and-Related-Data-Structures"><span class="toc-number">2.3.</span> <span class="toc-text">Symbol Table and Related Data Structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Relocation-Data-Structures"><span class="toc-number">2.4.</span> <span class="toc-text">Relocation Data Structures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Static-Archive-Libraries"><span class="toc-number">2.5.</span> <span class="toc-text">Static Archive Libraries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Universal-Binaries-32-bit-64-bit-PowerPC-Binaries"><span class="toc-number">2.6.</span> <span class="toc-text">Universal Binaries 32-bit&#x2F;64-bit PowerPC Binaries</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-7.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">GN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Mac OS X ABI Mach-O File Format Reference</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-06 19:44:02"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-06 19:44:02"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-06</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/06/machoFormat/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>This document describes the structure of the Mach-O (Mach object) file format, which is the standard<br>used to store programs and libraries on disk in the Mac OS X application binary interface (ABI). To<br>understand how the Xcode tools work with Mach-O files, and to perform low-level debugging tasks,<br>you need to understand this information.</p>
<p>本文档描述了Mach- o (Mach object)文件格式的结构，这是Mac OS X应用程序二进制接口(ABI)中用于在磁盘上存储程序和库的标准格式。要理解Xcode工具如何处理Mach-O文件，并执行 low-level 调试任务，您需要理解这些信息。</p>
<p>The Mach-O file format provides both intermediate (during the build process) and final (after linking<br>the final product) storage of machine code and data. It was designed as a flexible replacement for the<br>BSD a.out format, to be used by the compiler and the static linker and to contain statically linked<br>executable code at runtime. Features for dynamic linking were added as the goals of Mac OS X evolved,<br>resulting in a single file format for both statically linked and dynamically linked code.</p>
<p>Mach-O文件格式提供了机器代码和数据的中间(在构建过程中)和最终(在链接最终产品之后)存储。它被设计为一个灵活的替代BSD <code>a.out</code>输出格式，由编译器和静态链接器使用，并在运行时包含静态链接的可执行代码。随着Mac OS X目标的发展，动态链接的特性也被添加进来，从而为静态链接和动态链接代码提供了一种单一的文件格式。</p>
<h2 id="Basic-Structure"><a href="#Basic-Structure" class="headerlink" title="Basic Structure"></a>Basic Structure</h2><p>A Mach-O file contains three major regions (as shown in Figure 1):</p>
<p>一个Mach-O文件包含三个主要区域(如图1所示):</p>
<ul>
<li><p>At the beginning of every Mach-O file is a <strong>header structure</strong> that identifies the file as a Mach-O file. The header also contains other basic file type information, indicates the target architecture, and contains flags specifying options that affect the interpretation of the rest of the file. </p>
<p>在每个Mach-O文件的开头都有一个头结构，它将文件标识为一个Mach-O文件。头文件还包含其他基本文件类型信息，指示目标体系结构，并包含指定影响文件其余部分解释的选项的标志。</p>
</li>
<li><p>Directly following the header are a series of variable-size <strong>load commands</strong> that specify the layout and linkage characteristics of the file. Among other information, the load commands can specify: </p>
<p>头文件后面是一系列大小可变的<strong>load commands</strong>，它们指定文件的布局和链接特性。在其他信息中，load commands可以指定:</p>
<ul>
<li><p>The initial layout of the file in virtual memory </p>
<p>文件在虚拟内存中的初始布局</p>
</li>
<li><p>The location of the symbol table (used for dynamic linking) </p>
<p>符号表的位置(用于动态链接)</p>
</li>
<li><p>The initial execution state of the main thread of the program</p>
<p>程序主线程的初始执行状态</p>
</li>
<li><p>The names of shared libraries that contain definitions for the main executable’s imported<br>symbols</p>
<p>包含主可执行文件导入符号定义的共享库的名称</p>
</li>
</ul>
</li>
<li><p>Following the load commands, all Mach-O files contain the data of one or more segments. Each <strong>segment</strong> contains zero or more sections. Each <strong>section</strong> of a segment contains code or data of some particular type. Each segment defines a region of virtual memory that the dynamic linker maps into the address space of the process. The exact number and layout of segments and sections is specified by the load commands and the file type. </p>
<p>按照load commands, Mach-O文件都包含一个或多个<strong>segment</strong>的数据。每个段包含零个或多个<strong>sections</strong>。段的每个<strong>section</strong>都包含某种特定类型的代码或数据。每个<strong>segment</strong>定义一个虚拟内存区域，动态链接器将该区域映射到进程的地址空间。<strong>segment</strong>和<strong>sections</strong>的确切数量和布局由<code>load commands</code>和文件类型指定。</p>
</li>
<li><p>In user-level fully linked Mach-O files, the last segment is the <strong>link edit</strong> segment. This segment contains the tables of link edit information, such as the symbol table, string table, and so forth, used by the dynamic loader to link an executable file or Mach-O bundle to its dependent libraries. </p>
<p>在用户级完全链接的Mach-O文件中，最后一个段是链接编辑段。此段包含链接编辑信息的表，如符号表、字符串表等，动态加载程序使用这些表将可执行文件或Mach-O包链接到其依赖库。</p>
</li>
</ul>
<p>  <strong>Figure 1</strong> Mach-O file format basic structure </p>
<p>  <img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/macho_image/machoformat2.png"  alt="mach-o"></p>
<p>Various tables within a Mach-O file refer to sections by number. Section numbering begins at 1 (not<br>0) and continues across segment boundaries. Thus, the first segment in a file may contain sections 1<br>and 2 and the second segment may contain sections 3 and 4.</p>
<p>Mach-O文件中的各种表都是按编号引用节的。节编号从1(不是0)开始，并跨越段边界。因此，文件中的第一个段可以包含第1节和第2节，第二个段可以包含第3节和第4节。</p>
<p>When using the Stabs debugging format, the symbol table also holds debugging information. When<br>using DWARF, debugging information is stored in the image’s corresponding dSYM file, specified<br>by the uuid_command (page 20) structure</p>
<p>当使用Stabs调试格式时，符号表还包含调试信息。使用DWARF时，调试信息存储在image对应的dSYM文件中，该文件由uuid_command 结构指定</p>
<h2 id="Header-Structure-and-Load-Commands"><a href="#Header-Structure-and-Load-Commands" class="headerlink" title="Header Structure and Load Commands"></a>Header Structure and Load Commands</h2><p>A Mach-O file contains code and data for one architecture. The header structure of a Mach-O file<br>specifies the target architecture, which allows the kernel to ensure that, for example, code intended<br>for PowerPC-based Macintosh computers is not executed on Intel-based Macintosh computers.</p>
<p>一个Mach-O文件包含一个架构的代码和数据。Mach-O文件的头结构指定了目标体系结构，这允许内核确保，例如，针对基于powerpc的Macintosh计算机的代码不会在基于intel的Macintosh计算机上执行。</p>
<p>You can group multiple Mach-O files (one for each architecture you want to support) in one binary<br>using the format described in “Universal Binaries and 32-bit/64-bit PowerPC Binaries” (page 55).</p>
<p>您可以使用“Universal Binaries and 32-bit/64-bit PowerPC Binaries”中描述的格式将多个Mach-O文件(每个体系结构一个)分组到一个二进制文件中。</p>
<blockquote>
<p><strong>Note:</strong> Binaries that contain object files for more than one architecture are not Mach-O files. They<br>archive one or more Mach-O files.</p>
<p>注意:包含多个体系结构的目标文件的二进制文件不是Mach-O文件。他们存档一个或多个Mach-O文件。</p>
</blockquote>
<p>Segments and sections are normally accessed by name. Segments, by convention, are named using<br>all uppercase letters preceded by two underscores (for example, _TEXT); sections should be named<br>using all lowercase letters preceded by two underscores (for example, __text). This naming convention is standard, although not required for the tools to operate correctly.</p>
<p><code>Segments</code>和<code>sections</code>通常按名称访问。按照惯例，<code>Segments</code>的命名使用所有大写字母加上两个下划线(例如，__ TEXT);  <code>sections</code>的命名应该使用所有小写字母加上两个下划线(例如，__ text)。这只是一个规范的命名约定，不强制要求必须这样做</p>
<h2 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h2><p>A segment defines a range of bytes in a Mach-O file and the addresses and memory protection<br>attributes at which those bytes are mapped into virtual memory when the dynamic linker loads the<br>application. As such, segments are always virtual memory page aligned. A segment contains zero or<br>more sections.</p>
<p><code>segment</code>在Mach-O文件中定义一个字节范围，以及地址和内存保护属性，当动态链接器加载应用程序时，这些字节被映射到虚拟内存中。因此，<code>segments</code>始终是虚拟内存页面对齐的。一个<code>segment</code>包含零个或多个<code>sections</code>。</p>
<p>Segments that require more memory at runtime than they do at build time can specify a larger<br>in-memory size than they actually have on disk. For example, the __PAGEZERO segment generated by<br>the linker for PowerPC executable files has a virtual memory size of one page but an on-disk size of 0.</p>
<p>Because __PAGEZERO contains no data, there is no need for it to occupy any space in the executable<br>file.</p>
<p>运行时比构建时需要更多内存的段可以指定比它们在磁盘上实际拥有的更大的内存大小。例如，链接器为PowerPC可执行文件生成的__ PAGEZERO段的虚拟内存大小为一页，而磁盘大小为0。由于__ PAGEZERO不包含数据，因此不需要占用可执行文件中的任何空间。</p>
<blockquote>
<p><strong>Note:</strong> Sections that are to be filled with zeros must always be placed at the end of the segment.<br>Otherwise, the standard tools will not be able to successfully manipulate the Mach-O file.</p>
<p>注意:要用零填充的部分必须始终放在段的末尾。否则，标准工具将无法成功地操作Mach-O文件。</p>
</blockquote>
<p>For compactness, an intermediate object file contains only one segment. This segment has no name;<br>it contains all the sections destined ultimately for different segments in the final object file. The data<br>structure that defines a section (page 23) contains the name of the segment the section is intended<br>for, and the static linker places each section in the final object file accordingly.</p>
<p>为了紧凑性，中间对象文件只包含一个<code>segment</code>。这个<code>segment</code>没有名字;它包含为最终目标文件中的不同<code>segment</code>指定的所有<code>sections</code>。定义<code>section</code>的数据结构(第23页)包含节的目标段的名称，静态链接器将每个节相应地放在最终目标文件中。</p>
<p>For best performance, segments should be aligned on virtual memory page boundaries—4096 bytes<br>for PowerPC and x86 processors. To calculate the size of a segment, add up the size of each section,<br>then round up the sum to the next virtual memory page boundary (4096 bytes, or 4 kilobytes). Using<br>this algorithm, the minimum size of a segment is 4 kilobytes, and thereafter it is sized at 4 kilobyte<br>increments.</p>
<p>为了获得最佳性能，段应该对齐到虚拟内存页边界上—PowerPC和x86处理器的4096字节。要计算段的大小，请将每个段的大小相加，然后将总和四舍五入到下一个虚拟内存页边界(4096字节，或4 kb)。使用这种算法，一个段的最小大小是4 kb，然后以4 kb的增量进行调整。</p>
<p>The header and load commands are considered part of the first segment of the file for paging purposes.<br>In an executable file, this generally means that the headers and load commands live at the start of the __ TEXT segment because that is the first segment that contains data. The __PAGEZERO segment contains no data on disk, so it’s ignored for this purpose.</p>
<p>出于分页的目的，<code>header</code>和<code>load commands</code>被认为是文件第一<code>segment</code>的一部分。在一个可执行文件中，这通常意味着<code>headers</code>和<code>load commands</code>位于<code>__ TEXT</code> <code>segment</code>的开头，因为这是包含数据的第一个<code>segment</code>。由于<code>__PAGEZERO</code> <code>segment</code>没有包含任何数据，因此忽略了它。</p>
<p>These are the segments the standard Mac OS X development tools (contained in the Xcode Tools CD)<br>may include in a Mac OS X executable:</p>
<p>以下是标准Mac OS X开发工具(包含在Xcode tools CD中)可能包含在Mac OS X可执行文件中的部分:</p>
<ul>
<li><p>The static linker creates a __ PAGEZERO segment as the first segment of an executable file. This<br>segment is located at virtual memory location 0 and has no protection rights assigned, the<br>combination of which causes accesses to NULL, a common C programming error, to immediately<br>crash. The __ PAGEZERO segment is the size of one full VM page for the current architecture (for<br>Intel-based and PowerPC-based Macintosh computers, this is 4096 bytes or 0x1000 in hexadecimal).<br>Because there is no data in the __PAGEZERO segment, it occupies no space in the file (the file size<br>in the segment command is 0).</p>
<p>静态链接器创建一个__PAGEZERO <code>segment</code> 作为可执行文件的第一个<code>segment</code>。这个<code>segment</code>位于虚拟内存位置0，没有分配任何保护权限，两者的组合会导致对NULL的访问立即崩溃，这是一个常见的C编程错误。对于当前的体系结构(对于基于intel和基于powerpc的Macintosh计算机，这是4096字节，或者十六进制是0x1000)， _ PAGEZERO<code>segment</code>的大小相当于一个完整的VM页面。因为在PAGEZERO段中没有数据，所以它在文件中不占空间(segment命令中的文件大小为0)。</p>
</li>
<li><p>The __ TEXT segment contains executable code and other read-only data. To allow the kernel to map it directly from the executable into sharable memory, the static linker sets this segment’s virtual memory permissions to disallow writing. When the segment is mapped into memory, it can be shared among all processes interested in its contents. (This is primarily used with frameworks, bundles, and shared libraries, but it is possible to run multiple copies of the same executable in Mac OS X, and this applies in that case as well.) The read-only attribute also means that the pages that make up the __ TEXT segment never need to be written back to disk. When the kernel needs to free up physical memory, it can simply discard one or more __TEXT pages and re-read them from disk when they are next needed. </p>
<p>TEXT <code>segment</code>包含可执行代码和其他只读数据。为了允许内核将它直接从可执行文件映射到可共享内存，静态链接器将这个段的虚拟内存权限设置为不允许写入。当段被映射到内存中时，它可以在对其内容感兴趣的所有进程之间共享。(这主要用于框架、捆绑包和共享库，但也可以在Mac OS X中运行同一可执行文件的多个副本，在这种情况下也是适用的。)只读属性还意味着组成TEXT段的页面永远不需要写回磁盘。当内核需要释放物理内存时，它可以简单地丢弃一个或多个TEXT页面，然后在下次需要时从磁盘重新读取它们。</p>
</li>
<li><p>The __ DATA segment contains writable data. The static linker sets the virtual memory permissions of this segment to allow both reading and writing. Because it is writable, the __ DATA segment of a framework or other shared library is logically copied for each process linking with the library. When memory pages such as those making up the __DATA segment are readable and writable, the kernel marks them copy-on-write; therefore when a process writes to one of these pages, that process receives its own private copy of the page. </p>
<p>DATA段包含可写数据。静态链接器设置此段的虚拟内存权限为允许读写。因为它是可写的，所以framework或其他共享库的DATA segment在逻辑上被复制到与库链接的每个进程。当组成DATA段的内存页可读可写时，内核将它们标记为copy-on-write; 因此，当一个进程写到其中一个页面时，该进程将收到该页面的私有副本。</p>
</li>
<li><p>The __OBJC segment contains data used by the Objective-C language runtime support library. </p>
<p>__OBJC段包含OC运行时支持库使用的数据。</p>
</li>
<li><p>The __IMPORT segment contains symbol stubs and non-lazy pointers to symbols not defined in </p>
<p>the executable. This segment is generated only for executables targeted for the IA-32 architecture. </p>
<p>__IMPORT段含符号存根和指向可执行文件中未定义的符号的非懒加载指针。此段只在IA-32架构下的可执行文件中生成</p>
</li>
<li><p>The __LINKEDIT segment contains raw data used by the dynamic linker, such as symbol, string, and relocation table entries. </p>
<p>__LINKEDIT段包含动态链接器使用的原始数据，例如符号、字符串和重定位表条目。</p>
</li>
</ul>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p>The __ TEXT and __ DATA segments may contain a number of standard sections, listed in Table 1, Table 2 (page 11), and Table 3 (page 11). The __OBJC segment contains a number of sections that are private to the Objective-C compiler. Note that the static linker and file analysis tools use the section type and attributes (instead of the section name) to determine how they should treat the section. The section name, type and attributes are explained further in the description of the section (page 23) data type. </p>
<p>TEXT和DATA <code>segments</code>可以包含许多标准<code>sections</code>，如表1、表2和表3中列出。__OBJC段包含许多对Objective-C编译器私有的部分。注意，静态链接器和文件分析工具使用<code>section</code>类型和属性(而不是section name)来确定它们应该如何处理这个<code>section</code>。<code>section</code>名称、类型和属性将在section数据类型描述中进一步解释。</p>
<p><strong>Table 1</strong> The sections of a __TEXT segment </p>
<table>
<thead>
<tr>
<th>Segment and section name</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td>__ TEXT, __text</td>
<td>Executable machine code. The compiler generally places only executable<br/>code in this section, no tables or data of any sort.<br>可执行的机器代码。编译器通常只将可执行代码放在这一节中，没有任何类型的表或数据。</td>
</tr>
<tr>
<td>__ TEXT, __cstring</td>
<td>Constant C strings. A C string is a sequence of non-null bytes that ends<br/>with a null byte (‘\0’). The static linker coalesces constant C string values,<br/>removing duplicates, when building the final product.<br>常数C字符串。C字符串是一个以空字节(‘\0’)结尾的非空字节序列。静态链接器在构建最终产品时合并常量C字符串值，删除重复项。</td>
</tr>
<tr>
<td>__ TEXT, __picsymbol_stub</td>
<td>Position-independent indirect symbol stubs. See “Dynamic Code<br/>Generation” in <em>Mach-O Programming Topics</em> for more information.<br>位置无关的间接符号存根。有关更多信息，请参阅Mach-O编程主题中的“动态代码生成”。</td>
</tr>
<tr>
<td>__ TEXT, __symbol_stub</td>
<td>Indirect symbol stubs. See “Dynamic Code Generation” in <em>Mach-O<br/>Programming Topics</em> for more information.<br>间接的象征存根。有关更多信息，请参阅Mach-O编程主题中的“动态代码生成”。</td>
</tr>
<tr>
<td>__ TEXT, __const</td>
<td>Initialized constant variables. The compiler places all nonrelocatable data<br/>declared const in this section. (The compiler typically places uninitialized constant variables in a zero-filled section.)<br>初始化常数变量。编译器将在本节中放置所有声明的const的不可重定位数据。(编译器通常将未初始化的常量变量放在一个零填充的部分。)</td>
</tr>
<tr>
<td>__ TEXT, __literal4</td>
<td>4-byte literal values. The compiler places single-precision floating point<br/>constants in this section. The static linker coalesces these values, removing<br/>duplicates, when building the final product. With some architectures,<br/>it’s more efficient for the compiler to use immediate load instructions<br/>rather than adding to this section.<br>4字节的文本值。编译器在本节中放置单精度浮点常量。静态链接器在构建最终产品时合并这些值，删除重复项。对于某些架构，编译器使用立即加载指令比添加到本节更有效。</td>
</tr>
<tr>
<td>__ TEXT, __literal8</td>
<td>8-byte literal values. The compiler places double-precision floating point<br/>constants in this section. The static linker coalesces these values, removing<br/>duplicates, when building the final product. With some architectures,<br/>it’s more efficient for the compiler to use immediate load instructions<br/>rather than adding to this section.<br>8字节文字值。编译器在本节中放置双精度浮点常量。静态链接器在构建最终产品时合并这些值，删除重复项。对于某些架构，编译器使用立即加载指令比添加到本节更有效。</td>
</tr>
</tbody></table>
<p><strong>Table 2</strong>    The sections of a __DATA segment </p>
<table>
<thead>
<tr>
<th>Segment and section name</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td>__ DATA, __data</td>
<td>Initialized mutable variables, such as writable C strings and data arrays.<br>初始化可变变量，如可写C字符串和数据数组。</td>
</tr>
<tr>
<td>__ DATA, __la_symbol_ptr</td>
<td>Lazy symbol pointers, which are indirect references to functions<br/>imported from a different file. See “Dynamic Code Generation” in<br/><em>Mach-O Programming Topics</em> for more information.<br>懒加载符号指针，是对从不同文件导入的函数的间接引用。有关更多信息，请参阅Mach-O编程主题中的“动态代码生成”。</td>
</tr>
<tr>
<td>__ DATA, __nl_symbol_ptr</td>
<td>Non-lazy symbol pointers, which are indirect references to data items imported from a different file. See “Dynamic Code Generation” in Mach-O Programming Topics for more information.<br>非懒加载符号指针，是对从其他文件导入的函数的间接引用。有关详细信息，请参阅<a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001827-SW1" target="_blank" rel="noopener">Mach-O Programming Topics</a>中的“Dynamic Code Generatio”。</td>
</tr>
<tr>
<td>__ DATA, __dyld</td>
<td>Placeholder section used by the dynamic linker.<br>动态链接器使用的占位section</td>
</tr>
<tr>
<td>__ DATA, __const</td>
<td>Initialized relocatable constant variables.<br>初始化可重定位常量变量。</td>
</tr>
<tr>
<td>__ DATA, __mod_init_func</td>
<td>Module initialization functions. The C++ compiler places static<br/>constructors here.<br>模块初始化方法，c++的静态构造函数在这里放</td>
</tr>
<tr>
<td>__ DATA, __mod_term_func</td>
<td>Module termination functions.<br>退出方法，类似析构函数</td>
</tr>
<tr>
<td>__ DATA, __bss</td>
<td>Data for uninitialized static variables (for example, static int i;).<br>未初始化静态变量的数据（例如，static int i；）</td>
</tr>
<tr>
<td>__ DATA, __common</td>
<td>Uninitialized imported symbol definitions (for example, int i;)<br/>located in the global scope (outside of a function declaration).<br>位于全局范围（函数声明之外）中的未初始化全局符号的定义（例如，int i；)</td>
</tr>
</tbody></table>
<p><strong>Table 3</strong>  The sections of a __IMPORT segment </p>
<table>
<thead>
<tr>
<th>Segment and section name</th>
<th>Contents</th>
</tr>
</thead>
<tbody><tr>
<td>__ IMPORT, __jump_table</td>
<td>Stubs for calls to functions in a dynamic library.<br>动态库中函数调用的存根。</td>
</tr>
<tr>
<td>__ IMPORT, __pointers</td>
<td>Non-lazy symbol pointers, which are direct references to functions<br/>imported from a different file.<br>非懒加载符号指针，它们直接引用从其他文件导入的函数</td>
</tr>
</tbody></table>
<blockquote>
<p> Note: Compilers or any tools that create Mach-O files are free to define additional section names. These additional names do not appear in Table </p>
<p>注意：编译器或任何创建mach-o文件的工具都可以自由定义附加的节名。这些附加名称不出现在表中</p>
</blockquote>
<h1 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h1><p>This reference describes the data types that compose a Mach-O file. Values for integer types in all Mach-O data structures are written using the host CPU’s byte ordering scheme, except for <code>fat_header</code> (page 56) and <code>fat_arch</code> (page 56), which are written in big-endian byte order.</p>
<p>此参考描述组成mach-o文件的数据类型。所有mach-o数据结构中的整数类型的值都是使用主机cpu的字节顺序方案编写的，除了<code>fat_header</code>（第56页）和<code>fat_arch</code>（第56页）之外，它们都是以大端字节顺序编写的。</p>
<h2 id="Header-Data-Structure"><a href="#Header-Data-Structure" class="headerlink" title="Header Data Structure"></a>Header Data Structure</h2><h3 id="mach-header"><a href="#mach-header" class="headerlink" title="mach_header"></a>mach_header</h3><p>Specifies the general attributes of a file. Appears at the beginning of object files targeted to 32-bit architectures. Declared in /usr/include/mach-o/loader.h. See also mach_header_64 (page 14).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 32-bit mach header appears at the very beginning of the object file for</span></span><br><span class="line"><span class="comment"> * 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Constant for the magic field of the mach_header (32-bit architectures) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_MAGIC	0xfeedface	<span class="comment">/* the mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM	0xcefaedfe	<span class="comment">/* NXSwapInt(MH_MAGIC) */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>magic</strong></p>
<p>An integer containing a value identifying this file as a 32-bit Mach-O file. Use the constant MH_MAGIC if the file is intended for use on a CPU with the same endianness as the computer on which the compiler is running. The constant MH_CIGAM can be used when the byte ordering scheme of the target machine is the reverse of the host CPU.</p>
<p>一个整数将文件标识为32位Mach-O文件。如果文件要在与运行编译器的计算机具有相同端点的CPU上使用，请使用常量MH_MAGIC。当目标机器的字节排序方案与主机cpu相反时，可以使用常数MH_CIGAM。(大小端值不相同)</p>
</li>
<li><p><strong>cputype</strong></p>
<p>An integer indicating the architecture you intend to use the file on. Appropriate values include:</p>
<p>一个整数，指示要在其上使用文件的体系结构。适当的值包括：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/machine.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Machine types known by all.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ANY		((cpu_type_t) -1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_VAX		((cpu_type_t) 1)</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 2)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 3)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 4)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 5)	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	CPU_TYPE_MC680x0	((cpu_type_t) 6)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_X86		((cpu_type_t) 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386		CPU_TYPE_X86		<span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	CPU_TYPE_X86_64		(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* skip CPU_TYPE_MIPS		((cpu_type_t) 8)	*/</span></span><br><span class="line"><span class="comment">/* skip 			((cpu_type_t) 9)	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_MC98000	((cpu_type_t) 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_HPPA           ((cpu_type_t) 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM		((cpu_type_t) 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64		(CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_MC88000	((cpu_type_t) 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_SPARC		((cpu_type_t) 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I860		((cpu_type_t) 15)</span></span><br><span class="line"><span class="comment">/* skip	CPU_TYPE_ALPHA		((cpu_type_t) 16)	*/</span></span><br><span class="line"><span class="comment">/* skip				((cpu_type_t) 17)	*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_POWERPC		((cpu_type_t) 18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_POWERPC64		(CPU_TYPE_POWERPC | CPU_ARCH_ABI64)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cpusubtype</strong></p>
<p>An integer specifying the exact model of the CPU. To run on all PowerPC or x86 processors supported by the Mac OS X kernel, this should be set to CPU_SUBTYPE_POWERPC_ALL or CPU_SUBTYPE_I386_ALL.</p>
<p>一个整数，指定CPU的确切型号。要在Mac OS X内核支持的所有PowerPC或x86处理器上运行，应将其设置为CPU_Subtype_PowerPC_All或CPU_Subtype_i386_All。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_SUBTYPE_ARM_ALL             ((cpu_subtype_t) 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_SUBTYPE_X86_ALL		((cpu_subtype_t)3)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>filetype</strong></p>
<p>An integer indicating the usage and alignment of the file. Valid values for this field include:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A core file is in MH_CORE format and can be any in an arbritray legal</span></span><br><span class="line"><span class="comment"> * Mach-O file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Constants for the filetype field of the mach_header</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_OBJECT	0x1		<span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_EXECUTE	0x2		<span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_FVMLIB	0x3		<span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_CORE		0x4		<span class="comment">/* core file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PRELOAD	0x5		<span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLIB	0x6		<span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLINKER	0x7		<span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_BUNDLE	0x8		<span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DYLIB_STUB	0x9		<span class="comment">/* shared library stub for static */</span></span></span><br><span class="line">					<span class="comment">/*  linking only, no section contents */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DSYM		0xa		<span class="comment">/* companion file with only debug */</span></span></span><br><span class="line">					<span class="comment">/*  sections */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_KEXT_BUNDLE	0xb		<span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>The <code>MH_OBJECT</code> file type is the format used for intermediate object files. It is a very compact format containing all its sections in one segment. The compiler and assembler usually create one <code>MH_OBJECT</code> file for each source code file. By convention, the file name extension for this format is .o.</p>
<p><code>MH_OBJECT</code>文件类型是用于中间对象文件的格式。它是一种非常紧凑的格式，将其所有部分都包含在一个段中。编译器和汇编程序通常为每个源代码文件创建一个<code>MH_OBJECT</code>文件。按照惯例，此格式的文件扩展名为.o。</p>
</li>
<li><p>The <code>MH_EXECUTE</code> file type is the format used by standard executable programs. </p>
<p><code>MH_EXECUTE</code> file type是标准可执行程序使用的格式。</p>
</li>
<li><p>The <code>MH_BUNDLE</code> file type is the type typically used by code that you load at runtime (typically called bundles or plug-ins). By convention, the file name extension for this format is .bundle.</p>
<p><code>MH_BUNDLE</code>文件类型是运行时加载的代码通常使用的类型（通常称为bundle或插件）。按照惯例，此格式的文件扩展名为.bundle。 </p>
</li>
<li><p>The <code>MH_DYLIB</code> file type is for dynamic shared libraries. It contains some additional tables to support multiple modules. By convention, the file name extension for this format is .dylib, except for the main shared library of a framework, which does not usually have a file name extension. </p>
<p><code>MH_DYLIB</code>文件类型用于动态共享库。它包含一些额外的表来支持多个模块。按照惯例，此格式的文件扩展名为.dylib，但框架的主共享库除外，它通常没有文件扩展名。</p>
</li>
<li><p>The <code>MH_PRELOAD</code> file type is an executable format used for special-purpose programs that are not loaded by the Mac OS X kernel, such as programs burned into programmable ROM chips. Do not confuse this file type with the <code>MH_PREBOUND</code> flag, which is a flag that the static linker sets in the header structure to mark a prebound image. </p>
<p><code>MH_PRELOAD</code>文件类型是一种可执行格式，用于mac os x内核未加载的特殊用途程序，例如烧录到可编程ROM芯片中的程序。不要将此文件类型与<code>MH_PREBOUND</code>标志混淆，<code>MH_PREBOUND</code>标志是静态链接器在头结构中设置的用于标记预绑定图像的标志。</p>
</li>
<li><p>The <code>MH_CORE</code> file type is used to store core files, which are traditionally created when a program crashes. Core files store the entire address space of a process at the time it crashed. You can later run gdb on the core file to figure out why the crash occurred. </p>
<p><code>MH_CORE</code>文件类型用于存储核心文件，这些文件通常在程序崩溃时创建。核心文件存储进程崩溃时的整个地址空间。您可以稍后在核心文件上运行gdb来找出崩溃的原因。</p>
</li>
<li><p>The <code>MH_DYLINKER</code> file type is the type of a dynamic linker shared library. This is the type of the dyld file. </p>
<p><code>MH_DYLINKER</code>文件类型是动态链接器共享库的类型。这是dyld文件的类型。</p>
</li>
<li><p>The <code>MH_DSYM</code> file type designates files that store symbol information for a corresponding binary file. </p>
<p><code>MH_DSYM</code>文件类型指定存储相应二进制文件的符号信息的文件。</p>
</li>
</ul>
</li>
<li><p><strong>ncmds</strong></p>
<p>An integer indicating the number of load commands following the header structure.</p>
<p>指定架构load commands的个数</p>
</li>
<li><p><strong>sizeofcmds</strong> </p>
<p>An integer indicating the number of bytes occupied by the load commands following the header structure. 所有load commands的size</p>
</li>
<li><p><strong>flags</strong></p>
<p>An integer containing a set of bit flags that indicate the state of certain optional features of the<br>Mach-O file format. These are the masks you can use to manipulate this field:</p>
<p>一个整数，包含一组位标志，指示mach-o文件格式某些可选功能的状态。以下是可用于操作此字段的掩码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Constants for the flags field of the mach_header */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_NOUNDEFS	0x1		<span class="comment">/* the object file has no undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   references */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_INCRLINK	0x2		<span class="comment">/* the object file is the output of an</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   incremental link against a base file</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   and can't be link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK	0x4		<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   dynamic linker and can't be staticly</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDATLOAD	0x8		<span class="comment">/* the object file's undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   references are bound by the dynamic</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   linker when loaded. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBOUND	0x10		<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   references prebound. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS	0x20		<span class="comment">/* the file has its read-only and</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   read-write segments split */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_LAZY_INIT	0x40		<span class="comment">/* the shared library init routine is</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   to be run lazily via catching memory</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   faults to its writeable segments</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL	0x80		<span class="comment">/* the image is using two-level name</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   space bindings */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FORCE_FLAT	0x100		<span class="comment">/* the executable is forcing all images</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   to use flat name space bindings */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOMULTIDEFS	0x200		<span class="comment">/* this umbrella guarantees no multiple</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   defintions of symbols in its</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   sub-images so the two-level namespace</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   hints can always be used. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOFIXPREBINDING 0x400	<span class="comment">/* do not have dyld notify the</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   prebinding agent about this</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   executable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBINDABLE  0x800           <span class="comment">/* the binary is not prebound but can</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   have its prebinding redone. only used</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                           when MH_PREBOUND is not set. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLMODSBOUND 0x1000		<span class="comment">/* indicates that this binary binds to</span></span></span><br><span class="line"><span class="meta"><span class="comment">                                           all two-level namespace modules of</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   its dependent libraries. only used</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   when MH_PREBINDABLE and MH_TWOLEVEL</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   are both set. */</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SUBSECTIONS_VIA_SYMBOLS 0x2000<span class="comment">/* safe to divide up the sections into</span></span></span><br><span class="line"><span class="meta"><span class="comment">					    sub-sections via symbols for dead</span></span></span><br><span class="line"><span class="meta"><span class="comment">					    code stripping */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CANONICAL    0x4000		<span class="comment">/* the binary has been canonicalized</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   via the unprebind operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES	0x8000		<span class="comment">/* the final linked image contains</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   external weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000	<span class="comment">/* the final linked image uses</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   weak symbols */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ALLOW_STACK_EXECUTION 0x20000<span class="comment">/* When this bit is set, all stacks </span></span></span><br><span class="line"><span class="meta"><span class="comment">					   in the task will be given stack</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   execution privilege.  Only used in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   MH_EXECUTE filetypes. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_ROOT_SAFE 0x40000           <span class="comment">/* When this bit is set, the binary </span></span></span><br><span class="line"><span class="meta"><span class="comment">					  declares it is safe for use in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					  processes with uid zero */</span></span></span><br><span class="line">                                         </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SETUID_SAFE 0x80000         <span class="comment">/* When this bit is set, the binary </span></span></span><br><span class="line"><span class="meta"><span class="comment">					  declares it is safe for use in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					  processes when issetugid() is true */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_REEXPORTED_DYLIBS 0x100000 <span class="comment">/* When this bit is set on a dylib, </span></span></span><br><span class="line"><span class="meta"><span class="comment">					  the static linker does not need to</span></span></span><br><span class="line"><span class="meta"><span class="comment">					  examine dependent dylibs to see</span></span></span><br><span class="line"><span class="meta"><span class="comment">					  if any are re-exported */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_PIE 0x200000			<span class="comment">/* When this bit is set, the OS will</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   load the main executable at a</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   random address.  Only used in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   MH_EXECUTE filetypes. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_DEAD_STRIPPABLE_DYLIB 0x400000 <span class="comment">/* Only for use on dylibs.  When</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     linking against a dylib that</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     has this bit set, the static linker</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     will automatically not create a</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     LC_LOAD_DYLIB load command to the</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     dylib if no symbols are being</span></span></span><br><span class="line"><span class="meta"><span class="comment">					     referenced from the dylib. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_HAS_TLV_DESCRIPTORS 0x800000 <span class="comment">/* Contains a section of type </span></span></span><br><span class="line"><span class="meta"><span class="comment">					    S_THREAD_LOCAL_VARIABLES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NO_HEAP_EXECUTION 0x1000000	<span class="comment">/* When this bit is set, the OS will</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   run the main executable with</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   a non-executable heap even on</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   platforms (e.g. i386) that don't</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   require it. Only used in MH_EXECUTE</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   filetypes. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_APP_EXTENSION_SAFE 0x02000000 <span class="comment">/* The code was linked for use in an</span></span></span><br><span class="line"><span class="meta"><span class="comment">					    application extension. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_NLIST_OUTOFSYNC_WITH_DYLDINFO 0x04000000 <span class="comment">/* The external symbols</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   listed in the nlist symbol table do</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   not include all the symbols listed in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   the dyld info. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	MH_SIM_SUPPORT 0x08000000	<span class="comment">/* Allow LC_MIN_VERSION_MACOS and</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   LC_BUILD_VERSION load commands with</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   the platforms macOS, macCatalyst,</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   iOSSimulator, tvOSSimulator and</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   watchOSSimulator. */</span></span></span><br><span class="line">					   </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB_IN_CACHE 0x80000000	<span class="comment">/* Only for use on dylibs. When this bit</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   is set, the dylib is part of the dyld</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   shared cache, rather than loose in</span></span></span><br><span class="line"><span class="meta"><span class="comment">					   the filesystem. */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>MH_NOUNDEFS</code>—The object file contained no undefined references when it was built. </p>
<p>​                            对象文件在生成时不包含未定义的引用</p>
</li>
<li><p><code>MH_INCRLINK</code> The object file is the output of an incremental link against a base file and<br>cannot be linked again</p>
<p>对象文件是对基本文件的增量链接的输出，并且无法再次链接</p>
</li>
<li><p><code>MH_DYLDLINK</code> </p>
<ul>
<li><p>The file is input for the dynamic linker and cannot be statically linked again.</p>
<p>该文件是动态链接器的输入，不能再次静态链接。  </p>
</li>
</ul>
</li>
<li><p><code>MH_TWOLEVEL</code>  </p>
<ul>
<li><p>The image is using two-level namespace bindings </p>
<p>Image正在使用两级命名空间绑定</p>
</li>
</ul>
</li>
<li><p><code>MH_BINDATLOAD</code></p>
<ul>
<li><p>The dynamic linker should bind the undefined references when the file </p>
<p>is loaded. </p>
<p>动态链接器应该在文件加载时绑定未定义的引用</p>
</li>
</ul>
</li>
<li><p><code>MH_PREBOUND</code> </p>
<ul>
<li><p>The file’s undefined references are prebound. </p>
<p>文件的未定义引用是预先绑定的。</p>
</li>
</ul>
</li>
<li><p><code>MH_PREBINDABLE</code> </p>
<ul>
<li>This file is not prebound but can have its prebinding redone. Used only when MH_PREBEOUND is not set </li>
<li>此文件不是预绑定的，但可以重新进行预绑定。仅在未设置MH_PREBEOUND时使用</li>
</ul>
</li>
<li><p><code>MH_NOFIXPREBINDING</code></p>
<ul>
<li><p>The dynamic linker doesn’t notify the prebinding agent about this executable. </p>
<p>动态链接器不会将此可执行文件通知预绑定代理。</p>
</li>
</ul>
</li>
<li><p><code>MH_ALLMODSBOUND</code></p>
<ul>
<li>Indicates that this binary binds to all two-level namespace modules of its dependent libraries. Used only when MH_PREBINDABLE and MH_TWOLEVEL are set. </li>
<li>指示此二进制文件绑定到其依赖库的所有两级命名空间模块。仅当设置了MH_PREBINDABLE和MH_TWOLEVEL时使用。</li>
</ul>
</li>
<li><p><code>MH_CANONICAL</code></p>
<ul>
<li>This file has been canonicalized by unprebinding—clearing prebinding information from the file. See the redo_prebinding man page for details </li>
<li>此文件已通过取消绑定从文件中清除预绑定信息来规范化。有关详细信息，请参阅重做预绑定手册页</li>
</ul>
</li>
<li><p><code>MH_SPLIT_SEGS</code></p>
<ul>
<li>The file has its read-only and read-write segments split. </li>
<li>文件的只读段和读写段被拆分。</li>
</ul>
</li>
<li><p><code>MH_FORCE_FLAT</code></p>
<ul>
<li>The executable is forcing all images to use flat namespace bindings. </li>
<li>可执行文件正在强制所有映像使用平面命名空间绑定。</li>
</ul>
</li>
<li><p><code>MH_SUBSECTIONS_VIA_SYMBOLS</code></p>
<ul>
<li>The sections of the object file can be divided into individual blocks. These blocks are dead-stripped if they are not used by other code. See “Linking” in Xcode User Guide for details. </li>
<li>对象文件的各个部分可以划分为单独的块。如果其他代码不使用这些块，则它们将被完全剥离。有关详细信息，请参阅Xcode用户指南中的“链接”。</li>
</ul>
</li>
<li><p><code>MH_NOMULTIDEFS</code></p>
<ul>
<li>This umbrella guarantees there are no multiple definitions of symbols in its subimages. As a result, the two-level namespace hints can always be used. </li>
<li>这把伞保证了它的子图像中没有符号的多重定义。因此，始终可以使用两级命名空间提示。</li>
</ul>
</li>
<li><p><code>MH_PIE</code> </p>
<ul>
<li>When this bit is set, the OS will load the main executable at a random address.  Only used in <code>MH_EXECUTE</code> filetypes</li>
<li>随机地址分布，ASLR 用于MH_EXECUTE filetype</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Special Considerations</strong></p>
<p>For all file types, except <code>MH_OBJECT</code>, segments must be aligned on page boundaries for the given CPU<br>architecture: 4096 bytes for PowerPC and x86 processors. This allows the kernel to page virtual memory<br>directly from the segment into the address space of the process. The header and load commands must<br>be aligned as part of the data of the first segment stored on disk (which would be the __TEXT segment,<br>in the file types described in filetype).</p>
<p>对于除MH_OBJECT以外的所有文件类型，对于给定的cpu体系结构，段必须在页面边界上对齐：对于powerpc和x86处理器，为4096字节。这允许内核将虚拟内存直接从段分页到进程的地址空间。<code>header</code>和<code>load commands</code>存储在磁盘上的第一个段的数据的一部分对齐（在filetype中描述的文件类型中，第一个段是__TEXT段)</p>
</li>
</ul>
<h2 id="Load-Command-Data-Structures"><a href="#Load-Command-Data-Structures" class="headerlink" title="Load Command Data Structures"></a>Load Command Data Structures</h2><p>The load command structures are located directly after the header of the object file, and they specify<br>both the logical structure of the file and the layout of the file in virtual memory. Each load command<br>begins with fields that specify the command type and the size of the command data.</p>
<p>加载命令结构直接位于对象文件头的后面，它们指定文件的逻辑结构和虚拟内存中文件的布局。每个加载命令都以指定命令类型和命令数据大小的字段开头。</p>
<h3 id="load-command"><a href="#load-command" class="headerlink" title="load_command"></a>load_command</h3><p>Contains fields that are common to all load commands.</p>
<p>包含所有加载命令通用的字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmd;		<span class="comment">/* type of load command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code> </p>
<p>An integer indicating the type of load command. Table 4 lists the valid load command types.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>An integer specifying the total size in bytes of the load command data structure. Each load<br>command structure contains a different set of data, depending on the load command type, so<br>each might have a different size. In 32-bit architectures, the size must always be a multiple of<br>4; in 64-bit architectures, the size must always be a multiple of 8. If the load command data<br>does not divide evenly by 4 or 8 (depending on whether the target architecture is 32-bit or<br>64-bit, respectively), add bytes containing zeros to the end until it does.</p>
<p>一个整数，指定加载命令数据结构的总大小（字节）。每个加载命令结构都包含不同的数据集，具体取决于加载命令类型，因此每个数据集的大小可能不同。在32位体系结构中，大小必须始终是4的倍数；在64位体系结构中，大小必须始终是8的倍数。如果加载命令数据没有被4或8等分（分别取决于目标体系结构是32位还是64位），请在末尾添加包含零的字节，直到它等分为止。</p>
</li>
</ul>
<p><strong>Discussion</strong></p>
<p>Table 4 lists the valid load command types, with links to the full data structures for each type.</p>
<p>表4列出了有效的加载命令类型，每种类型都有指向完整数据结构的链接。</p>
<p><strong>Table 4</strong> Mach-O load commands</p>
<table>
<thead>
<tr>
<th>Commands</th>
<th>Data Structures</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>LC_UUID</td>
<td>uuid_command</td>
<td>Specifies the 128-bit UUID for an image <br>or its corresponding dSYM file.<br>为image或其相应的dSYM文件指定128位uuid</td>
</tr>
<tr>
<td>LC_SEGMENT</td>
<td>segment_command</td>
<td>Defines a segment of this file to be<br/>mapped into the address space of the<br/>process that loads this file. It also includes<br/>all the sections contained by the segment.<br>定义要映射到加载此文件的进程的地址空间中的此文件段。它还包括该段所包含的所有部分。</td>
</tr>
<tr>
<td>LC_SEGMENT_64</td>
<td>segment_command_64</td>
<td>Defines a 64-bit segment of this file to be<br/>mapped into the address space of the<br/>process that loads this file. It also includes<br/>all the sections contained by the segment.</td>
</tr>
<tr>
<td>LC_SYMTAB</td>
<td>symtab_command</td>
<td>Specifies the symbol table for this file.<br/>This information is used by both static<br/>and dynamic linkers when linking the<br/>file, and also by debuggers to map<br/>symbols to the original source code files<br/>from which the symbols were generated.<br>指定此文件的符号表。静态和动态链接器在链接文件时都会使用此信息，调试器也会使用此信息将符号映射到生成符号的原始源代码文件。</td>
</tr>
<tr>
<td>LC_DYSYMTAB</td>
<td>dysymtab_command</td>
<td>Specifies additional symbol table<br/>information used by the dynamic linker.<br>指定动态链接器使用的其他符号表信息。</td>
</tr>
<tr>
<td>LC_THREAD LC_UNIXTHREAD</td>
<td>thread_command</td>
<td>For an executable file, the LC_UNIXTHREAD<br/>command defines the initial thread state<br/>of the main thread of the process.<br/>LC_THREAD is similar to LC_UNIXTHREAD<br/>but does not cause the kernel to allocate<br/>a stack.<br>对于可执行文件，LC_UNIXTHREAD命令定义进程主线程的初始线程状态。LC_THREAD类似于LC_UNIXTHREAD，但不会导致内核分配堆栈。</td>
</tr>
<tr>
<td>LC_LOAD_DYLIB</td>
<td>dylib_command</td>
<td>Defines the name of a dynamic shared<br/>library that this file links against.<br>定义此文件链接所针对的动态共享库的名称。</td>
</tr>
<tr>
<td>LC_ID_DYLIB</td>
<td>dylib_command</td>
<td>Specifies the install name of a dynamic<br/>shared library.<br>指定动态共享库的安装名称。</td>
</tr>
<tr>
<td>LC_PREBOUND_DYLIB</td>
<td>prebound_dylib_command</td>
<td>For a shared library that this executable<br/>is linked prebound against, specifies the<br/>modules in the shared library that are<br/>used.<br>对于此可执行文件链接到的共享库，请指定共享库中使用的模块。</td>
</tr>
<tr>
<td>LC_LOAD_DYLINKER</td>
<td>dylinker_command</td>
<td>Specifies the dynamic linker that the<br/>kernel executes to load this file.<br>指定内核执行以加载此文件的动态链接器。</td>
</tr>
<tr>
<td>LC_ID_DYLINKER</td>
<td>dylinker_command</td>
<td>Identifies this file as a dynamic linker.<br>将此文件标识为动态链接器。</td>
</tr>
<tr>
<td>LC_ROUTINES</td>
<td>routines_command</td>
<td>Contains the address of the shared library<br/>initialization routine (specified by the<br/>linker’s -init option).<br>包含共享库初始化例程的地址（由链接器的-init选项指定）。</td>
</tr>
<tr>
<td>LC_ROUTINES_64</td>
<td>routines_command_64</td>
<td>Contains the address of the shared library<br/>64-bit initialization routine (specified by<br/>the linker’s -init option).</td>
</tr>
<tr>
<td>LC_TWOLEVEL_HINTS</td>
<td>twolevel_hints_command</td>
<td>Contains the two-level namespace lookup<br/>hint table.<br>包含两级命名空间查找提示表。</td>
</tr>
<tr>
<td>LC_SUB_FRAMEWORK</td>
<td>sub_framework_command</td>
<td>Identifies this file as the implementation<br/>of a subframework of an umbrella<br/>framework. The name of the umbrella<br/>framework is stored in the string<br/>parameter.<br>将此文件标识为伞形框架的子框架的实现。伞形框架的名称存储在字符串参数中。</td>
</tr>
<tr>
<td>LC_SUB_UMBRELLA</td>
<td>sub_umbrella_command</td>
<td>Specifies a file that is a subumbrella of<br/>this umbrella framework.<br>指定作为此伞形框架的子伞形结构的文件。</td>
</tr>
<tr>
<td>LC_SUB_LIBRARY</td>
<td>sub_library_command</td>
<td>Identifies this file as the implementation<br/>of a sublibrary of an umbrella framework.<br/>The name of the umbrella framework is<br/>stored in the string parameter. Note that<br/>Apple has not defined a supported<br/>location for sublibraries.<br>将此文件标识为伞形框架的子库的实现。伞形框架的名称存储在字符串参数中。请注意，Apple尚未为子库定义支持的位置。</td>
</tr>
<tr>
<td>LC_SUB_CLIENT</td>
<td>sub_client_command</td>
<td>A subframework can explicitly allow<br/>another framework or bundle to link<br/>against it by including an LC_SUB_CLIENT<br/>load command containing the name of<br/>the framework or a client name for a<br/>bundle.<br>子框架可以通过包含lc_sub_client load命令显式地允许另一个框架或捆绑包与之链接，该命令包含框架的名称或捆绑包的客户端名称。</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>uuid_command</strong></p>
<p>Specifies the 128-bit universally unique identifier (UUID) for an image or for its corresponding dSYM file.</p>
<p>为image或其相应的dSYM文件指定128位uuid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The uuid load command contains a single 128-bit unique random number that</span></span><br><span class="line"><span class="comment"> * identifies an object produced by the static link editor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_UUID */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* sizeof(struct uuid_command) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>	uuid[<span class="number">16</span>];	<span class="comment">/* the 128-bit uuid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong> </p>
<ul>
<li><p><code>cmd</code></p>
<pre><code>Set to LC_UUID for this structure. </code></pre></li>
<li><p><code>cmdsize</code></p>
<pre><code>Set to sizeof(uuid_command). </code></pre></li>
<li><p><code>uuid</code></p>
<p>​        128-bit unique identifier</p>
</li>
</ul>
<p><strong>Declared In</strong> </p>
<p>/usr/include/mach-o/loader.h</p>
</li>
</ul>
<ul>
<li><p><strong>segment_command</strong></p>
<p>Specifies the range of bytes in a 32-bit Mach-O file that make up a segment. Those bytes are mapped by the loader into the address space of a program. Declared in /usr/include/mach-o/loader.h.</p>
<p>指定组成段的32位mach-o文件中的字节范围。这些字节由加载程序映射到程序的地址空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit segment load command indicates that a part of this file is to be</span></span><br><span class="line"><span class="comment"> * mapped into a 64-bit task's address space.  If the 64-bit segment has</span></span><br><span class="line"><span class="comment"> * sections then section_64 structures directly follow the 64-bit segment</span></span><br><span class="line"><span class="comment"> * command and their size is reflected in cmdsize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment name */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmaddr;		<span class="comment">/* memory address of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	vmsize;		<span class="comment">/* memory size of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	fileoff;	<span class="comment">/* file offset of this segment */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	filesize;	<span class="comment">/* amount to map from the file */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	maxprot;	<span class="comment">/* maximum VM protection */</span></span><br><span class="line">	<span class="keyword">vm_prot_t</span>	initprot;	<span class="comment">/* initial VM protection */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsects;		<span class="comment">/* number of sections in segment */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. Set to LC_SEGMENT for this structure.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set this field to<br>sizeof(segment_command) plus the size of all the section data structures that follow<br>(sizeof(segment_command + (sizeof(section) * segment-&gt;nsect))).</p>
</li>
<li><p><code>segname</code></p>
<p>A C string specifying the name of the segment. The value of this field can be any sequence of<br>ASCII characters, although segment names defined by Apple begin with two underscores and<br>consist of capital letters (as in <strong>_TEXT and _</strong>DATA). This field is fixed at 16 bytes in length.</p>
<p>指定段名称的C字符串。此字段的值可以是任意一个ASCII字符序列，尽管Apple定义的段名称以两个下划线开头，并由大写字母组成（如在“<strong>___</strong>TEXT”和”_____DATA”中）。此字段的长度固定为16字节。</p>
</li>
<li><p><code>vmaddr</code></p>
<p>Indicates the starting virtual memory address of this segment.</p>
<p>指示此段的起始虚拟内存地址。</p>
</li>
<li><p><code>vmsize</code></p>
<p>Indicates the number of bytes of virtual memory occupied by this segment. See also the<br>description of filesize, below.</p>
<p>指示此段占用的虚拟内存字节数。另请参见下面的文件大小说明。</p>
</li>
<li><p><code>fileoff</code></p>
<p>Indicates the offset in this file of the data to be mapped at vmaddr.</p>
<p>指示此文件中要在vmaddr映射的数据的偏移量。</p>
</li>
<li><p><code>filesize</code></p>
<p>Indicates the number of bytes occupied by this segment on disk. For segments that require<br>more memory at runtime than they do at build time, vmsize can be larger than filesize. For<br>example, the __ PAGEZERO segment generated by the linker for MH_EXECUTABLE files has a<br>vmsize of 0x1000 but a filesize of 0. Because _ PAGEZERO contains no data, there is no need<br>for it to occupy any space until runtime. Also, the static linker often allocates uninitialized data<br>at the end of the __DATA segment; in this case, the vmsize is larger than the filesize. The<br>loader guarantees that any memory of this sort is initialized with zeros.</p>
<p>指示磁盘上此段占用的字节数。对于运行时比构建时需要更多内存的段，vmsize可以大于filesize。例如，链接器为MH_EXECUTABLE文件生成的u pagezero段的vmsize为0x1000，而filesize为0。因为pagezero不包含任何数据，所以在运行之前不需要占用任何空间。此外，静态链接器通常在数据段末尾分配未初始化的数据；在这种情况下，vmsize大于filesize。加载程序保证这类内存都是用零初始化的。</p>
</li>
<li><p><code>maxprot</code></p>
<p>Specifies the maximum permitted virtual memory protections of this segment.</p>
<p>指定此段允许的最大虚拟内存保护。</p>
</li>
<li><p><code>initprot</code></p>
<p>Specifies the initial virtual memory protections of this segment.</p>
<p>指定此段的初始虚拟内存保护。</p>
</li>
<li><p><code>nsects</code></p>
<p>Indicates the number of section data structures following this load command.</p>
<p>指示此load commands命令下的section数量</p>
</li>
<li><p><code>flags</code></p>
<p>Defines a set of flags that affect the loading of this segment:</p>
<ul>
<li>SG_HIGHVM—The file contents for this segment are for the high part of the virtual memory space; the low part is zero filled (for stacks in core files). </li>
<li>SG_NORELOC—This segment has nothing that was relocated in it and nothing relocated to it. It may be safely replaced without relocation. </li>
<li>定义一组影响此段加载的标志：<br>SG_HIGHVM—此段的文件内容用于虚拟内存空间的高部分；低部分为零填充（用于核心文件中的堆栈）。<br>SG_NORELOC-该段没有重新安置的任何东西，也没有重新安置的任何东西。可安全更换，无需重新安置。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>section</strong></p>
<p>Defines the elements used by a 32-bit section. Directly following a segment_command data structure<br>is an array of section data structures, with the exact count determined by the nsects field of the<br>segment_command (page 20) structure. Declared in /usr/include/mach-o/loader.h. </p>
<p>定义32位节使用的元素。段命令数据结构的正后方是一个段数据结构数组，其精确计数由段命令（第20页）结构的nsects字段确定。在/usr/include/mach-o/loader.h中声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	<span class="built_in">size</span>;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">char</span>		sectname[<span class="number">16</span>];	<span class="comment">/* name of this section */</span></span><br><span class="line">	<span class="keyword">char</span>		segname[<span class="number">16</span>];	<span class="comment">/* segment this section goes in */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	addr;		<span class="comment">/* memory address of this section */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	<span class="built_in">size</span>;		<span class="comment">/* size in bytes of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset of this section */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reloff;		<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nreloc;		<span class="comment">/* number of relocation entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;	<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;	<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;	<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>sectname</code></p>
<p>A string specifying the name of this section. The value of this field can be any sequence of<br>ASCII characters, although section names defined by Apple begin with two underscores and<br>consist of lowercase letters (as in __text and __data). This field is fixed at 16 bytes in length.</p>
<p>指定此节名称的字符串。此字段的值可以是任意一个ASCII字符序列，尽管Apple定义的节名称以两个下划线开头，并且由小写字母组成（如文本和数据）。此字段的长度固定为16字节。</p>
</li>
<li><p><code>segname</code></p>
<p>A string specifying the name of the segment that should eventually contain this section. For<br>compactness, intermediate object files—files of type MH_OBJECT—contain only one segment,<br>in which all sections are placed. The static linker places each section in the named segment<br>when building the final product (any file that is not of type MH_OBJECT).</p>
<p>指定最终应包含此节的段的名称的字符串。对于紧凑性，MH_OBJECT类型的中间对象文件只包含一个段，其中放置了所有的段。静态链接器在生成最终产品（任何不属于MH_OBJECT类型的文件）时将每个部分放置在命名段中。</p>
</li>
<li><p><code>addr</code></p>
<p>An integer specifying the virtual memory address of this section.</p>
<p>指定此节的虚拟内存地址的整数。</p>
</li>
<li><p><code>size</code></p>
<p>An integer specifying the size in bytes of the virtual memory occupied by this section.</p>
<p>一个整数，指定此节占用的虚拟内存的字节大小。</p>
</li>
<li><p><code>offset</code></p>
<p>An integer specifying the offset to this section in the file.</p>
<p>一个整数，指定文件中此节的偏移量。</p>
</li>
<li><p><code>align</code></p>
<p>An integer specifying the section’s byte alignment. Specify this as a power of two; for example,<br>a section with 8-byte alignment would have an align value of 3 (2 to the 3rd power equals 8).</p>
<p>指定节字节对齐方式的整数。将其指定为2的幂；例如，具有8字节对齐的节的对齐值为3（2到3的幂等于8）。</p>
</li>
<li><p><code>reloff</code></p>
<p>An integer specifying the file offset of the first relocation entry for this section.</p>
<p>一个整数，指定此节的第一个重定位项的文件偏移量。</p>
</li>
<li><p><code>nreloc</code></p>
<p>An integer specifying the number of relocation entries located at reloff for this section.</p>
<p>一个整数，指定位于此节的reloff处的重定位条目数。</p>
</li>
<li><p><code>flags</code></p>
<p>An integer divided into two parts. The least significant 8 bits contain the section type, while<br>the most significant 24 bits contain a set of flags that specify other attributes of the section.<br>These types and flags are primarily used by the static linker and file analysis tools, such as<br>otool, to determine how to modify or display the section. These are the possible types:</p>
<p>分成两部分的整数。最低有效8位包含节类型，而最高有效24位包含指定节的其他属性的标志集。这些类型和标志主要由静态链接器和文件分析工具（如otool）使用，以确定如何修改或显示节。以下是可能的类型：</p>
<ul>
<li><p><code>S_REGULAR</code></p>
<p>This section has no particular type. The standard tools create a <strong>TEXT,</strong>text section of this type. </p>
<p>此节没有特定类型。标准工具会创建此类型的文本节。</p>
</li>
<li><p><code>S_ZEROFILL</code></p>
<p>Zero-fill-on-demand section—when this section is first read from or written to, each page within is automatically filled with bytes containing zero. </p>
<p>零按需填充节第一次读取或写入此节时，其中的每一页都会自动填充包含零的字节。</p>
</li>
<li><p><code>S_CSTRING_LITERALS</code> </p>
<p>This section contains only constant C strings. The standard tools create a <strong>TEXT,</strong>cstring section of this type. </p>
<p>这个section仅包含C常量字符串。标准工具在此type下创建了__TEXT, __string</p>
</li>
<li><p><code>S_4BYTE_LITERALS</code></p>
<p>This section contains only constant values that are 4 bytes long. The standard tools create a <strong>TEXT,</strong>literal4 section of this type. </p>
</li>
<li><p><code>S_8BYTE_LITERALS</code></p>
<p>This section contains only constant values that are 8 bytes long. The standard tools create a <strong>TEXT,</strong>literal8 section of this type. </p>
</li>
<li><p><code>S_LITERAL_POINTERS</code></p>
<p>This section contains only pointers to constant values. </p>
<p>本节仅包含指向常量值的指针。</p>
</li>
<li><p><code>S_NON_LAZY_SYMBOL_POINTERS</code></p>
<p>This section contains only non-lazy pointers to symbols. </p>
<p>The standard tools create a section of the <strong>DATA,</strong>nl_symbol_ptrs section of this type.</p>
<p>此部分仅包含指向符号的非懒加载指针。</p>
</li>
<li><p><code>S_LAZY_SYMBOL_POINTERS</code></p>
<p>This section contains only lazy pointers to symbols. The </p>
<p>standard tools create a <strong>DATA,</strong>la_symbol_ptrs section of this type. </p>
<p> 此部分仅包含指向符号的懒加载指针。</p>
</li>
<li><p><code>S_SYMBOL_STUBS</code> </p>
<p>This section contains symbol stubs. The standard tools create <strong>TEXT,</strong>symbol_stub and <strong>TEXT,</strong>picsymbol_stub sections of this type. See “Dynamic Code Generation” in <em>Mach-O Programming Topics</em> for more information. </p>
<p>本节包含符号存根</p>
</li>
<li><p><code>S_MOD_INIT_FUNC_POINTERS</code> </p>
<p>This section contains pointers to module initialization functions. The standard tools create <strong>DATA,</strong>mod_init_func sections of this type. </p>
<p>包含模块初始化方法的指针</p>
</li>
<li><p><code>S_MOD_TERM_FUNC_POINTERS</code></p>
<p>This section contains pointers to module termination functions. The standard tools create <strong>DATA,</strong>mod_term_func sections of this type. </p>
<p>包含模块结束方法的指针</p>
</li>
<li><p><code>S_COALESCED</code></p>
<p>This section contains symbols that are coalesced by the static linker and possibly the dynamic linker. More than one file may contain coalesced definitions of the same symbol without causing multiple-defined-symbol errors. </p>
<p>此部分包含由静态链接器（可能还有动态链接器）合并的符号。多个文件可能包含同一符号的合并定义，但不会导致多个定义的符号错误。</p>
</li>
<li><p><code>S_GB_ZEROFILL</code></p>
<p>This is a zero-filled on-demand section. It can be larger than 4 GB. This section must be placed in a segment containing only zero-filled sections. If you place a zero-filled section in a segment with non–zero-filled sections, you may cause those sections to be unreachable with a 31-bit offset. That outcome stems from the fact that the size of a zero-filled section can be larger than 4 GB (in a 32-bit address space). As a result of this, the static linker would be unable to build the output file. See segment_command (page 20) for more information. </p>
<p>这是一个零填充的按需部分。它可以大于4 GB。此节必须放在只包含零填充节的段中。如果将零填充部分放在具有非零填充部分的段中，则可能会导致以31位偏移量无法访问这些部分。这一结果源于这样一个事实：零填充部分的大小可以大于4GB（在32位地址空间中）。因此，静态链接器将无法生成输出文件。有关更多信息，请参阅StEngSub命令（第20页）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>The following are the possible attributes of a section:

- `S_ATTR_PURE_INSTRUCTIONS` 

  This section contains only executable machine instructions. The standard tools set this flag for the sections __TEXT,__text, __TEXT,__symbol_stub, and __TEXT,__picsymbol_stub. 

  本节仅包含可执行的机器指令。

- `S_ATTR_SOME_INSTRUCTIONS `

  This section contains executable machine instructions. 

- `S_ATTR_NO_TOC`

  This section contains coalesced symbols that must not be placed in the 

  table of contents (SYMDEF member) of a static archive library. 

- `S_ATTR_EXT_RELOC` 

  This section contains references that must be relocated. These references refer to data that exists in other files (undefined symbols). To support external relocation, the maximum virtual memory protections of the segment that contains this section must allow both reading and writing. 

  本节包含必须重新定位的引用。这些引用引用其他文件中存在的数据（未定义的符号）。为了支持外部重定位，包含此节的段的最大虚拟内存保护必须允许读写。

- `S_ATTR_LOC_RELOC`

  This section contains references that must be relocated. These references refer to data within this file. 

  本节包含必须重新定位的引用。这些引用引用此文件中的数据。

- `S_ATTR_STRIP_STATIC_SYMS `

  The static symbols in this section can be stripped if the MH_DYLDLINK flag of the image’s mach_header (page 12) header structure is set. 

- `S_ATTR_NO_DEAD_STRIP `

  This section must not be dead-stripped. See “Linking” in *Xcode User Guide* for details. 

- `S_ATTR_LIVE_SUPPORT `

  This section must not be dead-stripped if they reference code that is live, but the reference is undetectable. </code></pre><ul>
<li><p><code>reserved1</code></p>
<p>An integer reserved for use with certain section types. For symbol pointer sections and symbol stubs sections that refer to indirect symbol table entries, this is the index into the indirect table for this section’s entries. The number of entries is based on the section size divided by the size of the symbol pointer or stub. Otherwise, this field is set to 0. </p>
<p>保留用于某些节类型的整数。对于引用间接符号表项的符号指针节和符号存根节，这是指向该节项的间接表的索引。条目的数目基于节大小除以符号指针或存根的大小。否则，此字段设置为0。</p>
</li>
<li><p><code>reserved2</code></p>
<p>For sections of type S_SYMBOL_STUBS, an integer specifying the size (in bytes) of the symbol </p>
<p>stub entries contained in the section. Otherwise, this field is reserved for future use and should be set to 0. </p>
<p>对于S_SYMBOL_STUBS类型的section，使用整数指定符号的大小(以字节为单位)<br>section中包含的stub条目。否则，此字段将保留以供将来使用，并应设置为0。</p>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  Each section in a Mach-O file has both a type and a set of attribute flags. In intermediate object files, the type and attributes determine how the static linker copies the sections into the final product. Object file analysis tools (such as otool) use the type and attributes to determine how to read and display the sections. Some section types and attributes are used by the dynamic linker. </p>
<p>  These are important static-linking variants of the symbol type and attributes:</p>
<p>  mach-o文件中的每个部分都有一个类型和一组属性标志。在中间对象文件中，类型和属性决定静态链接器如何将节复制到最终产品中。对象文件分析工具（如otool）使用类型和属性来确定如何读取和显示节。动态链接器使用某些节类型和属性。<br>  这些是符号类型和属性的重要静态链接变体： </p>
<ul>
<li><p><strong>Regular sections</strong>. In a regular section, only one definition of an external symbol may exist in intermediate object files. The static linker returns an error if it finds any duplicate external symbol definitions. </p>
<p>在常规部分中，中间对象文件中只能存在外部符号的一个定义。如果发现任何重复的外部符号定义，静态链接器将返回错误。</p>
</li>
<li><p><strong>Coalesced sections</strong>. In the final product, the static linker retains only one instance of each symbol defined in coalesced sections. To support complex language features (such as C++ vtables and RTTI) the compiler may create a definition of a particular symbol in every intermediate object file. The static linker and the dynamic linker would then reduce the duplicate definitions to the single definition used by the program. </p>
<p>在最终产品中，静态链接器只保留合并部分中定义的每个符号的一个实例。为了支持复杂的语言特性（如C++ VTABLE和RTTI），编译器可以在每个中间对象文件中创建一个特定符号的定义。静态链接器和动态链接器将把重复的定义减少到程序使用的单个定义。</p>
</li>
<li><p><strong>Coalesced sections with weak definitions</strong> Weak symbol definitions may appear only in coalesced sections. When the static linker finds duplicate definitions for a symbol, it discards any coalesced symbol definition that has the weak definition attribute set (see nlist (page 39)). If there are no non-weak definitions, the first weak definition is used instead. This feature is designed to support C++ templates; it allows explicit template instantiations to override implicit ones. The C++ compiler places explicit definitions in a regular section, and it places implicit definitions in a coalesced section, marked as weak definitions. Intermediate object files (and thus static archive libraries) built with weak definitions can be used only with the static linker in Mac OS X v10.2 and later. Final products (applications and shared libraries) should not contain weak definitions if they are expected to be used on earlier versions of Mac OS X. </p>
<p>弱符号定义只能出现在合并部分中。当静态链接器发现符号的重复定义时，它将丢弃任何具有弱定义属性集的合并符号定义（请参阅nlist（第39页））。如果没有非弱定义，则使用第一个弱定义。该特性被设计为支持C++模板；它允许显式模板实例化来重写隐式模板。C++编译器将显式定义放在一个常规的部分中，它将隐含的定义放在一个合并的区段中，标记为弱定义。使用弱定义构建的中间对象文件（以及静态存档库）只能与Mac OS X v10.2及更高版本中的静态链接器一起使用。如果最终产品（应用程序和共享库）预期在早期版本的MacOSX上使用，则不应包含弱定义。</p>
</li>
</ul>
<ul>
<li><p><strong>twolevel_hints_command</strong></p>
<p>Defines the attributes of a LC_TWOLEVEL_HINTS load command</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The twolevel_hints_command contains the offset and number of hints in the</span></span><br><span class="line"><span class="comment"> * two-level namespace lookup hints table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twolevel_hints_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;	<span class="comment">/* LC_TWOLEVEL_HINTS */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* sizeof(struct twolevel_hints_command) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset;	<span class="comment">/* offset to the hint table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nhints;	<span class="comment">/* number of hints in the hint table */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. Set to LC_TWOLEVEL_HINTS for this structure.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to<br>sizeof(twolevel_hints_command).</p>
</li>
<li><p><code>offset</code></p>
<p>An integer specifying the byte offset from the start of this file to an array of </p>
<p>twolevel_hint (page 30) data structures, known as the two-level namespace hint table. </p>
<p>在文件内的offset</p>
</li>
<li><p><code>nhints</code></p>
<p>The number of twolevel_hint data structures located at offset.</p>
<p>位于偏移量的二级提示数据结构的数目。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  The static linker adds the LC_TWOLEVEL_HINTS load command and the two-level namespace hint table to the output file when building a two-level namespace image. </p>
<p>  讨论<br>  静态链接器在生成两级命名空间映像时将lc_twowlevel_hints load命令和两级命名空间提示表添加到输出文件中。</p>
<p>  <strong>Special Considerations</strong><br>  By default, ld does not include the LC_TWOLEVEL_HINTS command or the two-level namespace hint table in an MH_BUNDLE file because the presence of this load command causes the version of the dynamic linker shipped with Mac OS X v10.0 to crash. If you know the code will run only on Mac OS X v10.1 and later, you should explicitly enable the two-level namespace hint table. See -twolevel_namespace_hints in the ld man page for more information.</p>
<p>  特殊注意事项<br>  默认情况下，ld不会在MH_BUNDLE文件中包含lc_twolevel_hint命令或两级名称空间提示表，因为这个load命令的存在会导致Mac OS X v10.0附带的动态链接器版本崩溃。如果您知道代码只在Mac OS X v10.1及更高版本上运行，那么应该显式启用两级名称空间提示表。有关更多信息，请参见ld手册页中的- twolevel_namespace_tips。</p>
<ul>
<li><p><strong>twolevel_hint</strong></p>
<p>Specifies an entry in the two-level namespace hint table. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">twolevel_hint</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> </span><br><span class="line">	isub_image:<span class="number">8</span>,	<span class="comment">/* index into the sub images */</span></span><br><span class="line">	itoc:<span class="number">24</span>;	<span class="comment">/* index into the table of contents */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>isub_image</code></p>
<p>The subimage in which the symbol is defined. It is an index into the list of images that make<br>up the umbrella image. If this field is 0, the symbol is in the umbrella image itself. If the image is not an umbrella framework or library, this field is 0.</p>
<p>定义符号的subimage。它是组成雨伞图像的图像列表的索引。如果此字段为0，则符号在伞图像本身中。如果图像不是伞形框架或库，则此字段为0。</p>
</li>
<li><p><code>itoc</code></p>
<p>The symbol index into the table of contents of the image specified by the isub_image field.</p>
<p>由isub_image字段指定的图像目录中的符号索引。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  The two-level namespace hint table provides the dynamic linker with suggested positions to start searching for symbols in the libraries the current image is linked against. </p>
<p>  Every undefined symbol (that is, every symbol of type N_UNDF or N_PBUD) in a two-level namespace image has a corresponding entry in the two-level hint table, at the same index. </p>
<p>  The static linker adds the LC_TWOLEVEL_HINTS load command and the two-level namespace hint table to the output file when building a two-level namespace image. </p>
<p>  By default, the linker does not include the LC_TWOLEVEL_HINTS command or the two-level namespace hint table in an MH_BUNDLE file, because the presence of this load command causes the version of the dynamic linker shipped with Mac OS X v10.0 to crash. If you know the code will run only on Mac OS X v10.1 and later, you should explicitly enable the two-level namespace hints. See the linker documentation for more information.<br>  两级命名空间提示表为动态链接器提供建议的位置，以便开始在当前图像所链接的库中搜索符号。<br>  两级命名空间映像中的每个未定义符号（即，类型为n_undf或n_pbud的每个符号）在两级提示表中的同一索引处都有相应的项。<br>  静态链接器在生成两级命名空间映像时将lc_twowlevel_hints load命令和两级命名空间提示表添加到输出文件中。<br>  默认情况下，链接器不包括mh_捆绑包文件中的lc_two level_hints命令或两级命名空间提示表，因为此加载命令的存在会导致mac os x v10.0附带的动态链接器版本崩溃。如果您知道代码将只在macosxv10.1及更高版本上运行，那么应该显式地启用两级命名空间提示。有关详细信息，请参阅链接器文档。</p>
<ul>
<li><p><strong>lc_str</strong></p>
<p>Defines a variable-length string. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> lc_str &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;	<span class="comment">/* offset to the string */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LP64__</span></span><br><span class="line">	<span class="keyword">char</span>		*ptr;	<span class="comment">/* pointer to the string */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>offset</code></p>
<p>A long integer. A byte offset from the start of the load command that contains this string to<br>the start of the string data.</p>
<p>一个长整数。从包含此字符串的加载命令开始到字符串数据开始的字节偏移量。</p>
</li>
<li><p><code>ptr</code></p>
<p>A pointer to an array of bytes. At runtime, this pointer contains the virtual memory address<br>of the string data. The ptr field is not used in Mach-O files.</p>
<p>指向字节数组的指针。在运行时，此指针包含字符串数据的虚拟内存地址。在mach-o文件中不使用ptr字段。</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>Load commands store variable-length data such as library names using the lc_str data structure. Unless otherwise specified, the data consists of a C string. </p>
<p>The data pointed to is stored just after the load command, and the size is added to the size of the load command. The string should be null terminated; any extra bytes to round up the size should be null. You can also determine the size of the string by subtracting the size of the load command data structure from the cmdsize field of the load command data structure.<br><code>Load Commands</code>使用<code>lc_str</code>数据结构存储可变长度的数据，例如库名称。除非另有说明，否则数据由C字符串组成。<br>指向的数据存储在<code>load command</code>之后，大小将添加到<code>load command</code>的大小中。字符串应以空结尾；要舍入大小的任何额外字节都应为空。还可以通过从加载命令数据结构的cmdSize字段中减去加载命令数据结构的大小来确定字符串的大小。</p>
</li>
</ul>
<ul>
<li><p><strong>dylib</strong></p>
<p>Defines the data used by the dynamic linker to match a shared library against the files that have linked to it. Used exclusively in the dylib_command (page 32) data structure. Declared in<br>/usr/include/mach-o/loader.h.</p>
<p>定义动态链接器用于将共享库与链接到该库的文件匹配的数据</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Dynamicly linked shared libraries are identified by two things.  The</span></span><br><span class="line"><span class="comment"> * pathname (the name of the library as found for execution), and the</span></span><br><span class="line"><span class="comment"> * compatibility version number.  The pathname must match and the compatibility</span></span><br><span class="line"><span class="comment"> * number in the user of the library must be greater than or equal to the</span></span><br><span class="line"><span class="comment"> * library being used.  The time stamp is used to record the time a library was</span></span><br><span class="line"><span class="comment"> * built and copied into user so it can be use to determined if the library used</span></span><br><span class="line"><span class="comment"> * at runtime is exactly the same as used to built the program.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> lc_str  name;			<span class="comment">/* library's path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;			<span class="comment">/* library's build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;		<span class="comment">/* library's current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version;	<span class="comment">/* library's compatibility vers number*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>name</code></p>
<p>A data structure of type lc_str (page 31). Specifies the name of the shared library.</p>
<p>指定共享库的名称 是一个lc_str的结构类型</p>
</li>
<li><p><code>timestamp</code></p>
<p>The date and time when the shared library was built.</p>
<p>创建共享库的日期和时间。</p>
</li>
<li><p><code>current_version</code></p>
<p>The current version of the shared library.</p>
<p>共享库的当前版本</p>
</li>
<li><p><code>compatibility_version</code></p>
<p>The compatibility version of the shared library.</p>
<p>共享库的兼容版本</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>dylib_command</strong></p>
<p>Defines the attributes of the <code>LC_LOAD_DYLIB</code> and <code>LC_ID_DYLIB</code> load commands. Declared in<br>/usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A dynamically linked shared library (filetype == MH_DYLIB in the mach header)</span></span><br><span class="line"><span class="comment"> * contains a dylib_command (cmd == LC_ID_DYLIB) to identify the library.</span></span><br><span class="line"><span class="comment"> * An object that uses a dynamically linked shared library also contains a</span></span><br><span class="line"><span class="comment"> * dylib_command (cmd == LC_LOAD_DYLIB, LC_LOAD_WEAK_DYLIB, or</span></span><br><span class="line"><span class="comment"> * LC_REEXPORT_DYLIB) for each library it uses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,</span></span><br><span class="line"><span class="comment">					   LC_REEXPORT_DYLIB */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dylib</span>	<span class="title">dylib</span>;</span>		<span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to either<code>LC_LOAD_DYLIB</code>,<br><code>LC_LOAD_WEAK_DYLIB</code>, or <code>LC_ID_DYLIB</code>.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to sizeof(dylib_command)<br>plus the size of the data pointed to by the name field of the dylib field.</p>
</li>
<li><p><code>dylib</code></p>
<p>A data structure of type dylib (page 31). Specifies the attributes of the shared library.</p>
<p>dylib类型的数据结构。指定共享库的属性。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  For each shared library that a file links against, the static linker creates an LC_LOAD_DYLIB command and sets its dylib field to the value of the dylib field of the LC_ID_DYLD load command of the target library. All the LC_LOAD_DYLIB commands together form a list that is ordered according to location in the file, earliest LC_LOAD_DYLIB command first. For two-level namespace files, undefined symbol entries in the symbol table refer to their parent shared libraries by index into this list. The index is called a <em>library ordinal</em>, and it is stored in the n_desc field of the nlist (page 39) data structure.<br>  对于文件链接所针对的每个共享库，静态链接器创建一个LC_LOAD_DYLIB命令，并将其dylib字段设置为目标库的LC_ID_DYLD load commands的dylib字段的值。所有LC_LOAD_DYLIB命令一起形成一个列表，该列表根据文件中的位置进行排序，首先是最早的LC_LOAD_DYLIB命令。对于两级命名空间文件，符号表中未定义的符号项通过索引指向该列表中的父共享库。索引称为库序号，它存储在nlist数据结构的n_desc字段中。</p>
<p>  At runtime, the dynamic linker uses the name in the dyld field of the LC_LOAD_DYLIB command to locate the shared library. If it finds the library, the dynamic linker compares the version information of the LC_LOAD_DYLIB load command against the library’s version. For the dynamic linker to successfully link the shared library, the compatibility version of the shared library must be less than or equal to the compatibility version in the LC_LOAD_DYLIB command.</p>
<p>  在运行时，动态链接器使用LC_LOAD_DYLIB命令的dyld字段中的名称来定位共享库。如果找到库，动态链接器将LC_LOAD_DYLIB <code>load commands</code>的版本信息与库的版本进行比较。要使动态链接器成功链接共享库，共享库的兼容版本必须小于或等于LC_LOAD_DYLIB命令中的兼容版本。</p>
<p>  The dynamic linker uses the timestamp to determine whether it can use the prebinding information.<br>  The current version is returned by the function NSVersionOfRunTimeLibrary to allow you to determine the version of the library your program is using.</p>
<p>  动态链接器使用时间戳来确定是否可以使用预绑定信息。函数NSVersionOfRunTimeLibrary返回当前版本，允许您确定程序正在使用的库的版本。</p>
<ul>
<li><p><strong>dylinker_command</strong></p>
<p>Defines the attributes of the <code>LC_LOAD_DYLINKER</code> and <code>LC_ID_DYLINKER</code> load commands. Declared in<br>/usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A program that uses a dynamic linker contains a dylinker_command to identify</span></span><br><span class="line"><span class="comment"> * the name of the dynamic linker (LC_LOAD_DYLINKER).  And a dynamic linker</span></span><br><span class="line"><span class="comment"> * contains a dylinker_command to identify the dynamic linker (LC_ID_DYLINKER).</span></span><br><span class="line"><span class="comment"> * A file can have at most one of these.</span></span><br><span class="line"><span class="comment"> * This struct is also used for the LC_DYLD_ENVIRONMENT load command and</span></span><br><span class="line"><span class="comment"> * contains string for dyld to treat like environment variable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylinker_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_ID_DYLINKER, LC_LOAD_DYLINKER or</span></span><br><span class="line"><span class="comment">					   LC_DYLD_ENVIRONMENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes pathname string */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str    name;		<span class="comment">/* dynamic linker's path name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to either <code>LC_ID_DYLINKER</code> or<br><code>LC_LOAD_DYLINKER</code>.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to sizeof(dylinker_command),<br>plus the size of the data pointed to by the name field.</p>
</li>
<li><p><code>name</code></p>
<p>A data structure of type lc_str (page 31). Specifies the name of the dynamic linker</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>Every executable file that is dynamically linked contains a LC_LOAD_DYLINKER command that specifies the name of the dynamic linker that the kernel must load in order to execute the file. The dynamic linker itself specifies its name using the LC_ID_DYLINKER load command. </p>
<p>每个动态链接的可执行文件都包含一个LC_LOAD_DYLINKER命令，该命令指定内核为了执行文件必须加载的动态链接器的名称。动态链接器本身使用LC_ID_DYLINKER load command指定其名称。</p>
</li>
</ul>
<ul>
<li><p><strong>prebound_dylib_command</strong></p>
<p>Defines the attributes of the <code>LC_PREBOUND_DYLIB</code> load command. For every library that a prebound executable file links to, the static linker adds one LC_PREBOUND_DYLIB command. Declared in<br>/usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A program (filetype == MH_EXECUTE) that is</span></span><br><span class="line"><span class="comment"> * prebound to its dynamic libraries has one of these for each library that</span></span><br><span class="line"><span class="comment"> * the static linker used in prebinding.  It contains a bit vector for the</span></span><br><span class="line"><span class="comment"> * modules in the library.  The bits indicate which modules are bound (1) and</span></span><br><span class="line"><span class="comment"> * which are not (0) from the library.  The bit for module 0 is the low bit</span></span><br><span class="line"><span class="comment"> * of the first byte.  So the bit for the Nth module is:</span></span><br><span class="line"><span class="comment"> * (linked_modules[N/8] &gt;&gt; N%8) &amp; 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">prebound_dylib_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_PREBOUND_DYLIB */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes strings */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str	name;		<span class="comment">/* library's path name */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nmodules;	<span class="comment">/* number of modules in library */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str	linked_modules;	<span class="comment">/* bit vector of linked modules */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to LC_PREBOUND_DYLIB.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to<br>sizeof(prebound_dylib_command) plus the size of the data pointed to by the name and<br>linked_modules fields.</p>
</li>
<li><p><code>name</code></p>
<p>A data structure of type lc_str (page 31). Specifies the name of the prebound shared library.</p>
<p>预绑定共享库的名称</p>
</li>
<li><p><code>nmodules</code></p>
<p>An integer. Specifies the number of modules the prebound shared library contains. The size<br>of the linked_modules string is (nmodules / 8) + (nmodules % 8).</p>
<p>一个整数。指定预绑定共享库包含的模块数。链接的模块字符串的大小为（nmodules/8）+（nmodules%8）</p>
</li>
<li><p><code>linked_modules</code></p>
<p>A data structure of type lc_str (page 31). Usually, this data structure defines the offset of a<br>C string; in this usage, it is a variable-length bitset, containing one bit for each module. Each<br>bit represents whether the corresponding module is linked to a module in the current file, 1<br>for yes, 0 for no. The bit for the first module is the low bit of the first byte</p>
<p>lc_str类型的数据结构（第31页）。通常，此数据结构定义C字符串的偏移量；在这种用法中，它是一个可变长度的位集，每个模块包含一个位。每个位表示对应的模块是否链接到当前文件中的模块，1表示是，0表示否。第一个模块的位是第一个字节的低位</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>thread_command</strong></p>
<p>Defines the attributes of the<code>LC_THREAD</code> and <code>LC_UNIXTHREAD</code> load commands. The data of this command is specific to each architecture and appears in thread_status.h, located in the architecture’s directory in /usr/include/mach. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_THREAD or  LC_UNIXTHREAD */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* total size of this command */</span></span><br><span class="line">	<span class="comment">/* uint32_t flavor		   flavor of thread state */</span></span><br><span class="line">	<span class="comment">/* uint32_t count		   count of uint32_t's in thread state */</span></span><br><span class="line">	<span class="comment">/* struct XXX_thread_state state   thread state for this flavor */</span></span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to <code>LC_THREAD</code> or <code>LC_UNIXTHREAD</code>.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to sizeof(thread_command) </p>
<p>plus the size of the flavor and count fields plus the size of the CPU-specific thread state data structure. </p>
</li>
<li><p><code>flavor</code></p>
<p>Integer specifying the particular flavor of the thread state data structure. See the thread_status.h file for your target architecture.</p>
<p>整数，指定线程状态数据结构的特殊类型。请参阅目标体系结构的thread_status.h文件。</p>
</li>
<li><p><code>count</code></p>
<p>Size of the thread state data, in number of 32-bit integers. The thread state data structure must be fully padded to 32-bit alignment.</p>
<p>线程状态数据的大小，以32位整数为单位。线程状态数据结构必须完全填充为32位对齐。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>routines_command</strong></p>
<p>Defines the attributes of the <code>LC_ROUTINES</code> load command, used in 32-bit architectures. Describes the location of the shared library initialization function, which is a function that the dynamic linker calls before allowing any of the routines in the library to be called. Declared in<br>/usr/include/mach-o/loader.h. See also routines_command_64 </p>
<p>定义32位体系结构中使用的LC_ROUTINES load commands的属性。描述共享库初始化函数的位置，该函数是动态链接器在允许调用库中的任何例程之前调用的函数。在/usr/include/mach-o/loader.h中声明。另请参见例程命令（第36页）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The routines command contains the address of the dynamic shared library </span></span><br><span class="line"><span class="comment"> * initialization routine and an index into the module table for the module</span></span><br><span class="line"><span class="comment"> * that defines the routine.  Before any modules are used from the library the</span></span><br><span class="line"><span class="comment"> * dynamic linker fully binds the module that defines the initialization routine</span></span><br><span class="line"><span class="comment"> * and then calls it.  This gets called before any module initialization</span></span><br><span class="line"><span class="comment"> * routines (used for C++ static constructors) in the library.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">routines_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_ROUTINES */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* total size of this command */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	init_address;	<span class="comment">/* address of initialization routine */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	init_module;	<span class="comment">/* index into the module table that */</span></span><br><span class="line">				        <span class="comment">/*  the init routine is defined in */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved1;</span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved2;</span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved3;</span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved4;</span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved5;</span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved6;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The 64-bit routines command.  Same use as above.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">routines_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_ROUTINES_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* total size of this command */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	init_address;	<span class="comment">/* address of initialization routine */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	init_module;	<span class="comment">/* index into the module table that */</span></span><br><span class="line">					<span class="comment">/*  the init routine is defined in */</span></span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved1;</span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved2;</span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved3;</span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved4;</span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved5;</span><br><span class="line">	<span class="keyword">uint64_t</span>	reserved6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to LC_ROUTINES.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to sizeof(routines_command).</p>
</li>
<li><p><code>init_address</code></p>
<p>An integer specifying the virtual memory address of the initialization function.</p>
<p>指定初始化函数的虚拟内存地址的整数。</p>
</li>
<li><p><code>init_module</code></p>
<p>An integer specifying the index into the module table of the module containing the initialization function.</p>
<p>一个整数，指定包含初始化函数的模块的模块表中的索引。</p>
</li>
<li><p><code>reserved1</code></p>
<p>Reserved for future use. Set this field to 0.</p>
<p>保留以备将来使用。将此字段设置为0</p>
</li>
<li><p><code>reserved2</code></p>
<p>Reserved for future use. Set this field to 0.</p>
</li>
<li><p><code>reserved3</code></p>
<p>Reserved for future use. Set this field to 0.</p>
</li>
<li><p><code>reserved4</code></p>
<p>Reserved for future use. Set this field to 0.</p>
</li>
<li><p><code>reserved5</code></p>
<p>Reserved for future use. Set this field to 0.</p>
</li>
<li><p><code>reserved6</code></p>
<p>Reserved for future use. Set this field to 0.</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>The static linker adds an LC_ROUTINES command when you specify a shared library initialization function using the -init option (see the ld man page for more information).<br>使用-init选项指定共享库初始化函数时，静态链接器会添加LC_ROUTINES命令（有关详细信息，请参阅ld手册页）。</p>
</li>
</ul>
<ul>
<li><p><strong>sub_framework_command</strong></p>
<p>Defines the attributes of the LC_SUB_FRAMEWORK load command. Identifies the umbrella framework of which this file is a subframework. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A dynamically linked shared library may be a subframework of an umbrella</span></span><br><span class="line"><span class="comment"> * framework.  If so it will be linked with "-umbrella umbrella_name" where</span></span><br><span class="line"><span class="comment"> * Where "umbrella_name" is the name of the umbrella framework. A subframework</span></span><br><span class="line"><span class="comment"> * can only be linked against by its umbrella framework or other subframeworks</span></span><br><span class="line"><span class="comment"> * that are part of the same umbrella framework.  Otherwise the static link</span></span><br><span class="line"><span class="comment"> * editor produces an error and states to link against the umbrella framework.</span></span><br><span class="line"><span class="comment"> * The name of the umbrella framework for subframeworks is recorded in the</span></span><br><span class="line"><span class="comment"> * following structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_framework_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SUB_FRAMEWORK */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes umbrella string */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str 	umbrella;	<span class="comment">/* the umbrella framework name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
</li>
<li><p><code>cmdsize</code></p>
</li>
<li><p><code>umbrella</code></p>
<p>A data structure of type lc_str (page 31). Specifies the name of the umbrella framework of<br>which this file is a member.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>sub_umbrella_command</strong></p>
<p>Defines the attributes of the LC_SUB_UMBRELLA load command. Identifies the named framework as a subumbrella of this framework. Unlike a subframework, any client may link to a subumbrella. Declared<br>in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A dynamically linked shared library may be a sub_umbrella of an umbrella</span></span><br><span class="line"><span class="comment"> * framework.  If so it will be linked with "-sub_umbrella umbrella_name" where</span></span><br><span class="line"><span class="comment"> * Where "umbrella_name" is the name of the sub_umbrella framework.  When</span></span><br><span class="line"><span class="comment"> * staticly linking when -twolevel_namespace is in effect a twolevel namespace </span></span><br><span class="line"><span class="comment"> * umbrella framework will only cause its subframeworks and those frameworks</span></span><br><span class="line"><span class="comment"> * listed as sub_umbrella frameworks to be implicited linked in.  Any other</span></span><br><span class="line"><span class="comment"> * dependent dynamic libraries will not be linked it when -twolevel_namespace</span></span><br><span class="line"><span class="comment"> * is in effect.  The primary library recorded by the static linker when</span></span><br><span class="line"><span class="comment"> * resolving a symbol in these libraries will be the umbrella framework.</span></span><br><span class="line"><span class="comment"> * Zero or more sub_umbrella frameworks may be use by an umbrella framework.</span></span><br><span class="line"><span class="comment"> * The name of a sub_umbrella framework is recorded in the following structure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_umbrella_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SUB_UMBRELLA */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sub_umbrella string */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str 	sub_umbrella;	<span class="comment">/* the sub_umbrella framework name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
</li>
<li><p><code>cmdsize</code></p>
</li>
<li><p><code>sub_umbrella</code></p>
<p>A data structure of type lc_str (page 31). Specifies the name of the umbrella framework of<br>which this file is a member.</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>sub_library_command</strong></p>
<p>Defines the attributes of the LC_SUB_LIBRARY load command. Identifies a sublibrary of this framework and marks this framework as an umbrella framework. Unlike a subframework, any client may link to a sublibrary. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A dynamically linked shared library may be a sub_library of another shared</span></span><br><span class="line"><span class="comment"> * library.  If so it will be linked with "-sub_library library_name" where</span></span><br><span class="line"><span class="comment"> * Where "library_name" is the name of the sub_library shared library.  When</span></span><br><span class="line"><span class="comment"> * staticly linking when -twolevel_namespace is in effect a twolevel namespace </span></span><br><span class="line"><span class="comment"> * shared library will only cause its subframeworks and those frameworks</span></span><br><span class="line"><span class="comment"> * listed as sub_umbrella frameworks and libraries listed as sub_libraries to</span></span><br><span class="line"><span class="comment"> * be implicited linked in.  Any other dependent dynamic libraries will not be</span></span><br><span class="line"><span class="comment"> * linked it when -twolevel_namespace is in effect.  The primary library</span></span><br><span class="line"><span class="comment"> * recorded by the static linker when resolving a symbol in these libraries</span></span><br><span class="line"><span class="comment"> * will be the umbrella framework (or dynamic library). Zero or more sub_library</span></span><br><span class="line"><span class="comment"> * shared libraries may be use by an umbrella framework or (or dynamic library).</span></span><br><span class="line"><span class="comment"> * The name of a sub_library framework is recorded in the following structure.</span></span><br><span class="line"><span class="comment"> * For example /usr/lib/libobjc_profile.A.dylib would be recorded as "libobjc".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_library_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SUB_LIBRARY */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes sub_library string */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str 	sub_library;	<span class="comment">/* the sub_library name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><strong>sub_client_command</strong></p>
<p>Defines the attributes of the LC_SUB_CLIENT load command. Specifies the name of a file that is allowed to link to this subframework. This file would otherwise be required to link to the umbrella framework of which this file is a component. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * For dynamically linked shared libraries that are subframework of an umbrella</span></span><br><span class="line"><span class="comment"> * framework they can allow clients other than the umbrella framework or other</span></span><br><span class="line"><span class="comment"> * subframeworks in the same umbrella framework.  To do this the subframework</span></span><br><span class="line"><span class="comment"> * is built with "-allowable_client client_name" and an LC_SUB_CLIENT load</span></span><br><span class="line"><span class="comment"> * command is created for each -allowable_client flag.  The client_name is</span></span><br><span class="line"><span class="comment"> * usually a framework name.  It can also be a name used for bundles clients</span></span><br><span class="line"><span class="comment"> * where the bundle is built with "-client_name client_name".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sub_client_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SUB_CLIENT */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* includes client string */</span></span><br><span class="line">	<span class="keyword">union</span> lc_str 	client;		<span class="comment">/* the client name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Special Considerations</strong> </p>
<p>The ld tool generates a sub_client_command load command in the built product if you pass the option -allowable_client <name>, where <name> is the install name of a framework or the client name of a bundle. See the ld man page, specifically about the options -allowable_client and -client_name, for more information. </p>
<p>如果传递选项-allowable_client<name>，其中<name>是框架的安装名称或捆绑包的客户端名称，则ld工具会在生成的产品中生成一个sub_client_command load commands。有关详细信息，请参阅ld手册页，特别是关于选项-允许的客户机和-客户机名称。</p>
</li>
</ul>
<h2 id="Symbol-Table-and-Related-Data-Structures"><a href="#Symbol-Table-and-Related-Data-Structures" class="headerlink" title="Symbol Table and Related Data Structures"></a>Symbol Table and Related Data Structures</h2><p>Two load commands, LC_SYMTAB and LC_DYSYMTAB, describe the size and location of the symbol<br>tables, along with additional metadata. The other data structures listed in this section represent the<br>symbol tables themselves.</p>
<p>两个加载命令<code>LC_SYMTAB</code>和<code>LC_DYSYMTAB</code>描述了符号表的大小和位置以及其他元数据。本节中列出的其他数据结构表示符号表本身。</p>
<ul>
<li><p><strong>symtab_command</strong></p>
<p>Defines the attributes of the<code>LC_SYMTAB</code> load command. Describes the size and location of the symbol table data structures. Declared in /usr/include/mach-o/loader.h.</p>
<p>定义lc_symtab load commands的属性。描述符号表数据结构的大小和位置。在/usr/include/mach-o/loader.h中声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD</span></span><br><span class="line"><span class="comment"> * "stab" style symbol table information as described in the header files</span></span><br><span class="line"><span class="comment"> * &lt;nlist.h&gt; and &lt;stab.h&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmd;		<span class="comment">/* LC_SYMTAB */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	cmdsize;	<span class="comment">/* sizeof(struct symtab_command) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	symoff;		<span class="comment">/* symbol table offset */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nsyms;		<span class="comment">/* number of symbol table entries */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	stroff;		<span class="comment">/* string table offset */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	strsize;	<span class="comment">/* string table size in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
</li>
<li><p><code>cmdsize</code></p>
</li>
<li><p><code>symoff</code></p>
<p>An integer containing the byte offset from the start of the file to the location of the symbol table entries. The symbol table is an array of nlist (page 39) data structures.</p>
<p>包含从文件开始到符号表项位置的字节偏移量的整数。符号表是一个由nlist(第39页)数据结构组成的数组。</p>
</li>
<li><p><code>nsyms</code></p>
<p>An integer indicating the number of entries in the symbol table.</p>
<p>符号表中条目数</p>
</li>
<li><p><code>stroff</code></p>
<p>An integer containing the byte offset from the start of the image to the location of the string<br>table.</p>
<p>包含从图像开始到字符串表位置的字节偏移量。</p>
</li>
<li><p><code>strsize</code></p>
<p>An integer indicating the size (in bytes) of the string table.</p>
<p>表示字符串表的大小（字节）。</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>LC_SYMTAB should exist in both statically linked and dynamically linked file types. </p>
<p><code>LC_SYMTAB</code>应该同时存在于静态链接和动态链接的文件类型中。</p>
</li>
</ul>
<ul>
<li><p><strong>nlist</strong></p>
<p>Describes an entry in the symbol table for 32-bit architectures. Declared in<br>/usr/include/mach-o/nlist.h. See also nlist_64</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LP64__</span></span><br><span class="line">		<span class="keyword">char</span> *n_name;	<span class="comment">/* for use when in-core */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">uint32_t</span> n_strx;	<span class="comment">/* index into the string table */</span></span><br><span class="line">	&#125; n_un;</span><br><span class="line">	<span class="keyword">uint8_t</span> n_type;		<span class="comment">/* type flag, see below */</span></span><br><span class="line">	<span class="keyword">uint8_t</span> n_sect;		<span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">	<span class="keyword">int16_t</span> n_desc;		<span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">	<span class="keyword">uint32_t</span> n_value;	<span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is the symbol table entry structure for 64-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>n_un</code></p>
<p>A union that holds an index into the string table, n_strx. To specify an empty string (“”), set<br>this value to 0. The n_name field is not used in Mach-O files.</p>
<p>共用体保存着在string table中的index，n_strx。若要指定空字符串（“”），请将此值设置为0。mach-o文件中不使用n_name字段。</p>
</li>
<li><p><code>n_type</code></p>
<p>A byte value consisting of data accessed using four bit masks:</p>
<p>一个字节值，由使用四位掩码访问的数据组成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The n_type field really contains four fields:</span></span><br><span class="line"><span class="comment"> *	unsigned char N_STAB:3,</span></span><br><span class="line"><span class="comment"> *		      N_PEXT:1,</span></span><br><span class="line"><span class="comment"> *		      N_TYPE:3,</span></span><br><span class="line"><span class="comment"> *		      N_EXT:1;</span></span><br><span class="line"><span class="comment"> * which are used via the following masks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_STAB	0xe0  <span class="comment">/* if any of these bits set, a symbolic debugging entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_PEXT	0x10  <span class="comment">/* private external symbol bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_TYPE	0x0e  <span class="comment">/* mask for the type bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_EXT	0x01  <span class="comment">/* external symbol bit, set for external symbols */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Only symbolic debugging entries have some of the N_STAB bits set and if any</span></span><br><span class="line"><span class="comment"> * of these bits are set then it is a symbolic debugging entry (a stab).  In</span></span><br><span class="line"><span class="comment"> * which case then the values of the n_type field (the entire field) are given</span></span><br><span class="line"><span class="comment"> * in &lt;mach-o/stab.h&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Values for N_TYPE bits of the n_type field.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_UNDF	0x0		<span class="comment">/* undefined, n_sect == NO_SECT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_ABS	0x2		<span class="comment">/* absolute, n_sect == NO_SECT */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_SECT	0xe		<span class="comment">/* defined in section number n_sect */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	N_PBUD	0xc		<span class="comment">/* prebound undefined (defined in a dylib) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_INDR	0xa		<span class="comment">/* indirect */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>N_STAB (0xe0)</code>—If any of these 3 bits are set, the symbol is a symbolic debugging table (stab) entry. In that case, the entire n_type field is interpreted as a stab value. See /usr/include/mach-o/stab.h for valid stab values. </p>
<p>如果设置了这3位中的任何一位，则符号是符号调试表（stab）项。在这种情况下，整个n_type字段被解释为stab值。有关有效的stab值，请参见/usr/include/mach-o/stab.h。</p>
</li>
<li><p><code>N_PEXT (0x10)</code>—If this bit is on, this symbol is marked as having limited global scope. When the file is fed to the static linker, it clears the N_EXT bit for each symbol with the N_PEXT bit set. (The ld option -keep_private_externs turns off this behavior.) With Mac OS X GCC, you can use the <strong>private_extern</strong> function attribute to set this bit. </p>
<p>如果该位为开，则该符号被标记为具有有限的全局范围。当文件被馈送到静态链接器时，它会为每个设置了n_-pext位的符号清除n_-ext位。（ld选项-keep_private_externs关闭此行为）使用mac os x gcc，可以使用u private_u extern_uu函数属性设置此位。</p>
</li>
<li><p><code>N_TYPE (0x0e)</code>—These bits define the type of the symbol. </p>
<p>定义符号的类型</p>
</li>
<li><p><code>N_EXT (0x01)</code>—If this bit is on, this symbol is an external symbol, a symbol that is either defined outside this file or that is defined in this file but can be referenced by other files. </p>
<p>如果该位为开，则该符号为外部符号，即在此文件外部定义的，或在此文件中定义但可以被其他文件引用的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>Values for the `N_TYPE` field include: 

- `N_UNDF (0x0)`—The symbol is undefined. Undefined symbols are symbols referenced in this module but defined in a different module. The n_sect field is set to NO_SECT. 

  符号未定义。未定义符号是指在此模块中引用但在其他模块中定义的符号。n_sect字段设置为NO_SECT。

- `N_ABS (0x2)`—The symbol is absolute. The linker does not change the value of an absolute symbol. The n_sect field is set to NO_SECT. 

  符号是绝对的。链接器不会更改绝对符号的值。n_sect字段设置为NO_SECT。

- `N_SECT (0xe)`—The symbol is defined in the section number given in n_sect. 

- `N_PBUD (0xc)`—The symbol is undefined and the image is using a prebound value for the symbol. The n_sect field is set to NO_SECT. 

- `N_INDR ( 0xa)`—The symbol is defined to be the same as another symbol. The n_value field is an index into the string table specifying the name of the other symbol. When that symbol is linked, both this and the other symbol have the same defined type and value. 

  该符号被定义为与另一个符号相同。n_value字段是字符串表的索引，用于指定另一个符号的名称。链接该符号时，此符号和其他符号都具有相同的定义类型和值。</code></pre><ul>
<li><p><code>n_sect</code></p>
<p>An integer specifying the number of the section that this symbol can be found in, or NO_SECT </p>
<p>if the symbol is not to be found in any section of this image. The sections are contiguously numbered across segments, starting from 1, according to the order they appear in the LC_SEGMENT load commands. </p>
<p>一个整数，指定可以在其中找到该符号的节的数目，或NO_SECT<br>如果在图像的任何部分都找不到符号。根据它们在LC_SEGMENT load commands中出现的顺序，分段在分段之间连续编号，从1开始。</p>
</li>
<li><p><code>n_desc</code></p>
<p>A 16-bit value providing additional information about the nature of this symbol for non-stab<br>symbols. The reference flags can be accessed using the REFERENCE_TYPE mask (0xF) and are<br>defined as follows:</p>
<p>一个16位值，为非stab符号提供关于此符号性质的附加信息。可以使用REFERENCE_TYPE掩码(0xF)访问引用标志，定义如下:</p>
</li>
<li><p><code>n_value</code></p>
<p>An integer that contains the value of the symbol. The format of this value is different for each type of symbol table entry (as specified by the n_type field). For the N_SECT symbol type, n_value is the address of the symbol. See the description of the n_type field for information on other possible values.</p>
<p>包含符号值的整数。对于每种类型的符号表条目(由n_type字段指定)，此值的格式是不同的。对于N_SECT符号类型，n_value是符号的地址。有关其他可能值的信息，请参见n_type字段的描述。</p>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  Common symbols must be of type N_UNDF and must have the N_EXT bit set. The n_value for a common symbol is the size (in bytes) of the data of the symbol. In C, a common symbol is a variable that is declared but not initialized in this file. Common symbols can appear only in MH_OBJECT Mach-O files. </p>
<p>  公共符号必须是N_UNDF类型的，并且必须设置N_EXT位。公共符号的n_value是符号数据的大小(以字节为单位)。在C语言中，公共符号是在该文件中声明但未初始化的变量。通用符号只能出现在MH_OBJECT Mach-O文件中。</p>
<ul>
<li><p><strong>dysymtab_command</strong></p>
<p>The data structure for the <code>LC_DYSYMTAB</code> load command. It describes the sizes and locations of the parts of the symbol table used for dynamic linking. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;	<span class="comment">/* LC_DYSYMTAB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;	<span class="comment">/* sizeof(struct dysymtab_command) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The symbols indicated by symoff and nsyms of the LC_SYMTAB load command</span></span><br><span class="line"><span class="comment">     * are grouped into the following three groups:</span></span><br><span class="line"><span class="comment">     *    local symbols (further grouped by the module they are from)</span></span><br><span class="line"><span class="comment">     *    defined external symbols (further grouped by the module they are from)</span></span><br><span class="line"><span class="comment">     *    undefined symbols</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The local symbols are used only for debugging.  The dynamic binding</span></span><br><span class="line"><span class="comment">     * process may have to use them to indicate to the debugger the local</span></span><br><span class="line"><span class="comment">     * symbols for a module that is being bound.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The last two groups are used by the dynamic binding process to do the</span></span><br><span class="line"><span class="comment">     * binding (indirectly through the module table and the reference symbol</span></span><br><span class="line"><span class="comment">     * table when this is a dynamically linked shared library file).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ilocalsym;	<span class="comment">/* index to local symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nlocalsym;	<span class="comment">/* number of local symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iextdefsym;<span class="comment">/* index to externally defined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextdefsym;<span class="comment">/* number of externally defined symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iundefsym;	<span class="comment">/* index to undefined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nundefsym;	<span class="comment">/* number of undefined symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For the for the dynamic binding process to find which module a symbol</span></span><br><span class="line"><span class="comment">     * is defined in the table of contents is used (analogous to the ranlib</span></span><br><span class="line"><span class="comment">     * structure in an archive) which maps defined external symbols to modules</span></span><br><span class="line"><span class="comment">     * they are defined in.  This exists only in a dynamically linked shared</span></span><br><span class="line"><span class="comment">     * library file.  For executable and object modules the defined external</span></span><br><span class="line"><span class="comment">     * symbols are sorted by name and is use as the table of contents.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tocoff;	<span class="comment">/* file offset to table of contents */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ntoc;	<span class="comment">/* number of entries in table of contents */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To support dynamic binding of "modules" (whole object files) the symbol</span></span><br><span class="line"><span class="comment">     * table must reflect the modules that the file was created from.  This is</span></span><br><span class="line"><span class="comment">     * done by having a module table that has indexes and counts into the merged</span></span><br><span class="line"><span class="comment">     * tables for each module.  The module structure that these two entries</span></span><br><span class="line"><span class="comment">     * refer to is described below.  This exists only in a dynamically linked</span></span><br><span class="line"><span class="comment">     * shared library file.  For executable and object modules the file only</span></span><br><span class="line"><span class="comment">     * contains one module so everything in the file belongs to the module.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> modtaboff;	<span class="comment">/* file offset to module table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nmodtab;	<span class="comment">/* number of module table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To support dynamic module binding the module structure for each module</span></span><br><span class="line"><span class="comment">     * indicates the external references (defined and undefined) each module</span></span><br><span class="line"><span class="comment">     * makes.  For each module there is an offset and a count into the</span></span><br><span class="line"><span class="comment">     * reference symbol table for the symbols that the module references.</span></span><br><span class="line"><span class="comment">     * This exists only in a dynamically linked shared library file.  For</span></span><br><span class="line"><span class="comment">     * executable and object modules the defined external symbols and the</span></span><br><span class="line"><span class="comment">     * undefined external symbols indicates the external references.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> extrefsymoff;	<span class="comment">/* offset to referenced symbol table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextrefsyms;	<span class="comment">/* number of referenced symbol table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The sections that contain "symbol pointers" and "routine stubs" have</span></span><br><span class="line"><span class="comment">     * indexes and (implied counts based on the size of the section and fixed</span></span><br><span class="line"><span class="comment">     * size of the entry) into the "indirect symbol" table for each pointer</span></span><br><span class="line"><span class="comment">     * and stub.  For every section of these two types the index into the</span></span><br><span class="line"><span class="comment">     * indirect symbol table is stored in the section header in the field</span></span><br><span class="line"><span class="comment">     * reserved1.  An indirect symbol table entry is simply a 32bit index into</span></span><br><span class="line"><span class="comment">     * the symbol table to the symbol that the pointer or stub is referring to.</span></span><br><span class="line"><span class="comment">     * The indirect symbol table is ordered to match the entries in the section.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirectsymoff; <span class="comment">/* file offset to the indirect symbol table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nindirectsyms;  <span class="comment">/* number of indirect symbol table entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * To support relocating an individual module in a library file quickly the</span></span><br><span class="line"><span class="comment">     * external relocation entries for each module in the library need to be</span></span><br><span class="line"><span class="comment">     * accessed efficiently.  Since the relocation entries can't be accessed</span></span><br><span class="line"><span class="comment">     * through the section headers for a library file they are separated into</span></span><br><span class="line"><span class="comment">     * groups of local and external entries further grouped by module.  In this</span></span><br><span class="line"><span class="comment">     * case the presents of this load command who's extreloff, nextrel,</span></span><br><span class="line"><span class="comment">     * locreloff and nlocrel fields are non-zero indicates that the relocation</span></span><br><span class="line"><span class="comment">     * entries of non-merged sections are not referenced through the section</span></span><br><span class="line"><span class="comment">     * structures (and the reloff and nreloc fields in the section headers are</span></span><br><span class="line"><span class="comment">     * set to zero).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Since the relocation entries are not accessed through the section headers</span></span><br><span class="line"><span class="comment">     * this requires the r_address field to be something other than a section</span></span><br><span class="line"><span class="comment">     * offset to identify the item to be relocated.  In this case r_address is</span></span><br><span class="line"><span class="comment">     * set to the offset from the vmaddr of the first LC_SEGMENT command.</span></span><br><span class="line"><span class="comment">     * For MH_SPLIT_SEGS images r_address is set to the the offset from the</span></span><br><span class="line"><span class="comment">     * vmaddr of the first read-write LC_SEGMENT command.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The relocation entries are grouped by module and the module table</span></span><br><span class="line"><span class="comment">     * entries have indexes and counts into them for the group of external</span></span><br><span class="line"><span class="comment">     * relocation entries for that the module.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For sections that are merged across modules there must not be any</span></span><br><span class="line"><span class="comment">     * remaining external relocation entries for them (for merged sections</span></span><br><span class="line"><span class="comment">     * remaining relocation entries must be local).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> extreloff;	<span class="comment">/* offset to external relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextrel;	<span class="comment">/* number of external relocation entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * All the local relocation entries are grouped together (they are not</span></span><br><span class="line"><span class="comment">     * grouped by their module since they are only used if the object is moved</span></span><br><span class="line"><span class="comment">     * from it staticly link edited address).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> locreloff;	<span class="comment">/* offset to local relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nlocrel;	<span class="comment">/* number of local relocation entries */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cmd</code></p>
<p>Common to all load command structures. For this structure, set to LC_DYSYMTAB.</p>
</li>
<li><p><code>cmdsize</code></p>
<p>Common to all load command structures. For this structure, set to sizeof(dysymtab_command).</p>
</li>
<li><p><code>ilocalsym</code></p>
<p>An integer indicating the index of the first symbol in the group of local symbols.</p>
<p>一个整数，表示本地符号组中第一个符号的索引</p>
</li>
<li><p><code>nlocalsym</code></p>
<p>An integer indicating the total number of symbols in the group of local symbols.</p>
<p>表示本地符号组中符号总数</p>
</li>
<li><p><code>iextdefsym</code></p>
<p>An integer indicating the index of the first symbol in the group of defined external symbols.</p>
<p>一个整数，表示定义的外部符号组中第一个符号的索引。</p>
</li>
<li><p><code>nextdefsym</code></p>
<p>An integer indicating the total number of symbols in the group of defined external symbols.</p>
<p>一个整数，表示定义的外部符号组中的符号总数。</p>
</li>
<li><p><code>iundefsym</code></p>
<p>An integer indicating the index of the first symbol in the group of undefined external symbols.</p>
<p>一个整数，表示未定义外部符号组中第一个符号的索引。</p>
</li>
<li><p><code>nundefsym</code></p>
<p>An integer indicating the total number of symbols in the group of undefined external symbols</p>
<p>表示未定义外部符号组中符号总数</p>
</li>
<li><p><code>tocoff</code></p>
<p>An integer indicating the byte offset from the start of the file to the table of contents data.</p>
<p>一个整数，表示从文件开始到目录数据的字节偏移量。</p>
</li>
<li><p><code>ntoc</code></p>
<p>An integer indicating the number of entries in the table of contents.</p>
<p>表示目录中条目数的整数。</p>
</li>
<li><p><code>modtaboff</code></p>
<p>An integer indicating the byte offset from the start of the file to the module table data.</p>
<p>一个整数，表示从文件开始到模块表数据的字节偏移量。</p>
</li>
<li><p><code>nmodtab</code></p>
<p>An integer indicating the number of entries in the module table.</p>
<p>表示模块表中条目数的整数。</p>
</li>
<li><p><code>extrefsymoff</code></p>
<p>An integer indicating the byte offset from the start of the file to the external reference table<br>data.</p>
<p>一个整数，表示从文件开始到外部引用表数据的字节偏移量。</p>
</li>
<li><p><code>nextrefsyms</code></p>
<p>An integer indicating the number of entries in the external reference table.</p>
<p>表示外部引用表中条目数的整数。</p>
</li>
<li><p><code>indirectsymoff</code></p>
<p>An integer indicating the byte offset from the start of the file to the indirect symbol table data.</p>
<p>一个整数，表示从文件开头到间接符号表数据的字节偏移量。</p>
</li>
<li><p><code>nindirectsyms</code></p>
<p>An integer indicating the number of entries in the indirect symbol table.</p>
<p>指示间接符号表中条目数的整数。</p>
</li>
<li><p><code>extreloff</code></p>
<p>An integer indicating the byte offset from the start of the file to the external relocation table data.</p>
<p>一个整数，表示从文件开始到外部重定位表数据的字节偏移量</p>
</li>
<li><p><code>nextrel</code></p>
<p>An integer indicating the number of entries in the external relocation table.</p>
<p>一个整数，指示外部重新定位表中的条目数</p>
</li>
<li><p><code>locreloff</code></p>
<p>An integer indicating the byte offset from the start of the file to the local relocation table data.</p>
<p>一个整数，表示从文件开始到本地重定位表数据的字节偏移量</p>
</li>
<li><p><code>nlocrel</code></p>
<p>An integer indicating the number of entries in the local relocation table.</p>
<p>一个整数，指示本地重新定位表中的条目数</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>The LC_DYSYMTAB load command contains a set of indexes into the symbol table and a set of file offsets that define the location of several other tables. Fields for tables not used in the file should be set to 0. These tables are described in “Dynamic Code Generation” in <em>Mach-O Programming Topics</em>.<br>LC_DYSYMTAB load command包含符号表中的一组索引和一组文件偏移量，它们定义了其他几个表的位置。文件中未使用的表的字段应设置为0。这些表在<em>Mach-O Programming Topics</em>.中的“Dynamic Code Generation”中进行了描述。</p>
</li>
</ul>
<ul>
<li><p><strong>dylib_table_of_contents</strong></p>
<p>Describes an entry in the table of contents of a dynamic shared library. Declared in<br>/usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a table of contents entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_table_of_contents</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> symbol_index;	<span class="comment">/* the defined external symbol</span></span><br><span class="line"><span class="comment">				   (index into the symbol table) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> module_index;	<span class="comment">/* index into the module table this symbol</span></span><br><span class="line"><span class="comment">				   is defined in */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>symbol_index</code></p>
<p>An index into the symbol table indicating the defined external symbol to which this entry<br>refers.</p>
<p>符号表中的索引，指示此项所引用的已定义外部符号。</p>
</li>
<li><p><code>module_index</code></p>
<p>An index into the module table indicating the module in which this defined external symbol<br>is defined.</p>
<p>模块表中的索引，指示在其中定义此定义的外部符号的模块。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>dylib_module</strong></p>
<p>Describes a module table entry for a dynamic shared library for 32-bit architectures. Declared in<br>/usr/include/mach-o/loader.h. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a module table entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_module</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> module_name;	<span class="comment">/* the module name (index into string table) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iextdefsym;	<span class="comment">/* index into externally defined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextdefsym;	<span class="comment">/* number of externally defined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> irefsym;		<span class="comment">/* index into reference symbol table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nrefsym;		<span class="comment">/* number of reference symbol table entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ilocalsym;		<span class="comment">/* index into symbols for local symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nlocalsym;		<span class="comment">/* number of local symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iextrel;		<span class="comment">/* index into external relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextrel;		<span class="comment">/* number of external relocation entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iinit_iterm;	<span class="comment">/* low 16 bits are the index into the init</span></span><br><span class="line"><span class="comment">				   section, high 16 bits are the index into</span></span><br><span class="line"><span class="comment">			           the term section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ninit_nterm;	<span class="comment">/* low 16 bits are the number of init section</span></span><br><span class="line"><span class="comment">				   entries, high 16 bits are the number of</span></span><br><span class="line"><span class="comment">				   term section entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>			<span class="comment">/* for this module address of the start of */</span></span><br><span class="line">	objc_module_info_addr;  <span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>			<span class="comment">/* for this module size of */</span></span><br><span class="line">	objc_module_info_size;	<span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">&#125;;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/* a 64-bit module table entry */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_module_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> module_name;	<span class="comment">/* the module name (index into string table) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iextdefsym;	<span class="comment">/* index into externally defined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextdefsym;	<span class="comment">/* number of externally defined symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> irefsym;		<span class="comment">/* index into reference symbol table */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nrefsym;		<span class="comment">/* number of reference symbol table entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ilocalsym;		<span class="comment">/* index into symbols for local symbols */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nlocalsym;		<span class="comment">/* number of local symbols */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iextrel;		<span class="comment">/* index into external relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nextrel;		<span class="comment">/* number of external relocation entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> iinit_iterm;	<span class="comment">/* low 16 bits are the index into the init</span></span><br><span class="line"><span class="comment">				   section, high 16 bits are the index into</span></span><br><span class="line"><span class="comment">				   the term section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ninit_nterm;      <span class="comment">/* low 16 bits are the number of init section</span></span><br><span class="line"><span class="comment">				  entries, high 16 bits are the number of</span></span><br><span class="line"><span class="comment">				  term section entries */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>			<span class="comment">/* for this module size of */</span></span><br><span class="line">        objc_module_info_size;	<span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>			<span class="comment">/* for this module address of the start of */</span></span><br><span class="line">        objc_module_info_addr;	<span class="comment">/*  the (__OBJC,__module_info) section */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>module_name</code></p>
<p>An index to an entry in the string table indicating the name of the module.</p>
<p>指向字符串表中指示模块名称的项的索引。</p>
</li>
<li><p><code>iextdefsym</code></p>
<p>The index into the symbol table of the first defined external symbol provided by this module.</p>
<p>此模块提供的第一个定义的外部符号的符号表索引。</p>
</li>
<li><p><code>nextdefsym</code></p>
<p>The number of defined external symbols provided by this module.</p>
<p>此模块提供的已定义外部符号的数目</p>
</li>
<li><p><code>irefsym</code></p>
<p>The index into the external reference table of the first entry provided by this module.</p>
<p>此模块提供的第一个条目的外部引用表的索引</p>
</li>
<li><p><code>nrefsym</code></p>
<p>The number of external reference entries provided by this module.</p>
<p>此模块提供的外部引用条目数。</p>
</li>
<li><p><code>ilocalsym</code></p>
<p>The index into the symbol table of the first local symbol provided by this module.</p>
<p>此模块提供的第一个本地符号的符号表索引。</p>
</li>
<li><p><code>nlocalsym</code></p>
<p>The number of local symbols provided by this module.</p>
<p>此模块提供的本地符号数。</p>
</li>
<li><p><code>iextrel</code></p>
<p>The index into the external relocation table of the first entry provided by this module.</p>
<p>此模块提供的第一个条目的外部重新定位表的索引</p>
</li>
<li><p><code>nextrel</code></p>
<p>The number of entries in the external relocation table that are provided by this module.</p>
<p>此模块提供的外部重新定位表中的条目数。</p>
</li>
<li><p><code>iinit_iterm</code></p>
<p>Contains both the index into the module initialization section (the low 16 bits) and the index into the module termination section (the high 16 bits) to the pointers for this module.</p>
<p>包含指向模块初始化部分（低16位）的索引和指向此模块指针的模块终止部分（高16位）的索引。</p>
</li>
<li><p><code>ninit_nterm</code></p>
<p>Contains both the number of pointers in the module initialization (the low 16 bits) and the<br>number of pointers in the module termination section (the high 16 bits) for this module.</p>
<p>包含模块初始化中的指针数（低16位）和此模块的模块终止部分中的指针数（高16位）。</p>
</li>
<li><p><code>objc_module_info_addr</code></p>
<p>The statically linked address of the start of the data for this module in the __module_info section in the __OBJC segment.</p>
<p>在objc段中的模块信息部分中，此模块的数据起始的静态链接地址。</p>
</li>
<li><p><code>objc_module_info_size</code></p>
<p>The number of bytes of data for this module that are used in the __module_info section in the __OBJC segment.</p>
<p>此模块在objc段中的模块信息部分中使用的数据字节数。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>dylib_reference</strong></p>
<p>Defines the attributes of an external reference table entry for the external reference entries provided by a module in a shared library. Declared in /usr/include/mach-o/loader.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * The entries in the reference symbol table are used when loading the module</span></span><br><span class="line"><span class="comment"> * (both by the static and dynamic link editors) and if the module is unloaded</span></span><br><span class="line"><span class="comment"> * or replaced.  Therefore all external symbols (defined and undefined) are</span></span><br><span class="line"><span class="comment"> * listed in the module's reference table.  The flags describe the type of</span></span><br><span class="line"><span class="comment"> * reference that is being made.  The constants for the flags are defined in</span></span><br><span class="line"><span class="comment"> * &lt;mach-o/nlist.h&gt; as they are also used for symbol table entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_reference</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> isym:<span class="number">24</span>,		<span class="comment">/* index into the symbol table */</span></span><br><span class="line">    		  flags:<span class="number">8</span>;	<span class="comment">/* flags to indicate the type of reference */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>isym</code></p>
<p>An index into the symbol table for the symbol being referenced</p>
<p>符号表中被引用符号的索引</p>
</li>
<li><p><code>flags</code></p>
<p>A constant for the type of reference being made. Use the same REFERENCE_FLAG constants as described in the nlist (page 39) structure description.</p>
<p>引用类型的常量。使用与nlist(第39页)结构描述中描述的相同的REFERENCE_FLAG常量。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Relocation-Data-Structures"><a href="#Relocation-Data-Structures" class="headerlink" title="Relocation Data Structures"></a>Relocation Data Structures</h2><p><strong>Relocation</strong> is the process of moving symbols to a different address. When the static linker moves a<br>symbol (a function or an item of data) to a different address, it needs to change all the references to<br>that symbol to use the new address. The <strong>relocation entries</strong> in a Mach-O file contain offsets in the file<br>to addresses that need to be relocated when the contents of the file are relocated. The addresses stored<br>in CPU instructions can be absolute or relative. Each relocation entry specifies the exact format of the<br>address. When creating the intermediate object file, the compiler generates one or more relocation<br>entries for every instruction that contains an address. Because relocation to symbols at fixed addresses,<br>and to relative addresses for position independent references, does not occur at runtime, the static<br>linker typically removes some or all the relocation entries when building the final product.</p>
<p>重定位是将符号移动到另一个地址的过程。当静态链接器将符号(函数或数据项)移动到另一个地址时，需要更改对该符号的所有引用，以使用新地址。Mach-O文件中的重定位条目包含文件中的偏移量，这些偏移量指向当文件内容重定位时需要重定位的地址。CPU指令中存储的地址可以是绝对地址，也可以是相对地址。每个重定位条目指定地址的确切格式。在创建中间对象文件时，编译器为包含地址的每条指令生成一个或多个重定位项。由于在运行时不会对固定地址的符号和位置独立引用的相对地址进行重定位，因此静态链接器通常会在构建最终产品时删除部分或所有重定位项。</p>
<blockquote>
<p>Note: In the Mac OS X x86-64 environment scattered relocations are not used. Compiler-generated code uses mostly external relocations, in which the r_extern bit is set to 1 and the r_symbolnum field contains the symbol-table index of the target label.</p>
<p>注意:在Mac OS X x86-64环境中不使用分散重定位。编译器生成的代码主要使用外部重定位，其中r_extern位设置为1,r_symbolnum字段包含目标标签的符号表索引。</p>
</blockquote>
<ul>
<li><p><strong>relocation_info</strong></p>
<p>Describes an item in the file that uses an address that needs to be updated when the address is changed.<br>Declared in /usr/include/mach-o/reloc.h.</p>
<p>描述文件中使用地址的项，该地址在地址更改时需要更新。在/usr/include/mach-o/reloc.h中声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Format of a relocation entry of a Mach-O file.  Modified from the 4.3BSD</span></span><br><span class="line"><span class="comment"> * format.  The modifications from the original format were changing the value</span></span><br><span class="line"><span class="comment"> * of the r_symbolnum field for "local" (r_extern == 0) relocation entries.</span></span><br><span class="line"><span class="comment"> * This modification is required to support symbols in an arbitrary number of</span></span><br><span class="line"><span class="comment"> * sections not just the three sections (text, data and bss) in a 4.3BSD file.</span></span><br><span class="line"><span class="comment"> * Also the last 4 bits have had the r_type tag added to them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">relocation_info</span> &#123;</span></span><br><span class="line">   <span class="keyword">int32_t</span>	r_address;	<span class="comment">/* offset in the section to what is being</span></span><br><span class="line"><span class="comment">				   relocated */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>     r_symbolnum:<span class="number">24</span>,	<span class="comment">/* symbol index if r_extern == 1 or section</span></span><br><span class="line"><span class="comment">				   ordinal if r_extern == 0 */</span></span><br><span class="line">		r_pcrel:<span class="number">1</span>, 	<span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">		r_length:<span class="number">2</span>,	<span class="comment">/* 0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">		r_extern:<span class="number">1</span>,	<span class="comment">/* does not include value of sym referenced */</span></span><br><span class="line">		r_type:<span class="number">4</span>;	<span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>r_address</code></p>
<p>In MH_OBJECT files, this is an offset from the start of the section to the item containing the address requiring relocation. If the high bit of this field is set (which you can check using the R_SCATTERED bit mask), the relocation_info structure is actually a scattered_relocation_info (page 52) structure. </p>
<p>In images used by the dynamic linker, this is an offset from the virtual memory address of the data of the first segment_command (page 20) that appears in the file (not necessarily the one with the lowest address). For images with the MH_SPLIT_SEGS flag set, this is an offset from the virtual memory address of data of the first read/write segment_command (page 20). </p>
<p>在MH_OBJECT文件中，这是从节的开始到包含需要重新定位的地址的项的偏移量。如果设置了该字段的高位(可以使用r_scatter位掩码检查)，则relocation_info结构实际上是scattered_relocation_info(第52页)结构。<br>在动态链接器使用的图像中，这是与文件中出现的第一个segment_command(第20页)的数据的虚拟内存地址的偏移量(不一定是地址最低的那个)。对于设置了MH_SPLIT_SEGS标志的图像，这是第一个读/写段_command(第20页)数据的虚拟内存地址的偏移量。</p>
</li>
<li><p><code>r_symbolnum</code></p>
<p>Indicates either an index into the symbol table (when the r_extern field is set to 1) or a section<br>number (when the r_extern field is set to 0). As previously mentioned, sections are ordered<br>from 1 to 255 in the order in which they appear in the LC_SEGMENT load commands. This field<br>is set to R_ABS for relocation entries for absolute symbols, which need no relocation.</p>
<p>表示符号表中的索引(当r_extern字段设置为1时)或节号(当r_extern字段设置为0时)。这个字段被设置为R_ABS，用于绝对符号的重新定位条目，绝对符号不需要重新定位。</p>
</li>
<li><p><code>r_pcrel</code></p>
<p>Indicates whether the item containing the address to be relocated is part of a CPU instruction that uses PC-relative addressing. </p>
<p>For addresses contained in PC-relative instructions, the CPU adds the address of the instruction to the address contained in the instruction. </p>
<p>指示包含要重新定位的地址的项是否属于使用pc相对寻址的CPU指令的一部分。<br>对于pc相关指令中包含的地址，CPU将指令的地址添加到指令中包含的地址中。</p>
</li>
<li><p><code>r_length</code></p>
<p>Indicates the length of the item containing the address to be relocated. The following table lists<br>r_length values and the corresponding address length.</p>
<p>指示包含要重新定位的地址的项的长度。下表列出了r_length值和相应的地址长度。</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Address length</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1 byte</td>
</tr>
<tr>
<td>1</td>
<td>2 bytes</td>
</tr>
<tr>
<td>2</td>
<td>4 bytes</td>
</tr>
<tr>
<td>3</td>
<td>4 bytes. See description for the PPC_RELOC_BR14 r_type in<br/>scattered_relocation_info (page 52).</td>
</tr>
</tbody></table>
</li>
<li><p><code>r_extern</code></p>
<p>Indicates whether the r_symbolnum field is an index into the symbol table (1) or a section<br>number (0).</p>
<p>指示r_symbolnum字段是符号表(1)的索引还是节号(0)的索引。</p>
</li>
<li><p><code>r_type</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>scattered_relocation_info</strong> </p>
<p>Describes an item in the file—using a nonzero constant in its relocatable expression or two addresses in its relocatable expression—that needs to be updated if the addresses that it uses are changed. This information is needed to reconstruct the addresses that make up the relocatable expression’s value in order to change the addresses independently of each other. Declared in /usr/include/mach-o/reloc.h. </p>
<p>在可重定位表达式中使用非零常量或在可重定位表达式中使用两个地址来描述文件中的项——如果使用的地址发生更改，则需要更新这些常量。需要此信息来重构构成可重定位表达式值的地址，以便独立地更改地址。中声明/usr/include/mach-o/reloc.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scattered_relocation_info</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __BIG_ENDIAN__</span></span><br><span class="line">   <span class="keyword">uint32_t</span>	r_scattered:<span class="number">1</span>,	<span class="comment">/* 1=scattered, 0=non-scattered (see above) */</span></span><br><span class="line">		r_pcrel:<span class="number">1</span>, 	<span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">		r_length:<span class="number">2</span>,	<span class="comment">/* 0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">		r_type:<span class="number">4</span>,	<span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">   		r_address:<span class="number">24</span>;	<span class="comment">/* offset in the section to what is being</span></span><br><span class="line"><span class="comment">				   relocated */</span></span><br><span class="line">   <span class="keyword">int32_t</span>	r_value;	<span class="comment">/* the value the item to be relocated is</span></span><br><span class="line"><span class="comment">				   refering to (without any offset added) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __BIG_ENDIAN__ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LITTLE_ENDIAN__</span></span><br><span class="line">   <span class="keyword">uint32_t</span></span><br><span class="line">   		r_address:<span class="number">24</span>,	<span class="comment">/* offset in the section to what is being</span></span><br><span class="line"><span class="comment">				   relocated */</span></span><br><span class="line">		r_type:<span class="number">4</span>,	<span class="comment">/* if not 0, machine specific relocation type */</span></span><br><span class="line">		r_length:<span class="number">2</span>,	<span class="comment">/* 0=byte, 1=word, 2=long, 3=quad */</span></span><br><span class="line">		r_pcrel:<span class="number">1</span>, 	<span class="comment">/* was relocated pc relative already */</span></span><br><span class="line">		r_scattered:<span class="number">1</span>;	<span class="comment">/* 1=scattered, 0=non-scattered (see above) */</span></span><br><span class="line">   <span class="keyword">int32_t</span>	r_value;	<span class="comment">/* the value the item to be relocated is</span></span><br><span class="line"><span class="comment">				   refering to (without any offset added) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __LITTLE_ENDIAN__ */</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>r_scattered</code></p>
<p>If this bit is 0, this structure is actually a relocation_info (page 49) structure.</p>
<p>如果这个位是0，那么这个结构实际上是一个relocation_info(第49页)结构。</p>
</li>
<li><p><code>r_address</code></p>
<p>In MH_OBJECT files, this is an offset from the start of the section to the item containing the address requiring relocation. If the high bit of this field is clear (which you can check using the R_SCATTERED bit mask), this structure is actually a relocation_info (page 49) structure. </p>
<p>In images used by the dynamic linker, this is an offset from the virtual memory address of the data of the first segment_command (page 20) that appears in the file (not necessarily the one with the lowest address). For images with the MH_SPLIT_SEGS flag set, this is an offset from the virtual memory address of data of the first read/write segment_command (page 20). </p>
<p>Since this field is only 24 bits long, the offset in this field can never be larger than 0x00FFFFFF, thus limiting the size of the relocatable contents of this image to 16 megabytes. </p>
<p>在MH_OBJECT文件中，这是从节的开始到包含需要重新定位的地址的项的偏移量。如果这个字段的高位是清除的(可以使用r_scatter位掩码检查)，那么这个结构实际上是一个relocation_info(第49页)结构。<br>在动态链接器使用的图像中，这是与文件中出现的第一个segment_command(第20页)的数据的虚拟内存地址的偏移量(不一定是地址最低的那个)。对于设置了MH_SPLIT_SEGS标志的图像，这是第一个读/写段_command(第20页)数据的虚拟内存地址的偏移量。<br>由于该字段只有24位长，因此该字段中的偏移量永远不能大于0x00FFFFFF，从而将此图像的可重定位内容的大小限制为16 mb。</p>
</li>
<li><p><code>r_pcrel</code></p>
<p>Indicates whether the item containing the address to be relocated is part of a CPU instruction that uses PC-relative addressing. </p>
<p>For addresses contained in PC-relative instructions, the CPU adds the address of the instruction to the address contained in the instruction. </p>
<p>指示包含要重新定位的地址的项是否属于使用pc相对寻址的CPU指令的一部分。<br>对于pc相关指令中包含的地址，CPU将指令的地址添加到指令中包含的地址中。</p>
</li>
<li><p><code>r_length</code></p>
<p>Indicates the length of the item containing the address to be relocated. A value of 0 indicates<br>a single byte; a value of 1 indicates a 2-byte address, and a value of 2 indicates a 4-byte address.</p>
<p>指示包含要重新定位的地址的项的长度。值为0表示单个字节;值1表示2字节地址，值2表示4字节地址。</p>
</li>
<li><p><code>r_type</code></p>
<p>Indicates the type of relocation to be performed. Possible values for this field are shared between<br>this structure and the relocation_info data structure; see the description of the r_type field<br>in the relocation_info (page 49) data structure for more details.</p>
<p>指示要执行的重定位类型。这个字段的可能值在这个结构和relocation_info数据结构之间共享;有关详细信息，请参阅relocation_info(第49页)数据结构中r_type字段的描述。</p>
</li>
<li><p><code>r_value</code></p>
<p>The address of the relocatable expression for the item in the file that needs to be updated if the<br>address is changed. For relocatable expressions with the difference of two section addresses,<br>the address from which to subtract (in mathematical terms, the minuend) is contained in the<br>first relocation entry and the address to subtract (the subtrahend) is contained in the second<br>relocation entry.</p>
<p>如果地址更改，则需要更新文件中项的可重定位表达式的地址。对于两个节地址不同的可重定位表达式，要减去的地址(数学术语为被减数)包含在第一个重定位项中，要减去的地址(减数)包含在第二个重定位项中。</p>
</li>
</ul>
<p><strong>Discussion</strong> </p>
<p>Mach-O relocation data structures support two types of relocatable expressions in machine code and data: </p>
<p>Mach-O重定位数据结构支持两种类型的可重定位表达式:</p>
<ul>
<li><p><strong>Symbol address + constant</strong>. The most typical form of relocation is referencing a symbol’s address with no constant added. In this case, the value of the constant expression is 0. </p>
<p>最典型的重定位形式是引用没有添加常量的符号地址。在本例中，常量表达式的值为0。</p>
</li>
<li><p><strong>Address of section y</strong> <strong>–</strong> <strong>address of section x + constant</strong>. The section difference form of relocation. This form of relocation supports position-independent code. </p>
<p>节差形式的移位。这种形式的重新定位支持与位置无关的代码。</p>
</li>
</ul>
</li>
</ul>
<h2 id="Static-Archive-Libraries"><a href="#Static-Archive-Libraries" class="headerlink" title="Static Archive Libraries"></a>Static Archive Libraries</h2><p>This section describes the file format used for static archive libraries. Mac OS X uses a format derived from the original BSD static archive library format, with a few minor additions. See the discussion for the ranlib data structure for more information. </p>
<p>本节描述用于静态存档库的文件格式。Mac OS X使用的格式是从原始的BSD静态存档库格式派生出来的，只添加了一些小功能。有关更多信息，请参阅ranlib数据结构的讨论。</p>
<ul>
<li><p><strong>ranlib</strong> </p>
<p>Defines the attributes of a static archive library symbol table entry. Declared in /usr/include/mach-o/ranlib.h. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure of the __.SYMDEF table of contents for an archive.</span></span><br><span class="line"><span class="comment"> * __.SYMDEF begins with a uint32_t giving the size in bytes of the ranlib</span></span><br><span class="line"><span class="comment"> * structures which immediately follow, and then continues with a string</span></span><br><span class="line"><span class="comment"> * table consisting of a uint32_t giving the number of bytes of strings which</span></span><br><span class="line"><span class="comment"> * follow and then the strings themselves.  The ran_strx fields index the</span></span><br><span class="line"><span class="comment"> * string table whose first byte is numbered 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>	<span class="title">ranlib</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="keyword">uint32_t</span>	ran_strx;	<span class="comment">/* string table index of */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __LP64__</span></span><br><span class="line">	<span class="keyword">char</span>		*ran_name;	<span class="comment">/* symbol defined by */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; ran_un;</span><br><span class="line">    <span class="keyword">uint32_t</span>		ran_off;	<span class="comment">/* library member at this offset */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong> </p>
<ul>
<li><p><code>ran_strx</code></p>
<p>The index number (zero-based) of the string in the string table that follows the array of ranlib data structures. </p>
<p>在ranlib数据结构数组后面的字符串表中字符串的索引号(从零开始)。</p>
</li>
<li><p><code>ran_name</code></p>
<p>The byte offset, from the start of the file, at which the symbol name can be found. This field is not used in Mach-O files. </p>
<p>从文件开始的字节偏移量，在该偏移量处可以找到符号名。此字段在Mach-O文件中不使用。</p>
</li>
<li><p><code>ran_off</code></p>
<p>The byte offset, from the start of the file, at which the header line for the member containing this symbol can be found. </p>
<p>从文件开始的字节偏移量，在此位置可以找到包含此符号的成员的头行。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  A static archive library begins with the file identifier string !<arch>, followed by a newline character (ASCII value 0x0A). The file identifier string is followed by a series of member files. Each member consists of a fixed-length header line followed by the file data. The header line is 60 bytes long and is divided into five fixed-length fields, as shown in this example header line: </p>
<p>  静态存档库以文件标识符字符串!<arch>开始，后跟一个换行符(ASCII值0x0A)。文件标识符字符串后面跟着一系列成员文件。每个成员由一个固定长度的头行和文件数据组成。头行为60字节长，分为5个固定长度的字段，如下例头行所示:</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grapple.c       999514211   501   20    100644  167       `</span><br></pre></td></tr></table></figure>

<p>  The last 2 bytes of the header line are a grave accent (`) character (ASCII value 0x60) and a newline<br>  character. All header fields are defined in ASCII and padded with spaces to the full length of the field.<br>  All fields are defined in decimal notation, except for the file mode field, which is defined in octal.<br>  These are the descriptions for each field:</p>
<p>  头行最后两个字节是一个重重音(‘)字符(ASCII值0x60)和一个换行字符。所有头字段都是用ASCII定义的，并用空格填充到字段的完整长度。所有字段都是用十进制记数法定义的，文件模式字段除外，它是用八进制定义的。以下是每个领域的描述:</p>
<ul>
<li><p>The name field (16 bytes) contains the name of the file. If the name is either longer than 16 bytes or contains a space character, the actual name should be written directly after the header line and the name field should contain the string #1/ followed by the length. To keep the archive entries aligned to 8 byte boundaries, the length of the name that follows the #1/ is rounded to 8 bytes and the name that follows the header is padded with null bytes. </p>
<p>name字段(16字节)包含文件的名称。如果名称大于16字节或包含空格字符，则实际名称应该直接写在标题行之后，name字段应该包含字符串#1/后跟长度。为了使归档条目对齐到8个字节的边界，#1/后面的名称的长度四舍五入为8个字节，头部后面的名称用空字节填充。</p>
</li>
<li><p>The modified date field (12 bytes) is taken from the st_time field returned by the stat system call. </p>
<p>修改后的日期字段(12字节)取自stat系统调用返回的st_time字段。</p>
</li>
<li><p>The user ID field (6 bytes) is taken from the st_uid field returned by the stat system call. </p>
<p>用户ID字段(6字节)取自stat系统调用返回的st_uid字段。</p>
</li>
<li><p>The group ID field (6 bytes) is taken from the st_gid field returned by the stat system call. </p>
<p>组ID字段(6字节)取自stat系统调用返回的st_gid字段。</p>
</li>
<li><p>The file mode field (8 bytes) is taken from the st_mode field returned by the stat system call. This field is written in octal notation. </p>
<p>文件模式字段(8字节)取自stat系统调用返回的st_mode字段。这个字段用八进制符号表示。</p>
</li>
<li><p>The file size field (8 bytes) is taken from the st_size field returned by the stat system call. </p>
<p>文件大小字段(8字节)取自stat系统调用返回的st_size字段。</p>
<p>The first member in a static archive library is always the symbol table describing the contents of the rest of the member files. This member is always called either <strong>.SYMDEF or __.SYMDEF SORTED (note the two leading underscores and the period). The name used depends on the sort order of the symbol table. The older variant—</strong>.SYMDEF—contains entries in the same order that they appear in the object files. The newer variant—__.SYMDEF SORTED— contains entries in alphabetical order, which allows the static linker to load the symbols faster. </p>
<p>静态存档库中的第一个成员总是描述其余成员文件内容的符号表。这个成员总是被称为<strong>。SYMDEF或</strong>。SYMDEF排序(注意两个前导下划线和句号)。使用的名称取决于符号表的排序顺序。<strong>年长的变体。symdef -包含与它们在目标文件中出现的顺序相同的条目。</strong>新的变体。按字母顺序包含条目，这允许静态链接器更快地加载符号。</p>
</li>
</ul>
<p>  The <strong>.SYMDEF and .</strong>SORTED SYMDEF archive members contain an array of ranlib data structures preceded by the length in bytes (a long integer, 4 bytes) of the number of items in the array. The array is followed by a string table of null-terminated strings, which are preceded by the length in bytes of the entire string table (again, a 4-byte long integer). </p>
<p>  __。已排序的SYMDEF archive成员包含一个ranlib数据结构数组，前面是数组中项数的字节长度(一个长整数，4个字节)。数组后面是一个以null结尾的字符串字符串表，它的前面是整个字符串表的字节长度(同样是一个4字节长的整数)。</p>
<p>  The string table is an array of C strings, each terminated by a null byte.<br>   The ranlib declarations can be found in /usr/include/mach-o/ranlib.h. </p>
<p>  <strong>Special Considerations</strong> </p>
<p>  Prior to the advent of libtool, a tool called ranlib was used to generate the symbol table. ranlib has since been integrated into libtool. See the man page for libtool for more information. </p>
<p>  在libtool出现之前，使用了一个名为ranlib的工具来生成符号表。ranlib已经集成到libtool中。有关更多信息，请参见libtool的手册页。</p>
<h2 id="Universal-Binaries-32-bit-64-bit-PowerPC-Binaries"><a href="#Universal-Binaries-32-bit-64-bit-PowerPC-Binaries" class="headerlink" title="Universal Binaries 32-bit/64-bit PowerPC Binaries"></a>Universal Binaries 32-bit/64-bit PowerPC Binaries</h2><p>The standard development tools accept as parameters two kinds of binaries: </p>
<p>标准开发工具接受两种二进制文件作为参数:</p>
<ul>
<li><p>Object files targeted at one architecture. These include Mach-O files, static libraries, and dynamic libraries. </p>
<p>目标文件针对一个体系结构。其中包括Mach-O文件、静态库和动态库。</p>
</li>
<li><p>Binaries targeted at more than one architecture. These binaries contain compiled code and data for one of these system types: </p>
<p>针对多个体系结构的二进制文件。这些二进制文件包含以下系统类型的编译代码和数据:</p>
<ul>
<li><p>PowerPC-based (32-bit and 64-bit) Macintosh computers. Binaries that contain code for both<br>32-bit and 64-bit PowerPC-based Macintosh computers are are known as <strong>PPC/PPC64 binaries</strong>.</p>
<p>基于powerpc(32位和64位)的Macintosh计算机。包含两者代码的二进制文件<br>基于32位和64位powerpc的Macintosh计算机被称为<strong>PPC/PPC64二进制文件</strong>。</p>
</li>
<li><p>Intel-based and PowerPC-based (32-bit, 64-bit, or both) Macintosh computers. Binaries that<br>contain code for both Intel-based and PowerPC-based Macintosh computers are known as<br><strong>universal binaries</strong>.</p>
<p>基于intel和基于powerpc(32位、64位或两者都有)的Macintosh计算机。二进制文件<br>包含基于intel和基于powerpc的Macintosh计算机的代码 通用二进制文件</p>
</li>
</ul>
<p>Each object file is stored as a continuous set of bytes at an offset from the beginning of the binary.<br>They use a simple archive format to store the two object files with a special header at the beginning<br>of the file to allow the various runtime tools to quickly find the code appropriate for the current<br>architecture.</p>
<p>每个目标文件都存储为一组连续的字节，以二进制文件开头的偏移量为单位。它们使用一种简单的归档格式来存储这两个目标文件，并在文件的开头使用一个特殊的头，以允许各种运行时工具快速找到适合当前体系结构的代码。</p>
</li>
</ul>
<p>A binary that contains code for more than one architecture always begins with a fat_header (page<br>56) data structure, followed by two fat_arch (page 56) data structures and the actual data for the<br>architectures contained in the file. All data in these data structures is stored in big-endian byte order.</p>
<p>包含多个体系结构代码的二进制文件总是以fat_header(第56页)数据结构开始，然后是两个fat_arch(第56页)数据结构和文件中包含的体系结构的实际数据。这些数据结构中的所有数据都以大端字节顺序存储。</p>
<ul>
<li><p><strong>fat_header</strong></p>
<p>Defines the layout of a binary that contains code for more than one architecture. Declared in the<br>header /usr/include/mach-o/fat.h.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC	0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM	0xbebafeca	<span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* FAT_MAGIC or FAT_MAGIC_64 */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	nfat_arch;	<span class="comment">/* number of structs that follow */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>magic</code></p>
<p>An integer containing the value 0xCAFEBABE in big-endian byte order format. On a big-endian<br>host CPU, this can be validated using the constant FAT_MAGIC; on a little-endian host CPU, it<br>can be validated using the constant FAT_CIGAM.</p>
<p>包含值0xCAFEBABE的整数，采用大端字节顺序格式。在大端主机CPU上，可以使用常量FAT_MAGIC验证这一点;在little-endian主机CPU上，可以使用常量FAT_CIGAM验证它。</p>
</li>
<li><p><code>nfat_arch</code></p>
<p>An integer specifying the number of fat_arch (page 56) data structures that follow. This is<br>the number of architectures contained in this binary.</p>
<p>一个整数，指定后面的fat_arch(第56页)数据结构的数量。这是这个二进制文件中包含的体系结构的数量。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  The fat_header data structure is placed at the start of a binary that contains code for multiple architectures. Directly following the fat_header data structure is a set of fat_arch (page 56) data structures, one for each architecture included in the binary. </p>
<p>  Regardless of the content this data structure describes, all its fields are stored in big-endian byte order. </p>
<p>  fat_header数据结构位于包含多个体系结构代码的二进制文件的开头。直接跟随fat_header数据结构的是一组fat_arch(第56页)数据结构，每个结构都包含在二进制文件中。<br>  不管这个数据结构描述的内容是什么，它的所有字段都以大端字节顺序存储。</p>
<ul>
<li><p><strong>fat_arch</strong></p>
<p>Describes the location within the binary of an object file targeted at a single architecture. Declared in /usr/include/mach-o/fat.h.</p>
<p>描述以单一架构为目标的目标文件二进制文件中的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier (int) */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier (int) */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	offset;		<span class="comment">/* file offset to this object file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	<span class="built_in">size</span>;		<span class="comment">/* size of this object file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	align;		<span class="comment">/* alignment as a power of 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Fields</strong></p>
<ul>
<li><p><code>cputype</code></p>
<p>An enumeration value of type cpu_type_t. Specifies the CPU family.</p>
<p>类型cpu_type_t的枚举值。指定CPU族</p>
</li>
<li><p><code>cpusubtype</code></p>
<p>An enumeration value of type cpu_subtype_t. Specifies the specific member of the CPU family<br>on which this entry may be used or a constant specifying all members.</p>
<p>类型cpu_subtype_t的枚举值。指定可以使用此条目的CPU家族的特定成员，或指定所有成员的常量。</p>
</li>
<li><p><code>offset</code></p>
<p>Offset to the beginning of the data for this CPU.</p>
<p>偏移到此CPU的数据开头。</p>
</li>
<li><p><code>size</code></p>
<p>Size of the data for this CPU.</p>
<p>这个CPU的数据大小。</p>
</li>
<li><p><code>align</code></p>
<p>The power of 2 alignment for the offset of the object file for the architecture specified in cputype </p>
<p>within the binary. This is required to ensure that, if this binary is changed, the contents it retains are correctly aligned for virtual memory paging and other uses. </p>
<p>对cputype中指定的体系结构的目标文件的偏移量进行2对齐的能力<br>在二进制。这是为了确保，如果这个二进制文件被更改，它保留的内容被正确对齐，以用于虚拟内存分页和其他用途。</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>Discussion</strong> </p>
<p>  An array of fat_arch data structures appears directly after the fat_header (page 56) data structure of a binary that contains object files for multiple architectures. </p>
<p>  Regardless of the content this data structure describes, all its fields are stored in big-endian byte order. </p>
<p>  fat_arch数据结构数组直接出现在包含多个体系结构目标文件的二进制文件的fat_header(第56页)数据结构之后。<br>  不管这个数据结构描述的内容是什么，它的所有字段都以大端字节顺序存储。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmzcool.top/2020/04/06/machoFormat/">http://lmzcool.top/2020/04/06/machoFormat/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmzcool.top" target="_blank">GN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/06/objc_msgsend/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-9.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">objc_msgsend</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/06/dyld/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/dyld_img/fork@2x.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Dyld</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'f41b211b8f76bcb4c631',
  clientSecret: '18d237316009bcbd6c13816a73a595f20e63e0f9',
  repo: 'https://github.com/gaonian/gaonian.github.io',
  owner: 'gaonian',
  admin: ['gaonian'],
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  perPage: 10,
  distractionFreeMode: false,
  pagerDirection: 'last',
  createIssueManually: false,
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  try {
    document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
  } catch (e) {
    return false
  }
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By GN</div><div class="icp"><a><span>京ICP备19014027号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>