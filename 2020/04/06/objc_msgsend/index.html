<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>objc_msgsend | GN</title><meta name="description" content="objc_msgsend"><meta name="author" content="GN"><meta name="copyright" content="GN"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="objc_msgsend"><meta name="twitter:description" content="objc_msgsend"><meta name="twitter:image" content="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/msgsend_img/objc_msgsend.png"><meta property="og:type" content="article"><meta property="og:title" content="objc_msgsend"><meta property="og:url" content="http://lmzcool.top/2020/04/06/objc_msgsend/"><meta property="og:site_name" content="GN"><meta property="og:description" content="objc_msgsend"><meta property="og:image" content="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/msgsend_img/objc_msgsend.png"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://lmzcool.top/2020/04/06/objc_msgsend/"><link rel="prev" title="One Quick Way to Drastically Reduce your iOS App's Download Size" href="http://lmzcool.top/2020/04/06/reduceApp/"><link rel="next" title="Mac OS X ABI Mach-O File Format Reference" href="http://lmzcool.top/2020/04/06/machoFormat/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: false,
  highlightLang: false,
  highlightShrink: 'none',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">15</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Overview"><span class="toc-number">1.</span> <span class="toc-text">Overview</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instruction-by-Instruction"><span class="toc-number">2.</span> <span class="toc-text">Instruction by Instruction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tagged-Pointer-Handler"><span class="toc-number">3.</span> <span class="toc-text">Tagged Pointer Handler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nil-Handler"><span class="toc-number">4.</span> <span class="toc-text">nil Handler</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/msgsend_img/objc_msgsend.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">GN</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">objc_msgsend</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-06 19:45:55"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-13 22:00:45"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-13</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/06/objc_msgsend/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/06/objc_msgsend/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Every Objective-C object has a class, and every Objective-C class has a list of methods. Each method has a selector, a function pointer to the implementation, and some metadata. The job of <code>objc_msgSend</code> is to take the object and selector that’s passed in, look up the corresponding method’s function pointer, and then jump to that function pointer.</p>
<p>每个Objective-C对象都有一个类，每个Objective-C类都有一个方法列表。每个method都有一个selector、一个指向实现的函数指针和一些元数据。objc_msgSend的工作是获取传入的对象和selector，查找对应方法的函数指针，然后跳转到那个函数指针。</p>
<p>Looking up a method can be extremely complicated. If a method isn’t found on a class, then it needs to continue searching in the superclasses. If no method is found at all, then it needs to call into the runtime’s message forwarding code. If this is the very first message being sent to a particular class, then it has to call that class’s <code>+initialize</code> method.</p>
<p>查找方法可能非常复杂。如果在类中没有找到方法，则需要继续在父类中搜索。如果根本找不到方法，则需要调用runtime的消息转发。如果这是发送到特定类的第一个消息，那么它必须调用该类的<code>+initialize</code>方法。</p>
<p>Looking up a method also needs to be extremely fast in the common case, since it’s done for every method call. This, of course, is in conflict with the complicated lookup process.</p>
<p>在一般情况下，查找方法也需要非常快，因为每个方法调用都需要这样做。当然，这与复杂的查找过程相冲突。</p>
<p>Objective-C’s solution to this conflict is the method cache. Each class has a cache which stores methods as pairs of selectors and function pointers, known in Objective-C as <code>IMP</code>s. They’re organized as a hash table so lookups are fast. When looking up a method, the runtime first consults the cache. If the method isn’t in the cache, it follows the slow, complicated procedure, and then places the result into the cache so that the next time can be fast.</p>
<p>Objective-C解决这个冲突的方法是方法缓存。每个类都有一个缓存，它以selectors和函数指针对的形式存储方法，在Objective-C中称为<code>IMP</code>。它们被组织成hash table，所以查找很快。当查找方法时，runtime首先查询缓存。如果该方法不在缓存中，它将执行缓慢而复杂的过程，然后将结果放入缓存中，以便下一次可以快速执行。</p>
<p><code>objc_msgSend</code> is written in assembly. There are two reasons for this: one is that it’s not possible to write a function which preserves unknown arguments and jumps to an arbitrary function pointer in C. The language just doesn’t have the necessary features to express such a thing. The other reason is that it’s extremely important for <code>objc_msgSend</code> to be fast, so every last instruction of it is written by hand so it can go as fast as possible.</p>
<p><code>objc_msgSend</code>是用汇编语言编写的。这样做有两个原因: 一是不可能编写一个保留未知参数并跳转到c中的任意函数指针的函数。编程语言没有对应的特性来表达这种东西。另一个原因是objc_msgSend的速度非常重要，所以它的每一条指令都是手写的，这样它就可以运行得尽可能快。</p>
<p>Naturally, you don’t want to write the whole complicated message lookup procedure in assembly langauge. It’s not necessary, either, because things are going to be slow no matter what the moment you start going through it. The message send code can be divided into two parts: there’s the <em>fast path</em> in <code>objc_msgSend</code> itself, which is written in assembly, and the <em>slow path</em> implemented in C. The assembly part looks up the method in the cache and jump to it if it’s found. If the method is not in the cache, then it calls into the C code to handle things.</p>
<p>当然，您不希望用汇编语言编写整个复杂的消息查找过程。也没有必要，因为不管你从什么时候开始，事情都会变慢。消息发送代码可以分为两部分: objc_msgSend本身的fast path是用汇编写的，而slow path是用c语言实现的。汇编部分在缓存中查找方法，如果找到，实现跳转。如果方法不在缓存中，那么它会调用C代码来处理事情。</p>
<p>Therefore, when looking at <code>objc_msgSend</code> itself, it does the following:</p>
<ol>
<li>Get the class of the object passed in.</li>
<li>Get the method cache of that class.</li>
<li>Use the selector passed in to look up the method in the cache.</li>
<li>If it’s not in the cache, call into the C code.</li>
<li>Jump to the <code>IMP</code> for the method.</li>
</ol>
<p>How does it do all of that? Let’s see!</p>
<p>因此，当查看 <code>objc_msgSend</code> 本身时，它执行以下操作:</p>
<ol>
<li>获取传入的对象的类</li>
<li>获取该类的方法缓存</li>
<li>使用传入的selector在缓存中查找方法</li>
<li>如果不在缓存中，则调用C代码</li>
<li>跳转到方法的<code>IMP</code></li>
</ol>
<p>让我们看看它是如何做到这些的呢?</p>
<h2 id="Instruction-by-Instruction"><a href="#Instruction-by-Instruction" class="headerlink" title="Instruction by Instruction"></a>Instruction by Instruction</h2><p><code>objc_msgSend</code> has a few different paths it can take depending on circumstances. It has special code for handling things like messages to <code>nil</code>, tagged pointers, and hash table collisions. I’ll start by looking at the most common, straight-line case where a message is sent to a non-<code>nil</code>, non-tagged pointer and the method is found in the cache without any need to scan. I’ll note the various branching-off points as we go through them, and then once we’re done with the common path I’ll circle back and look at all of the others.</p>
<p>根据不同的情况，objc_msgSend可以采用几种不同的路径。它有特殊的代码来处理收到消息为nil的代码、tagged pointers和哈希表冲突等问题。我将从最常见的情况开始，即消息被发送到非nil、非tagged pointer对象，然后在缓存中找到方法，而不需要进行额外的扫描。描述完正常情况后，我们将会回来再看一下其他的一些分支情况。</p>
<p>I’ll list each instruction or group of instructions followed by a description of what it does and why. Just remember to look <em>up</em> to find the instruction any given piece of text is discussing.</p>
<p>我将列出每条指令或一组指令，然后描述它的功能和原因。为什么这么做。我会在罗列出来的指令下面做描述。</p>
<p>Each instruction is preceded by its offset from the beginning of the function. This serves as a counter, and lets you identify jump targets.</p>
<p>每条指令前都会有一个相对函数开始处的偏移量。这可以方便你辨识跳转到哪个目标代码。</p>
<p>ARM64 has 31 integer registers which are 64 bits wide. They’re referred to with the notation <code>x0</code> through <code>x30</code>. It’s also possible to access the lower 32 bits of each register as if it were a separate register, using <code>w0</code> through <code>w30</code>. Registers <code>x0</code> through <code>x7</code> are used to pass the first eight parameters to a function. That means that <code>objc_msgSend</code> receives the <code>self</code> parameter in <code>x0</code> and the selector <code>_cmd</code> parameter in <code>x1</code>.</p>
<p>ARM64有31个64位的整数寄存器。它们用<code>x0</code>到<code>x30</code>来表示。还可以使用<code>w0</code>到<code>w30</code>访问每个寄存器的低32位，就好像它是一个单独的寄存器一样。寄存器<code>x0</code>到<code>x7</code>用于将前八个参数传递给一个函数。这就表示<code>objc_msgSend</code>收到的<code>self</code>参数是保存在<code>x0</code>中，selector <code>_cmd</code>参数在<code>x1</code>里。</p>
<p>Let’s begin!</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0000 cmp     x0, #0x0</span><br><span class="line">0x0004 b.le    0x6c</span><br></pre></td></tr></table></figure>

<p>This performs a signed comparison of <code>self</code> with <code>0</code> and jumps elsewhere if the value is less than or equal to zero. A value of zero is <code>nil</code>, so this handles the special case of messages to nil. This also handles <a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">tagged pointers</a>. Tagged pointers on ARM64 are indicated by setting the high bit of the pointer. (This is an interesting contrast with x86-64, where it’s the low bit.) If the high bit is set, then the value is negative when interpreted as a signed integer. For the common case of <code>self</code> being a normal pointer, the branch is not taken.</p>
<p>这将执行self与0的带符号比较，如果值小于或等于0，则跳转到其他地方。0的值是nil，因此它处理消息为nil的特殊情况。这也处理标记的指针。ARM64上的标记指针是通过设置指针的高位来指示的。(这与x86-64形成了有趣的对比，后者的bit较低。)如果设置了高位，那么在解释为带符号整数时该值为负。对于self是普通指针的常见情况，不会采取分支。</p>
<p>这里执行了 <code>self</code> 和 <code>0</code> 的带符号比较，如果结果小于等于0，则跳转到<code>0x6c</code>。如果值等于0则说明是<code>nil</code>，所以跳转到的地方就是执行当发送消息给<code>nil</code>的情况。这里也处理了<a href="https://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html" target="_blank" rel="noopener">tagged pointer</a>的情况。在ARM64上 通过设置指针的高位来指明是tagged pointer。（x86-64上是设置低位）。如果高位被设置了1，且被作为一个带符号的整型解析的时候，那么值就是负数。一般情况下<code>self</code>是正常的，不会进入这些分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0008 ldr    x13, [x0]</span><br></pre></td></tr></table></figure>

<p>This loads <code>self</code>‘s <code>isa</code> by loading the 64-bit quantity pointed to by <code>x0</code>, which contains <code>self</code>. The <code>x13</code> register now contains the <code>isa</code>.</p>
<p>这条指令通过加载<code>x0</code>所指向的内存中的64位，来加载<code>self</code>的<code>isa</code>指针。因为一个对象的第一个指针就是<code>isa</code>指针。此时<code>x13</code>寄存器包含了<code>isa</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x000c and    x16, x13, #0xffffffff8</span><br></pre></td></tr></table></figure>

<p>ARM64 can use <a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">non-pointer isas</a>. Traditionally the <code>isa</code> points to the object’s class, but non-pointer <code>isa</code> takes advantage of spare bits by cramming some other information into the <code>isa</code> as well. This instruction performs a logical AND to mask off all the extra bits, and leaves the actual class pointer in <code>x16</code>.</p>
<p>ARM64可以使用<a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">非指针的isa</a>。通常isa指针指向的是对象的类，但是非指针的isa利用了备用的bit位，填充了一些其他的信息。这条汇编指令执行了一个逻辑与运算，掩盖掉了所有额外的位，把实际的指向类的指针保存在x16寄存器中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0010 ldp    x10, x11, [x16, #0x10]</span><br></pre></td></tr></table></figure>

<p>This is my favorite instruction in <code>objc_msgSend</code>. It loads the class’s cache information into <code>x10</code> and <code>x11</code>. The <code>ldp</code> instruction loads <em>two</em> registers’ worth of data from memory into the registers named in the first two arguments. The third argument describes where to load the data, in this case at offset <code>16</code> from <code>x16</code>, which is the area of the class which holds the cache information. The cache itself looks like this:</p>
<p>这是<code>objc_msgSend</code>中我最喜欢的指令。它把类的缓存信息加载到<code>x10</code>和<code>x11</code>中。<code>ldp</code>指令从内存中提取了两个寄存器的数据保存到前两个参数指定的寄存器中。第三个参数告诉从哪里加载数据，这里我们看到的是在<code>x16</code>寄存器中的值再偏移16，这块属于保存了持有缓存信息的类的区域。缓存的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;</span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Following the <code>ldp</code> instruction, <code>x10</code> contains the value of <code>_buckets</code>, and <code>x11</code> contains <code>_occupied</code> in its high 32 bits, and <code>_mask</code> in its low 32 bits.</p>
<p><code>ldp</code>指令执行完后，<code>x10</code>包含了<code>_buckets</code>的值，<code>x11</code>在它的高32位保存了<code>_occupied</code>，低32位保存了<code>_mask</code></p>
<p><code>_occupied</code> specifies how many entries the hash table contains, and plays no role in <code>objc_msgSend</code>. <code>_mask</code> is important: it describes the size of the hash table as a convenient AND-able mask. Its value is always a power of two minus 1, or in binary terms something that looks like <code>000000001111111</code> with a variable number of 1s at the end. This value is needed to figure out the lookup index for a selector, and to wrap around the end when searching the table.</p>
<p><code>_occupied</code>指定了哈希表中包含了多少条目，在<code>objc_msgSend</code>中不起什么作用。<code>_mask</code>很重要：它描述了哈希表的尺寸，方便用于与运算的掩码。它的值总是一个2的幂减一，用二进制的方法描述看起来就像是<code>000000001111111</code>，末尾是可变数量的1。通过这个值可以知道selector的查找索引，并在查找表的时候包裹着结尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0014 and    w12, w1, w11</span><br></pre></td></tr></table></figure>

<p>This instruction computes the starting hash table index for the selector passed in as <code>_cmd</code>. <code>x1</code> contains <code>_cmd</code>, so <code>w1</code> contains the bottom 32 bits of <code>_cmd</code>. <code>w11</code> contains <code>_mask</code> as mentioned above. This instruction ANDs the two together and places the result into <code>w12</code>. The result is the equivalent of computing <code>_cmd % table_size</code> but without the expensive modulo operation.</p>
<p>这条指令用于计算传入的selector的起始哈希表的索引，selector是作为<code>_cmd</code>传入的。<code>x1</code>中包含<code>_cmd</code>，所以w1包含了<code>_cmd</code>的低32位。<code>w11</code>包含了上面提到的<code>_mask</code>。这条指令将这两个值做与运算并将结果放到<code>w12</code>中。结果相当于是计算<code>_cmd % table_size</code>，但是避免了开销很大的模运算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0018 add    x12, x10, x12, lsl #4</span><br></pre></td></tr></table></figure>

<p>The index is not enough. To start loading data from the table, we need the actual address to load from. This instruction computes that address by adding the table index to the table pointer. It shifts the table index left by <code>4</code> bits first, which multiplies it by <code>16</code>, because each table bucket is <code>16</code> bytes. <code>x12</code> now contains the address of the first bucket to search.</p>
<p>光有索引还不够。为了从表里加载数据，我们需要一个实际的地址来加载。这个指令通过表索引加上表的指针来计算这个地址。它先将表索引向左位移4，相当于是乘以16，因为每个表的bucket是16字节。<code>x12</code>现在包含了第一个查找的bucket的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x001c ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure>

<p>Our friend <code>ldp</code> makes another appearance. This time it’s loading from the pointer in <code>x12</code>, which points to the bucket to search. Each bucket contains a selector and an <code>IMP</code>. <code>x9</code> now contains the selector for the current bucket, and <code>x17</code> contains the <code>IMP</code>.</p>
<p>我们的朋友<code>ldp</code>又出现了。这次是从保存在<code>x12</code>中的指针加载，这个指针指向了查找的bucket。每个bucket包含一个selector和一个<code>IMP</code>。<code>x9</code>现在包含了当前bucket的selector，<code>x17</code>中包含的是<code>IMP</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0020 cmp    x9, x1</span><br><span class="line">0x0024 b.ne   0x2c</span><br></pre></td></tr></table></figure>

<p>These instructions compare the bucket’s selector in <code>x9</code> with <code>_cmd</code> in <code>x1</code>. If they’re not equal then this bucket does not contain an entry for the selector we’re looking for, and in that case the second instruction jumps to offset <code>0x2c</code>, which handles non-matching buckets. If the selectors do match, then we’ve found the entry we’re looking for, and execution continues with the next instruction.</p>
<p>这两条指令首先对<code>x9</code>中的selector和<code>x1</code>中的<code>cmd</code>做一个比较。如果他们不相等，说明这个bucket中不包含我们正在查找的selector的条目，随后跳转到<code>0x2c</code>的位置，处理bucket不相等的逻辑。如果<code>x9</code>中的selector和我们正在查找的条目匹配，则执行接下去的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0028 br    x17</span><br></pre></td></tr></table></figure>

<p>This performs an unconditional jump to <code>x17</code>, which contains the <code>IMP</code> loaded from the current bucket. From here, execution will continue in the actual implementation of the target method, and this is the end of <code>objc_msgSend&#39;s</code> fast path. All of the argument registers have been left undisturbed, so the target method will receive all passed in arguments just as if it had been called directly</p>
<p>这将执行一个无条件的跳转到<code>x17</code>，包含了从当前bucket中加载的<code>IMP</code>。从这里开始，接下去就是执行目标方法的代码了，<code>objc_msgSend</code>的fast path到此已经结束了。所有参数寄存器不会受到干扰，原封不动的传给目标方法，就好像直接调用了目标方法一样。</p>
<p>When everything is cached and all the stars align, this path can execute in less than 3 nanoseconds on modern hardware.</p>
<p>当所有东西都被缓存，在现代硬件上，这条路径可以在不到3纳秒的时间内执行。</p>
<p>That’s the fast path, how about the rest of the code? Let’s continue with the code for a non-matching bucket.</p>
<p>这是fast path，让我们继续看一下没有匹配到bucket的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x002c cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p><code>x9</code> contains the selector loaded from the bucket. This instruction compares it with zero and jumps to <code>__objc_msgSend_uncached</code> if it’s zero. A zero selector indicates an empty bucket, and an empty bucket means that the search has failed. The target method isn’t in the cache, and it’s time to fall back to the C code that performs a more comprehensive lookup.</p>
<p> <code>__objc_msgSend_uncached</code> handles that. Otherwise, the bucket doesn’t match but isn’t empty, and the search continues.</p>
<p><code>x9</code>包含了从bucket加载到的selector。这条指令先是用它和0作比较，如果等于0则跳转到<code>__objc_msgSend_uncached</code>。这说明这是一个空的bucket，并且意味着这次查找失败了。目标方法不在缓存中，这时候会回到C代码执行更详细的查找。否则就说明bucket不是空的，只是没有匹配，则继续查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0030 cmp    x12, x10</span><br><span class="line">0x0034 b.eq   0x40</span><br></pre></td></tr></table></figure>

<p>This instruction compares the current bucket address in <code>x12</code> with the beginning of the hash table in <code>x10</code>. If they match, it jumps to code that wraps the search back to the end of the hash table. We haven’t seen it yet, but the hash table search being performed here actually runs backwards. The search examines decreasing indexes until it hits the beginning of the table, then it starts over at the end. I’m not sure why it works this way rather than the more common approach of increasing addresses that wrap to the beginning, but it’s a safe bet that it’s because it ends up being faster this way.</p>
<p>Offset <code>0x40</code> handles the wraparound case. Otherwise, execution proceeds to the next instruction.</p>
<p>这里将<code>x12</code>中当前bucket的地址和<code>x10</code>中的，哈希表的开头做比较。如果他们匹配，则跳转到查找到哈希表末端后需要执行的代码块。我们还没有看到，但是哈希表的查找实际上是向后执行。搜索检查会逐渐减小索引，直到它命中表的开头，就结束了。这样做的原因是，表的开头我们是已知的，但是表的结尾是未知的，索引递增的查找需要更多的指令来判断是否已经到达表尾。</p>
<p>偏移量<code>0x40</code>的代码处理了这种情况。如果不匹配，继续执行接下去的指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0038 ldp    x9, x17, [x12, #-0x10]!</span><br></pre></td></tr></table></figure>

<p>Another <code>ldp</code>, once again loading a cache bucket. This time, it loads from offset <code>0x10</code> to the address of the current cache bucket. The exclamation point at the end of the address reference is an interesting feature. This indicates a register write-back, which means that the register is updated with the newly computed value. In this case, it’s effectively doing <code>x12 -= 16</code> in addition to loading the new bucket, which makes <code>x12</code> point to that new bucket.</p>
<p>又出现<code>ldp</code>了，再一次从缓存的bucket中加载。这次他从偏移量为0x10的地方加载当前缓存bucket的地址。地址引用末尾的感叹号是一个有趣的特性。这指定一个寄存器进行回写，意思就是寄存器会更新为计算后的值。这条指令有效的执行了<code>x12 -= 16</code>来加载新的bucket，并使<code>x12</code>指向这个新的bucket</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x003c b      0x20</span><br></pre></td></tr></table></figure>

<p>Now that the new bucket is loaded, execution can resume with the code that checks to see if the current bucket is a match. This loops back up to the instruction labeled <code>0x0020</code> above, and runs through all of that code again with the new values. If it continues to find non-matching buckets, this code will keep running until it finds a match, an empty bucket, or hits the beginning of the table.</p>
<p>现在已经加载了一个新的bucket，所以接下去的执行就要回到之前的检查当前bucket是否匹配的代码。这条指令代表回到上面的<code>0x0020</code>，使用新的值再执行一次所有代码。如果仍然没有找到匹配的bucket，这些代码会持续执行，直到找到匹配的，或者空的bucket，或者命中表的开头。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0040 add    x12, x12, w11, uxtw #4</span><br></pre></td></tr></table></figure>

<p>This is the target for when the search wraps. <code>x12</code> contains a pointer to the current bucket, which in this case is also the first bucket. <code>w11</code> contains the table mask, which is the size of the table. This adds the two together, while also shifting <code>w11</code> left by 4 bits, multiplying it by <code>16</code>. The result is that <code>x12</code> now points to the end of the table, and the search can resume from there.</p>
<p><code>x12</code>包含了当前bucket的指针，这里同样指的是第一个bucket。<code>w11</code>包含了表的掩码，即表的大小。这里将两个值做了相加，同时将<code>w11</code>左移4位。现在<code>x12</code>中的结果是指向表的末尾，并且从这里可以恢复查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0044 ldp    x9, x17, [x12]</span><br></pre></td></tr></table></figure>

<p>The now-familiar <code>ldp</code> loads the new bucket into <code>x9</code> and <code>x17</code>.</p>
<p><code>ldp</code>加载了一个新的bucket到<code>x9</code>和<code>x17</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x0048 cmp    x9, x1</span><br><span class="line">0x004c b.ne   0x54</span><br><span class="line">0x0050 br     x17</span><br></pre></td></tr></table></figure>

<p>This code checks to see if the bucket matches and jumps to the bucket’s <code>IMP</code>. It’s a duplicate of the code at <code>0x0020</code> above.</p>
<p>这段代码检查bucket是否匹配，并跳转到bucket的<code>IMP</code>。这和<code>0x0020</code>处的代码是重复的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0054 cbz    x9, __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>Just like before, if the bucket is empty then it’s a cache miss and execution proceeds into the comprehensive lookup code implemented in C.</p>
<p>就像之前一样，如果bucket为空就说明缓存miss了，接下去用C实现去执行更完整更详尽的查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0058 cmp    x12, x10</span><br><span class="line">0x005c b.eq   0x68</span><br></pre></td></tr></table></figure>

<p>This checks for wraparound <em>again</em>, and jumps to <code>0x68</code> if we’ve hit the beginning of the table a second time. In this case, it jumps into the comprehensive lookup code implemented in C:</p>
<p>这一步再次检查是否已到表头，如果再次命中表头的话就跳转到<code>0x68</code>。这里的情况是直接跳到C实现的，进行全面查找的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0068 b      __objc_msgSend_uncached</span><br></pre></td></tr></table></figure>

<p>This is something that should never actually happen. The table grows as entries are added to it, and it’s never 100% full. Hash tables become inefficient when they’re too full because collisions become too common.</p>
<p>这种情况应该不会发生。表会随着条目的增加而增长，并且它永远不会100%满。哈希表会太满会变得很低效，因为经常会发生哈希碰撞。</p>
<p>Why is this here? A comment in the source code explains:</p>
<p>为什么这段代码会在这，源码中有一段注释做了解释：</p>
<blockquote>
<p>Clone scanning loop to miss instead of hang when cache is corrupt. The slow path may detect any corruption and halt later.</p>
</blockquote>
<blockquote>
<p>当缓存被破坏时，循环扫描将会miss而不是挂起。<br>缓慢的路径（C实现的代码）可能会检测到破坏，并在之后终止。</p>
</blockquote>
<p>I doubt that this is common, but evidently the folks at Apple have seen memory corruption which caused the cache to be filled with bad entries, and jumping into the C code improves the diagnostics.</p>
<p>还有一种情况，当有另一个线程同时修改缓存时会引起这个线程即不命中也不miss。C代码做了额外的工作来解决竞争。之前一个版本的<code>objc_msgSend</code>的做法是错误的，它会立即终止，而不是回到C代码，这样做的话运气不好的时候会发生罕见的崩溃。</p>
<p>The existence of this check should have minimal impact on code that doesn’t suffer from this corruption. Without it, the original loop could be reused, which would save a bit of instruction cache space, but the effect is minimal. This wraparound handler is not the common case anyway. It will only be invoked for selectors that get sorted near the beginning of the hash table, and then only if there’s a collision and all the prior entries are occupied.</p>
<p>额外的二次扫描检查是为了在遇到内存被破坏或者无效对象时，防止陷入无限循环而榨干性能。举个例子，堆损坏能够在缓存中塞满非0的数据，或者设置缓存的掩码为0，缓存不命中就会一直循环执行缓存扫描。额外的检查可以停止循环，将问题转变为崩溃日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0060 ldp    x9, x17, [x12, #-0x10]!</span><br><span class="line">0x0064 b      0x48</span><br></pre></td></tr></table></figure>

<p>The remainder of this loop is the same as before. Load the next bucket into <code>x9</code> and <code>x17</code>, update the bucket pointer in <code>x12</code>, and go back to the top of the loop.</p>
<p>这个循环的其余部分与前面相同。将下一个bucket加载到<code>x9</code>和<code>x17</code>中，更新<code>x12</code>中的bucket指针，然后回到循环的顶部。</p>
<p>That’s the end of the main body of <code>objc_msgSend</code>. What remains are special cases for <code>nil</code> and tagged pointers.</p>
<p><code>objc_msgSend</code>主体的结束。剩下的就是<code>nil</code>和<code>tagged pointers</code>的特殊情况。</p>
<h2 id="Tagged-Pointer-Handler"><a href="#Tagged-Pointer-Handler" class="headerlink" title="Tagged Pointer Handler"></a>Tagged Pointer Handler</h2><p>You’ll recall that the very first instructions checked for those and jumped to offset <code>0x6c</code> to handle them. Let’s continue from there:</p>
<p>您还记得，第一个指令检查了这些值，然后跳到偏移<code>0x6c</code>来处理它们。让我们继续来看:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x006c b.eq    0xa4</span><br></pre></td></tr></table></figure>

<p>We’ve arrived here because <code>self</code> is less than or equal to zero. Less than zero indicates a tagged pointer, and zero is <code>nil</code>. The two cases are handled completely differently, so the first thing the code does here is check to see whether <code>self</code> is <code>nil</code> or not. If <code>self</code> is equal to zero then this instruction branches to <code>0xa4</code>, which is where the <code>nil</code> handler lives. Otherwise, it’s a tagged pointer, and execution continues with the next instruction.</p>
<p>我们来到这是因为 <code>self</code>小于等于0，小于0表明这是一个<code>tagged pointer</code>，而0是<code>nil</code>。</p>
<p>这两种情况的处理方式是完全不同的，因此这里代码要做的第一件事是检查<code>self</code>是否为<code>nil</code>。如果<code>self</code>等于0，那么这个指令会到<code>0xa4</code>，这里处理nil程序所在的位置。否则，它就是一个<code>tagged pointer</code>，将继续执行下一条指令。</p>
<p>Before we move on, let’s briefly discuss how tagged pointers work. Tagged pointers support multiple classes. The top four bits of the tagged pointer (on ARM64) indicate which class the “object” is. They are essentially the tagged pointer’s isa. Of course, four bits isn’t nearly enough to hold a class pointer. Instead, there’s a special table which stores the available tagged pointer classes. The class of a tagged pointer “object” is found by looking up the index in that table which corresponds to the top four bits.</p>
<p>在我们继续往下之前，简单讨论下tagged pointer是如何工作的。tagged pointer支持多个类。tagged pointer的前四位（ARM 64上）指明对象的类是哪个。本质上就是tagged pointer的isa。当然4位不够保存一个类的指针。实际上，有一张特殊的表存储了可用的tagged pointer的类。这个对象的类的查找是通过搜索这张表中的索引，是否对应于这个tagged pointer的前4位。</p>
<p>tagged pointer（至少在AMR64上）也支持扩展类。当前四位都设置为1，接下去的8位用于索引tagged pointer扩展类的表。减少存储他们的代价，就允许运行时能够支持更多的tagged pointer类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0070 mov    x10, #-0x1000000000000000</span><br></pre></td></tr></table></figure>

<p>This sets <code>x10</code> to an integer value with the top four bits set and all other bits set to zero. This will serve as a mask to extract the tag bits from <code>self</code>.</p>
<p>这里将<code>x10</code>设置成一个整型值，只有前四位被设置，其余位都为0。作为掩码用于从<code>self</code>中提取标签位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0074 cmp    x0, x10</span><br><span class="line">0x0078 b.hs   0x90</span><br></pre></td></tr></table></figure>

<p>This checks for an extended tagged pointer. If <code>self</code> is greater than or equal to the value in <code>x10</code>, then that means the top four bits are all set. In that case, branch to <code>0x90</code> which will handle extended classes. Otherwise, use the primary tagged pointer table.</p>
<p>这步检查是为了扩展的tagged pointer。如果<code>self</code>大于等于<code>x10</code>的值，意味着前四位都被设置了。这种情况下会跳转到<code>0x90</code>，处理扩展类。否则，使用<code>tagged pointer</code>主表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x007c adrp   x10, _objc_debug_taggedpointer_classes@PAGE</span><br><span class="line">0x0080 add    x10, x10, _objc_debug_taggedpointer_classes@PAGEOFF</span><br></pre></td></tr></table></figure>

<p>This little song and dance loads the address of <code>_objc_debug_taggedpointer_classes</code>, which is the primary tagged pointer table. ARM64 requires two instructions to load the address of a symbol. This is a standard technique on RISC-like architectures. Pointers on ARM64 are 64 bits wide, and instructions are only 32 bits wide. It’s not possible to fit an entire pointer into one instruction.</p>
<p>这里加载了<code>_objc_debug_taggedpointer_classes</code>的地址，即<code>tagged pointer</code>主表。ARM64需要两条指令来加载一个符号的地址。这是RISC样架构上的一个标准技术。AMR64上的指针是64位宽的，指令是32位宽。所以一个指令无法保存一个完整的指针。</p>
<p>x86 doesn’t suffer from this problem, since it has variable-length instructions. It can just use a 10-byte instruction, where two bytes identify the instruction itself and the target register, and eight bytes hold the pointer value.</p>
<p>x86不会遇到这种问题，因为他有可变长指令。它只能使用10字节的指令，两个字节用于标识指令自己，以及目标寄存器，8个字节用于持有指针的值</p>
<p>On a machine with fixed-length instructions, you load the value in pieces. In this case, only two pieces are needed. The <code>adrp</code> instruction loads the top part of the value, and the <code>add</code> then adds in the bottom part.</p>
<p>在一个固定长度指令的机器上，就需要分块加载。这里我们需要两块，<code>adrp</code>指令加载前半部分的值，<code>add</code>指令添加了后半部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0084 lsr    x11, x0, #60</span><br></pre></td></tr></table></figure>

<p>The tagged class index is in the top four bits of <code>x0</code>. To use it as an index, it has to be shifted right by <code>60</code> bits so it becomes an integer in the range <code>0-15</code>. This instruction performs that shift and places the index into <code>x11</code>.</p>
<p><code>x0</code>的前四位保存了<code>tagged pointer</code>的索引。如果需要把它用于索引，则需要将其右移60位，这样它就变成一个0-15的整数了。这个指令执行了位移并将索引放到<code>x11</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0088 ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure>

<p>This uses the index in <code>x11</code> to load the entry from the table that <code>x10</code> points to. The <code>x16</code> register now contains the class of this tagged pointer.</p>
<p>这里通过<code>x11</code>里的索引到<code>x10</code>所指向的表中查找条目。<code>x16</code>寄存器现在包含了这个<code>tagged pointer</code>的类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x008c b      0x10</span><br></pre></td></tr></table></figure>

<p>With the class in <code>x16</code>, we can now branch back to the main code. The code starting with offset <code>0x10</code> assumes that the class pointer is loaded into <code>x16</code> and performs dispatch from there. The tagged pointer handler can therefore just branch back to that code rather than duplicating logic here.</p>
<p>有了<code>x16</code>中的类后，我们就能够回到主要的逻辑代码了。在偏移量为<code>0x10</code>的代码处开始，使用<code>x16</code>中的类执行后续的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x0090 adrp   x10, _objc_debug_taggedpointer_ext_classes@PAGE</span><br><span class="line">0x0094 add    x10, x10, _objc_debug_taggedpointer_ext_classes@PAGEOFF</span><br></pre></td></tr></table></figure>

<p>The extended tagged class handler looks similar. These two instructions load the pointer to the extended table.</p>
<p>扩展的tagged类执行起来也是一样的。这两条指令加载了指向扩展表的指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0098 ubfx   x11, x0, #52, #8</span><br></pre></td></tr></table></figure>

<p>This instruction loads the extended class index. It extracts <code>8</code> bits starting from bit <code>52</code> in <code>self</code> into <code>x11</code>.</p>
<p>这条指令加载了扩展类的索引。它从<code>self</code>中的第52位开始，提取8位，保存到<code>x11</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x009c ldr    x16, [x10, x11, lsl #3]</span><br></pre></td></tr></table></figure>

<p>Just like before, that index is used to look up the class in the table and load it into <code>x16</code>.</p>
<p>和之前一样，这个索引用于在表中查找类，并存入<code>x16</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00a0 b      0x10</span><br></pre></td></tr></table></figure>

<p>With the class in <code>x16</code>, it can branch back into the main code.</p>
<p>也是一样，回到<code>0x10</code>处的主逻辑代码。</p>
<p>That’s nearly everything. All that remains is the <code>nil</code> handler.</p>
<p>已经快结束了，剩下的就是<code>nil</code>的处理了</p>
<h2 id="nil-Handler"><a href="#nil-Handler" class="headerlink" title="nil Handler"></a>nil Handler</h2><p>Finally we get to the <code>nil</code> handler. Here it is, in its entirety.</p>
<p>以下全部代码就是<code>nil</code>的处理过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x00a4 mov    x1, #0x0</span><br><span class="line">  0x00a8 movi   d0, #0000000000000000</span><br><span class="line">  0x00ac movi   d1, #0000000000000000</span><br><span class="line">  0x00b0 movi   d2, #0000000000000000</span><br><span class="line">  0x00b4 movi   d3, #0000000000000000</span><br><span class="line">  0x00b8 ret</span><br></pre></td></tr></table></figure>

<p>The <code>nil</code> handler is completely different from the rest of the code. There’s no class lookup or method dispatch. All it does for <code>nil</code> is return <code>0</code> to the caller.</p>
<p><code>nil</code>处理程序与代码的其余部分完全不同。没有类查找或方法分派。它对<code>nil</code>所做的一切就是将<code>0</code>返回给调用者。</p>
<p>This task is a bit complicated by the fact that <code>objc_msgSend</code> doesn’t know what kind of return value the caller expects. Is this method returning one integer, or two, or a floating-point value, or nothing at all?</p>
<p>这个任务有点复杂，因为objc_msgSend不知道调用者希望返回什么类型的值。这个方法是返回一个整数，还是两个，或者一个浮点值，或者什么都不返回?</p>
<p>Fortunately, all of the registers used for return values can be safely overwritten even if they’re not being used for this particular call’s return value. Integer return values are stored in <code>x0</code> and <code>x1</code> and floating point return values are stored in vector registers <code>v0</code> through <code>v3</code>. Multiple registers are used for returning smaller <code>struct</code>s.</p>
<p>幸运的是，所有用于返回值的寄存器都可以被安全地覆盖，即使它们不用于此特定调用的返回值。整数返回值存储在<code>x0</code>和<code>x1</code>中，浮点返回值存储在向量寄存器<code>v0</code>到<code>v3</code>中。多个寄存器用于返回更小的结构。</p>
<p>This code clears <code>x1</code> and <code>v0</code> through <code>v3</code>. The <code>d0</code> through <code>d3</code> registers refer to the bottom half of the corresponding <code>v</code> registers, and storing into them clears the top half, so the effect of the four <code>movi</code> instructions is to clear those four registers. After doing this, it returns control to the caller.</p>
<p>此代码清除<code>x1</code>和<code>v0</code>到<code>v3</code>。<code>d0</code>到<code>d3</code>寄存器指的是相应的v寄存器的下半部分，存储到其中会清除上半部分，所以四个movi指令的作用是清除这四个寄存器。完成此操作后，它将控制权返回给调用者。</p>
<p>You might wonder why this code doesn’t clear <code>x0</code>. The answer to that is simple: <code>x0</code> holds <code>self</code> which in this case is <code>nil</code>, so it’s already zero! You can save an instruction by not clearing <code>x0</code> since it already holds the value we want.</p>
<p>您可能想知道为什么这段代码不清除<code>x0</code>。答案很简单: <code>x0</code>持有<code>self</code>，在本例中是<code>nil</code>，所以它已经是零了! 您可以通过不清除<code>x0</code>来节省一条指令</p>
<p>What about larger <code>struct</code> returns that don’t fit into registers? This requires a little cooperation from the caller. Large <code>struct</code> returns are performed by having the caller allocate enough memory for the return value, and then passing the address of that memory in <code>x8</code>. The function then writes to that memory to return a value. <code>objc_msgSend</code> can’t clear this memory, because it doesn’t know how big the return value is. To solve this, the compiler generates code which fills the memory with zeroes before calling <code>objc_msgSend</code>.</p>
<p>That’s the end of the <code>nil</code> handler, and of <code>objc_msgSend</code> as a whole.</p>
<p>对于寄存器不够存储的，更大结构的返回值会怎样？这需要调用者的一些合作。通过调用者来分配足够多的内存存储大型的结构体，并将内存地址传入<code>x8</code>。函数通过写入这块内存来返回值。<code>objc_msgSend</code>不能清除这块内存，因为它不知道返回值到底有多大。为了解决这个问题，编译器生成的代码会在调用<code>objc_msgSend</code>之前用<code>0</code>填满这块内存。</p>
<p>以上就是<code>nil</code>的处理方法，以及<code>objc_msgSend</code>的全部。</p>
<p><img src="/" class="lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/msgsend_img/objc_msgsend.png"  alt="objc_msgSend"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">GN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lmzcool.top/2020/04/06/objc_msgsend/">http://lmzcool.top/2020/04/06/objc_msgsend/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lmzcool.top" target="_blank">GN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://user-gold-cdn.xitu.io/2020/5/11/1720422da38055a1?w=500&amp;h=500&amp;f=png&amp;s=23846" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/06/reduceApp/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">One Quick Way to Drastically Reduce your iOS App's Download Size</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/06/machoFormat/"><img class="next_cover lazyload" data-src="https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/macho_image/machoformat2.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mac OS X ABI Mach-O File Format Reference</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: false,
  verify: false,
  appId: 'v26lyi3lmFjLAjSuqbPuAQWf-gzGzoHsz',
  appKey: 'kXNYMLXOoEDtuSEqWE7SadDa',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" style="background-image: url(https://raw.githubusercontent.com/gaonian/HexoDocument/master/iOS/msgsend_img/objc_msgsend.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2015 - 2020 By GN</div><div class="icp"><a><span>京ICP备19014027号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>